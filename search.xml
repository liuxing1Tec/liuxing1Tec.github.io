<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode精选算法合集(Go)</title>
    <url>/2019/04/08/LeetCode%E7%B2%BE%E9%80%89%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86(Go)/</url>
    <content><![CDATA[<h1 id="算法合集"><a href="#算法合集" class="headerlink" title="算法合集"></a>算法合集</h1><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p><strong>注意</strong>:你不能在买入股票前卖出股票。</p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: [7,1,5,3,6,4]<br><code>输出</code>: 5<br><code>解释</code>: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: [7,6,4,3,1]<br><code>输出</code>: 0<br><code>解释</code>: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	gaps := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(prices)<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(gaps); i++ &#123;</span><br><span class="line">		gaps[i] = prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">	&#125;</span><br><span class="line">	ans := <span class="number">0</span></span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(gaps); i++ &#123;</span><br><span class="line">		sum += gaps[i]</span><br><span class="line">		ans = getMax(ans, sum)</span><br><span class="line">		sum = getMax(sum, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMax</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: [7,1,5,3,6,4]<br><code>输出</code>: 7<br><code>解释</code>: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: [1,2,3,4,5]<br><code>输出</code>: 4<br><code>解释</code>: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
</blockquote>
<p><code>示例 3</code>:</p>
<blockquote>
<p><code>输入</code>: [7,6,4,3,1]<br><code>输出</code>: 0<br><code>解释</code>: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ans := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(prices)<span class="number">-1</span>; i++ &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> prices[i+<span class="number">1</span>] &gt; prices[i] &#123;</span><br><span class="line">			ans += prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a>123. 买卖股票的最佳时机 III</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p><strong>注意</strong>: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: [3,3,5,0,0,3,1,4]<br><code>输出</code>: 6<br><code>解释</code>: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: [1,2,3,4,5]<br><code>输出</code>: 4<br><code>解释</code>: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
</blockquote>
<p><code>示例 3</code>:</p>
<blockquote>
<p><code>输入</code>: [7,6,4,3,1]<br><code>输出</code>: 0<br><code>解释</code>: 在这个情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> intMin = ^<span class="keyword">int</span>(^<span class="keyword">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fstBuy, secBuy := intMin, intMin</span><br><span class="line">	fstSell, secSell := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, vousmevoyez := <span class="keyword">range</span> prices &#123;</span><br><span class="line">		fstBuy = getMax(fstBuy, -vousmevoyez)</span><br><span class="line">		fstSell = getMax(fstSell, fstBuy+vousmevoyez)</span><br><span class="line">		secBuy = getMax(secBuy, fstSell-vousmevoyez)</span><br><span class="line">		secSell = getMax(secSell, secBuy+vousmevoyez)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> secSell</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMax</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a>188. 买卖股票的最佳时机 IV</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p><strong>注意</strong>: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: [2,4,1], k = 2<br><code>输出</code>: 2<br><code>解释</code>: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: [3,2,6,5,0,3], k = 2<br><code>输出</code>: 7<br><code>解释</code>: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。<br>     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">profits</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>] &#123;</span><br><span class="line">			res += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(k <span class="keyword">int</span>, prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> prices == <span class="literal">nil</span> || <span class="built_in">len</span>(prices) == <span class="number">0</span> || k &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> k &gt;= <span class="built_in">len</span>(prices) &#123;</span><br><span class="line">		<span class="keyword">return</span> profits(prices)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ownDp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">	noDp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> ownDp &#123;</span><br><span class="line">		ownDp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, k+<span class="number">1</span>)</span><br><span class="line">		noDp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, k+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> t := <span class="number">0</span>; t &lt;= k; t++ &#123;</span><br><span class="line">		noDp[<span class="number">0</span>][t] = <span class="number">0</span></span><br><span class="line">		ownDp[<span class="number">0</span>][t] = -prices[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	ownDp[<span class="number">0</span>][k] = <span class="number">-1</span>&lt;&lt;<span class="number">32</span> - <span class="number">1</span></span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">		x := i % <span class="number">2</span></span><br><span class="line">		y := (i - <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">		<span class="keyword">for</span> m := <span class="number">0</span>; m &lt;= k; m++ &#123;</span><br><span class="line">			<span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">				noDp[x][m] = max(<span class="number">-1</span>&lt;&lt;<span class="number">32</span><span class="number">-1</span>, noDp[y][m])</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				noDp[x][m] = max(noDp[y][m], ownDp[y][m<span class="number">-1</span>]+prices[i])</span><br><span class="line">			&#125;</span><br><span class="line">			ownDp[x][m] = max(ownDp[y][m], noDp[y][m]-prices[i])</span><br><span class="line">			tmp := max(noDp[x][m], ownDp[x][m])</span><br><span class="line">			res = max(res, tmp)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: coins = [1, 2, 5], amount = 11<br><code>输出</code>: 3<br><code>解释</code>: 11 = 5 + 5 + 1</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: coins = [2], amount = 3<br><code>输出</code>: -1<br><code>说明</code>: 你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> vousmevoyez := <span class="number">1</span>; vousmevoyez &lt;= amount; vousmevoyez++ &#123;</span><br><span class="line">		dp[vousmevoyez] = <span class="number">0x3f3f3f3f</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">		<span class="keyword">for</span> vousmevoyez := coin; vousmevoyez &lt;= amount; vousmevoyez++ &#123;</span><br><span class="line">			<span class="keyword">if</span> dp[vousmevoyez] &gt; dp[vousmevoyez-coin] + <span class="number">1</span> &#123;</span><br><span class="line">				dp[vousmevoyez] = dp[vousmevoyez-coin] + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> dp[amount] == <span class="number">0x3f3f3f3f</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a>518. 零钱兑换 II</h2><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: amount = 5, coins = [1, 2, 5]<br><code>输出</code>: 4<br><code>解释</code>: 有四种方式可以凑成总金额:<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: amount = 3, coins = [2]<br><code>输出</code>: 0<br><code>解释</code>: 只用面额2的硬币不能凑成总金额3。</p>
</blockquote>
<p><code>示例 3</code>:</p>
<blockquote>
<p><code>输入</code>: amount = 10, coins = [10]<br><code>输出</code>: 1</p>
</blockquote>
<p><strong>注意</strong>:</p>
<blockquote>
<p>你可以假设：<br>0 &lt;= amount (总金额) &lt;= 5000<br>1 &lt;= coin (硬币面额) &lt;= 5000<br>硬币种类不超过 500 种<br>结果符合 32 位符号整数</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(amount <span class="keyword">int</span>, coins []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> amount == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(coins) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(coins); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := coins[i]; j &lt;= amount; j++ &#123;</span><br><span class="line">            dp[j] += dp[j - coins[i]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h2><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p>
<p><strong>说明</strong>:<br>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
<p><code>示例</code>:</p>
<blockquote>
</blockquote>
<p><code>输入</code>:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br><code>输出</code>: [1,2,2,3,5,6]</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="keyword">int</span>, m <span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">copy</span>(nums1, nums2)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(nums1[m:], nums2)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m+n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; m+n<span class="number">-1</span>-i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums1[j] &gt; nums1[j+<span class="number">1</span>] &#123;</span><br><span class="line">				nums1[j], nums1[j+<span class="number">1</span>] = nums1[j+<span class="number">1</span>], nums1[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>其他 git 技巧</title>
    <url>/2020/10/16/Git%20%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="其他-git-技巧"><a href="#其他-git-技巧" class="headerlink" title="其他 git 技巧"></a>其他 git 技巧</h1><h2 id="删除文件夹下的-所有-svn或者-git文件夹信息"><a href="#删除文件夹下的-所有-svn或者-git文件夹信息" class="headerlink" title="删除文件夹下的 所有.svn或者.git文件夹信息"></a>删除文件夹下的 所有.svn或者.git文件夹信息</h2><p>两步：</p>
<ol>
<li>cd到该文件夹</li>
<li>删除管理文件</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">//删除文件夹下的所有 .svn 文件</span><br><span class="line">find . -name <span class="string">&quot;.svn&quot;</span> | xargs rm -Rf</span><br><span class="line">//删除文件夹下的所有 .git 文件</span><br><span class="line">find . -name <span class="string">&quot;.git&quot;</span> | xargs rm -Rf</span><br></pre></td></tr></table></figure>

 <a id="more"></a>

<h2 id="git-clone-反复需要输入用户名密码"><a href="#git-clone-反复需要输入用户名密码" class="headerlink" title="git clone 反复需要输入用户名密码"></a>git clone 反复需要输入用户名密码</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>

<h2 id="去掉多余的commit"><a href="#去掉多余的commit" class="headerlink" title="去掉多余的commit"></a>去掉多余的commit</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git rebase -i &lt;commit_ID&gt;</span><br><span class="line">git rebase -i master</span><br><span class="line">git rebase -i HEAD~&lt;num&gt;</span><br><span class="line"></span><br><span class="line">// squash：将这一行的 commit 与上一个 commit 进行合并</span><br><span class="line">// fixup：与 squash 相同，只是不会保留这行 commit 的提交 message 信息</span><br><span class="line"></span><br><span class="line">// 修改上一次 commit 提交的 message</span><br><span class="line">git commit --amend</span><br><span class="line">// 不过只能修正上一次的 commit。如果很多个 commit 之前就有 message 写错，就得用上我们之前说的 git rebase 了</span><br><span class="line"></span><br><span class="line">// 自动标记这一次的 commit 为上一个 commit 的 fix</span><br><span class="line">git commit --fixup &lt;commit&gt;</span><br><span class="line">// 自动组织合并两个 commit</span><br><span class="line">git rebase -i --autosquash</span><br><span class="line"></span><br><span class="line">// 撤销过去的 commit 重建一个新的</span><br><span class="line">git reset HEAD~2</span><br><span class="line">git add .</span><br><span class="line">git commit -am <span class="string">&quot;This is the new feature&quot;</span></span><br><span class="line">git push --force</span><br></pre></td></tr></table></figure>

<h2 id="git-查看本地修改"><a href="#git-查看本地修改" class="headerlink" title="git 查看本地修改"></a>git 查看本地修改</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git status 查看改变的文件列表</span><br><span class="line">git status -s 查看改变的文件列表简化版</span><br><span class="line">git diff或者git diff filename查看不在缓冲区的文件发生的改变</span><br><span class="line">git diff --cached或者git diff --staged查看缓冲区的文件发生的改变</span><br><span class="line">git diff HEAD是git diff和git diff --cached的合并</span><br></pre></td></tr></table></figure>

<h2 id="git将当前修改提交至其他分支"><a href="#git将当前修改提交至其他分支" class="headerlink" title="git将当前修改提交至其他分支"></a>git将当前修改提交至其他分支</h2><blockquote>
<p>当前处于A分支，需要将此次的代码提交至B分支，则在没有进行commit之前可以进行以下操作</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 1、通过git stash将工作区恢复到上次提交的内容，同时备份本地所做的修改</span><br><span class="line">git stash</span><br><span class="line">// 2、然后切换至B分支</span><br><span class="line">git checkout B</span><br><span class="line">// 3、从git栈中获取到最近一次stash进去的内容，恢复工作区的内容，获取之后，会删除栈中对应的stash</span><br><span class="line">git stash pop</span><br><span class="line">// 4、在进行正常的提交代码步骤即可</span><br><span class="line">git add /src/main/..</span><br><span class="line">git commit -m <span class="string">&quot;功能开发&quot;</span></span><br><span class="line">git pull origin &lt;分支名称&gt;</span><br><span class="line">git push origin &lt;分支名称&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="git从本地连接远端仓库-非-git-clone-下来的代码"><a href="#git从本地连接远端仓库-非-git-clone-下来的代码" class="headerlink" title="git从本地连接远端仓库(非 git clone 下来的代码)"></a>git从本地连接远端仓库(非 git clone 下来的代码)</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;url&gt;</span><br><span class="line">git pull --rebase origin master</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="git强制拉取最新代码"><a href="#git强制拉取最新代码" class="headerlink" title="git强制拉取最新代码"></a>git强制拉取最新代码</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/&lt;develop&gt;</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h2 id="git-commit-的特殊姿势"><a href="#git-commit-的特殊姿势" class="headerlink" title="git commit 的特殊姿势"></a>git commit 的特殊姿势</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -s -m  </span><br><span class="line">// 在git <span class="built_in">log</span> 的时候会多展示 signed-off-by  行</span><br><span class="line"></span><br><span class="line">git commit -a -m </span><br><span class="line">// 用于提交跟踪过的文件 ；会自动把修改的文件，先暂存，然后直接commit </span><br><span class="line">// 相当于git add . 与git commit –m “本次提交描述”两句操作合并为一句进行使用。</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 撤销命令详解</title>
    <url>/2020/10/16/Git%20%E6%92%A4%E9%94%80%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="撤销命令详解"><a href="#撤销命令详解" class="headerlink" title="撤销命令详解"></a>撤销命令详解</h1><h2 id="修改最后一次commit的内容"><a href="#修改最后一次commit的内容" class="headerlink" title="修改最后一次commit的内容"></a>修改最后一次commit的内容</h2><p>文件修改后<code>git add</code>了，也<code>git commit</code>了，发现哪里错了或者是漏<code>add</code>了一个文件，可以先<code>git add file</code>后，再<code>git commit –amend</code>这样只会记录一次<code>commit</code>（相当于将两次<code>commit</code>合并成了一次<code>commit</code>）。</p>
<h2 id="取消加入暂存区的文件"><a href="#取消加入暂存区的文件" class="headerlink" title="取消加入暂存区的文件"></a>取消加入暂存区的文件</h2><p>不小心用了<code>git add .</code>将所有文件加入了暂存区或者是<code>add</code>多了文件，可以使用<code>git reset HEAD &lt;file&gt;</code>将文件拉回到已修改但是未提交到暂存区的状态。（在<code>add</code>后，通过<code>git status</code>可以看到相应提示，教你如何撤销提交）</p>
 <a id="more"></a>

<h2 id="取消对当前目录下文件的修改"><a href="#取消对当前目录下文件的修改" class="headerlink" title="取消对当前目录下文件的修改"></a>取消对当前目录下文件的修改</h2><p>不小心将文件改崩了，或者发现文件根本没必要修改，可以用<code>git checkout — &lt;file&gt;</code>取消工作区的文件的修改。（同样的，在修改文件后，通过<code>git status</code>可以看到相应提示）</p>
<h2 id="reset-命令的3种模式"><a href="#reset-命令的3种模式" class="headerlink" title="reset 命令的3种模式"></a>reset 命令的3种模式</h2><p><code>git reset –option &lt;commitid&gt;</code>是回滚命令，option 有三个参数可选：</p>
<ol>
<li><code>git reset –mixed</code>，这也是默认方式（即不带参数默认是这种），回退暂存区和版本库信息，工作区的源码不会变化，可以重新add，重新commit。</li>
<li><code>git reset –soft</code>，回退版本库信息，暂存区和工作区都不会变化，如果还要提交，直接commit即可。</li>
<li><code>git reset –hard</code>，彻底回退，3个区都回退到历史某个版本。</li>
</ol>
<h2 id="回滚某个文件"><a href="#回滚某个文件" class="headerlink" title="回滚某个文件"></a>回滚某个文件</h2><ol>
<li><code>git log –pretty=oneline &lt;file&gt;</code>可以查看某个文件的修改历史。</li>
<li><code>git show commit_id &lt;file&gt;</code>可以查看对应某个<code>commit</code>时期<code>file</code>的内容。</li>
<li><code>git reset commit_id &lt;file&gt;</code>可以将<code>file</code>回退到某个版本</li>
<li>执行完第3步后提示：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Unstaged changes after reset:</span><br><span class="line">M       README.md</span><br></pre></td></tr></table></figure>

<p>执行<code>git status</code>，提示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br></pre></td></tr></table></figure>

<p>执行<code>git checkout — &lt;file&gt;</code>后，README.md成功回滚到指定版本。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS 使用技巧</title>
    <url>/2020/10/01/MacOS%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="MacOS-使用技巧"><a href="#MacOS-使用技巧" class="headerlink" title="MacOS 使用技巧"></a>MacOS 使用技巧</h1><h1 id="VIM常用快捷键"><a href="#VIM常用快捷键" class="headerlink" title="VIM常用快捷键"></a>VIM常用快捷键</h1><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ </span><br><span class="line">// 光标移动到最后一个字符</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> </span><br><span class="line">// 光标移动到首位</span><br><span class="line"></span><br><span class="line">ZZ </span><br><span class="line">// 保存退出</span><br><span class="line"></span><br><span class="line">dt<span class="symbol">&lt;character&gt;</span></span><br><span class="line">// 删除到该字符</span><br><span class="line"></span><br><span class="line"><span class="keyword">f</span><span class="symbol">&lt;character&gt;</span></span><br><span class="line">// 将光标移动到，从光标当前位置开始第一个该字符的位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h1><h2 id="brew-相关命令"><a href="#brew-相关命令" class="headerlink" title="brew 相关命令"></a>brew 相关命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">更新：brew update</span><br><span class="line">查看版本：brew -v</span><br><span class="line">帮助信息：brew -h</span><br><span class="line"></span><br><span class="line">查询软件的详细信息：brew info &lt;软件名&gt;</span><br><span class="line">查看安装列表：brew list</span><br><span class="line"></span><br><span class="line">安装软件包：brew install &lt;软件名&gt;</span><br><span class="line">卸载软件包：brew uninstall &lt;软件名&gt;</span><br><span class="line">彻底卸载指定软件，包括旧版本：brew uninstall --force &lt;软件名&gt;</span><br><span class="line"></span><br><span class="line">搜索软件：brew search &lt;正则表达式&#x2F;软件名&gt;</span><br><span class="line">更新所有软件包：brew upgrade &lt;软件名&gt;</span><br><span class="line">查询有更新版本的软件：brew outdated</span><br><span class="line">清理指定软件的过时包：brew cleanup &lt;软件名&gt;</span><br><span class="line">清理所有的过时软件：brew cleanup</span><br><span class="line">列出需要清理的内容：brew cleanup -n</span><br><span class="line"></span><br><span class="line">用浏览器打开相关包的页面：brew home &lt;软件名&gt;</span><br><span class="line">显示包依赖：brew deps &lt;软件名&gt;</span><br><span class="line">锁定某个包：brew pin $FORMULA</span><br><span class="line">取消锁定：brew unpin $FORMULA</span><br><span class="line">查看已安装的包的依赖，树形显示：brew deps --installed --tree </span><br></pre></td></tr></table></figure>

<h2 id="brew-应用包"><a href="#brew-应用包" class="headerlink" title="brew 应用包"></a>brew 应用包</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tree</span><br><span class="line">// 显示目录层级关系</span><br><span class="line"></span><br><span class="line">youtube-dl</span><br><span class="line">// 下载youtube视频</span><br><span class="line"></span><br><span class="line">ncdu</span><br><span class="line">// 查看磁盘占用情况</span><br><span class="line"></span><br><span class="line">ffmpeg</span><br><span class="line">// 音视频格式转换转码</span><br><span class="line"></span><br><span class="line">you-get</span><br><span class="line">// 下载爬取视频</span><br><span class="line"></span><br><span class="line">thefuck</span><br><span class="line">// 自动重输正确的建议命令</span><br></pre></td></tr></table></figure>

<h1 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h1><h2 id="zsh-插件的使用"><a href="#zsh-插件的使用" class="headerlink" title="zsh 插件的使用"></a>zsh 插件的使用</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git</span><br><span class="line">// git 快捷指令 由↓查看快捷指令</span><br><span class="line">// cat ~/.oh-my-zsh/plugins/git/git.plugin.zsh</span><br><span class="line"></span><br><span class="line">gitignore</span><br><span class="line">// 自动生成gitignore文件</span><br><span class="line">// gi &lt;c/c++/python/...&gt; &gt; .gitignore</span><br><span class="line"></span><br><span class="line">zsh_reload</span><br><span class="line">// src 重载zsh</span><br><span class="line"></span><br><span class="line">git-open</span><br><span class="line">// 在任何一个git目录，输入git-open 就可以打开github对应的页面</span><br><span class="line"></span><br><span class="line">safe-paste</span><br><span class="line">// 当你往 zsh 粘贴脚本时，它不会被立刻运行</span><br><span class="line"></span><br><span class="line">extract</span><br><span class="line">// 万能解压命令</span><br><span class="line"></span><br><span class="line">gh-md-toc</span><br><span class="line">// md目录生成工具，<span class="built_in">alias</span> -&gt; mdtoc</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title>linux/MacOS 操作技巧合集</title>
    <url>/2020/10/01/linux:MacOS%20%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h1 id="访问本机接口"><a href="#访问本机接口" class="headerlink" title="访问本机接口"></a>访问本机接口</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl --location --request POST <span class="string">&#x27;http://本机IP/接口&#x27;</span> --header <span class="string">&#x27;Content-Type: application/x-www-form-urlencoded&#x27;</span> --data-urlencode <span class="string">&#x27;data=[&#123;&quot;type&quot;:1,&quot;brand&quot;:&quot;GE&quot;,&quot;ae_oe_code&quot;:&quot;9261317&quot;&#125;]&#x27;</span></span><br><span class="line"></span><br><span class="line">curl --location --request GET <span class="string">&#x27;http://127.0.0.1:18016/honda/oe_by_std_name?vin=LVHRM1836D5019492&amp;std_name=%E6%B3%A2%E7%AE%B1%E6%B2%B9&#x27;</span></span><br></pre></td></tr></table></figure>

 <a id="more"></a>

<h1 id="查看-log-技巧"><a href="#查看-log-技巧" class="headerlink" title="查看 log 技巧"></a>查看 log 技巧</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tail -f &lt;file&gt; i//自动刷新查看文件，适用于查看日志，相对于cat的优点在于不用全部打开，只会看最新的几行，看大文件时不会那么容易卡死</span><br><span class="line"></span><br><span class="line">//查看nginx日志，并进行过滤</span><br><span class="line">tail -f /var/<span class="built_in">log</span>/nginx/access.log | grep XXX </span><br></pre></td></tr></table></figure>


<h1 id="vim-常用快捷键"><a href="#vim-常用快捷键" class="headerlink" title="vim 常用快捷键"></a>vim 常用快捷键</h1><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ </span><br><span class="line">// 光标移动到最后一个字符</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> </span><br><span class="line">// 光标移动到首位</span><br><span class="line"></span><br><span class="line">ZZ </span><br><span class="line">// 保存退出</span><br><span class="line"></span><br><span class="line">dt<span class="symbol">&lt;character&gt;</span></span><br><span class="line">// 删除到该字符</span><br><span class="line"></span><br><span class="line"><span class="keyword">f</span><span class="symbol">&lt;character&gt;</span></span><br><span class="line">// 将光标移动到，从光标当前位置开始第一个该字符的位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="常用系统命令"><a href="#常用系统命令" class="headerlink" title="常用系统命令"></a>常用系统命令</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将目前目录及其子目录下所有延伸档名是 c 的文件列出来。</span></span><br><span class="line">find . -name <span class="string">&quot;*.c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目前目录其其下子目录中所有一般文件列出</span></span><br><span class="line">find . -<span class="built_in">type</span> f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目前目录及其子目录下所有最近 20 天内更新过的文件列出</span></span><br><span class="line">find . -ctime -20</span><br></pre></td></tr></table></figure>

<h2 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h2><h3 id="brew-相关命令"><a href="#brew-相关命令" class="headerlink" title="brew 相关命令"></a>brew 相关命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">更新：brew update</span><br><span class="line">查看版本：brew -v</span><br><span class="line">帮助信息：brew -h</span><br><span class="line"></span><br><span class="line">查询软件的详细信息：brew info &lt;软件名&gt;</span><br><span class="line">查看安装列表：brew list</span><br><span class="line"></span><br><span class="line">安装软件包：brew install &lt;软件名&gt;</span><br><span class="line">卸载软件包：brew uninstall &lt;软件名&gt;</span><br><span class="line">彻底卸载指定软件，包括旧版本：brew uninstall --force &lt;软件名&gt;</span><br><span class="line"></span><br><span class="line">搜索软件：brew search &lt;正则表达式&#x2F;软件名&gt;</span><br><span class="line">更新所有软件包：brew upgrade &lt;软件名&gt;</span><br><span class="line">查询有更新版本的软件：brew outdated</span><br><span class="line">清理指定软件的过时包：brew cleanup &lt;软件名&gt;</span><br><span class="line">清理所有的过时软件：brew cleanup</span><br><span class="line">列出需要清理的内容：brew cleanup -n</span><br><span class="line"></span><br><span class="line">用浏览器打开相关包的页面：brew home &lt;软件名&gt;</span><br><span class="line">显示包依赖：brew deps &lt;软件名&gt;</span><br><span class="line">锁定某个包：brew pin $FORMULA</span><br><span class="line">取消锁定：brew unpin $FORMULA</span><br><span class="line">查看已安装的包的依赖，树形显示：brew deps --installed --tree </span><br></pre></td></tr></table></figure>

<h3 id="brew-应用包"><a href="#brew-应用包" class="headerlink" title="brew 应用包"></a>brew 应用包</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tree</span><br><span class="line">// 显示目录层级关系</span><br><span class="line"></span><br><span class="line">youtube-dl</span><br><span class="line">// 下载youtube视频</span><br><span class="line"></span><br><span class="line">ncdu</span><br><span class="line">// 查看磁盘占用情况</span><br><span class="line"></span><br><span class="line">ffmpeg</span><br><span class="line">// 音视频格式转换转码</span><br><span class="line"></span><br><span class="line">you-get</span><br><span class="line">// 下载爬取视频</span><br><span class="line"></span><br><span class="line">thefuck</span><br><span class="line">// 自动重输正确的建议命令</span><br></pre></td></tr></table></figure>

<h2 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git</span><br><span class="line">// git 快捷指令 由↓查看快捷指令</span><br><span class="line">// cat ~/.oh-my-zsh/plugins/git/git.plugin.zsh</span><br><span class="line"></span><br><span class="line">gitignore</span><br><span class="line">// 自动生成gitignore文件</span><br><span class="line">// gi &lt;c/c++/python/...&gt; &gt; .gitignore</span><br><span class="line"></span><br><span class="line">zsh_reload</span><br><span class="line">// src 重载zsh</span><br><span class="line"></span><br><span class="line">git-open</span><br><span class="line">// 在任何一个git目录，输入git-open 就可以打开github对应的页面</span><br><span class="line"></span><br><span class="line">safe-paste</span><br><span class="line">// 当你往 zsh 粘贴脚本时，它不会被立刻运行</span><br><span class="line"></span><br><span class="line">extract</span><br><span class="line">// 万能解压命令</span><br><span class="line"></span><br><span class="line">gh-md-toc</span><br><span class="line">// md目录生成工具，<span class="built_in">alias</span> -&gt; mdtoc</span><br></pre></td></tr></table></figure>

<h2 id="Hexo版本升级"><a href="#Hexo版本升级" class="headerlink" title="Hexo版本升级"></a>Hexo版本升级</h2><p>1、全局升级<code>hexo-cli</code>，先<code>hexo version</code>查看当前版本，然后<code>npm i hexo-cli -g</code>，再次<code>hexo version</code>查看是否升级成功。</p>
<p>2、使用<code>npm install -g npm-check</code>和<code>npm-check</code>，检查系统中的插件是否有升级的，可以看到自己前面都安装了那些插件</p>
<p>3、使用<code>npm install -g npm-upgrade</code>和<code>npm-upgrade</code>，升级系统中的插件</p>
<p>4、使用<code>npm update -g</code>和<code>npm update --save</code></p>
<p>如果遇到报错，需要重装xcode-cli：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /Library/Developer/CommandLineTools</span><br><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.07-2020.09 学习总结</title>
    <url>/2020/10/01/2020.07-2020.09%20%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div align='center' ><font size='70'>2020.07-2020.09 学习总结</font></div>

<hr>
<p><span id="toc"></span></p>
<p>[TOC]</p>
<hr>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p><a href="#toc">&lt;返回目录&gt;</a></p>
<h2 id="C-基于容器（docker）的开发环境配置"><a href="#C-基于容器（docker）的开发环境配置" class="headerlink" title="C++ 基于容器（docker）的开发环境配置"></a>C++ 基于容器（docker）的开发环境配置</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<h3 id="配置ODBC"><a href="#配置ODBC" class="headerlink" title="配置ODBC"></a>配置ODBC</h3><p>在<strong>安装</strong>配置之前，需要先大概了解一下 MyODBC 的架构，MyODBC 体系结构建立在 5 个组件上，如下图所示：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggwm30f77xj30a20b3aah.jpg"></p>
 <a id="more"></a>

<p><strong>Driver Manager</strong><br>负责管理应用程序和驱动程序间的通信，主要功能包括：解析 DSN (数据源名称，ODBC 的数据源名称在 odbc.ini 文件中配置)，加载和卸载驱动程序，处理 ODBC 调用，将其传递给驱动程序。</p>
<p><strong>ODBC.INI</strong><br>odbc.ini 是 ODBC 配置文件，记录了连接到服务器所需的驱动信息和数据库信息。Driver Manager 将使用它来确定加载哪个驱动程序（使用数据源名 DSN ）。驱动程序将根据指定的DSN来读取连接参数。</p>
<p><strong>Connector/ODBC(MyODBC驱动程序)</strong><br>实现 ODBC API 所提供的功能，它负责处理 ODBC 函数调用，将 SQL 请求提交给 MySQL 服务器，并将结果返回给应用程序。</p>
<p>在 Linux 下配置 mysql ODBC 需要有以下步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 安装 Driver Manager，本案例使用 unixODBC 来作为 Driver Manager。</span><br><span class="line">2. 安装 MySQL 驱动程序，本案例使用 Connector&#x2F;ODBC。</span><br><span class="line">3. 配置 ODBC.INI</span><br></pre></td></tr></table></figure>

<p><strong>第一步：下载安装包</strong></p>
<p>需要下载两个安装包 <code>unixODBC 2.3.0</code> 和 <code>mysql Connector/ODBC 3.51</code><br>unixODBC 源码包：<code>ftp://ftp.unixodbc.org/pub/unixODBC/unixODBC-2.3.0.tar.gz</code><br>mysql Connector/ODBC 源码包：<code>http://dev.mysql.com/downloads/connector/odbc/3.51.html%23downloads</code><br>选择</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">版本：5.1.11</span><br><span class="line">平台：Oracle&amp;Red Hat Linux6</span><br><span class="line">下载：mysql-connector-odbc-5.1.11-linux-el6-x86-64bit.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>第二步：安装 unixODBC</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf unixODBC-2.3.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> unixODBC-2.3.4</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/unixODBC-2.3.4 --includedir=/usr/include --libdir=/usr/<span class="built_in">local</span>/lib -bindir=/usr/bin --sysconfdir=/usr/<span class="built_in">local</span>/etc</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装完成后,可以在/usr/bin目录下有下面的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root      75312 Nov 1 16:22 odbcinst</span><br><span class="line">-rwxr-xr-x 1 root root      10922 Nov 1 16:22 odbc_config</span><br><span class="line">-rwxr-xr-x 1 root root      37650 Nov 1 16:22 iusql</span><br><span class="line">-rwxr-xr-x 1 root root      44400 Nov 1 16:22 isql</span><br><span class="line">-rwxr-xr-x 1 root root      95903 Nov 1 16:22 dltest</span><br></pre></td></tr></table></figure>
<p>在/usr/local/lib目录下面有这些文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root 422955 Nov 1 16:22 libodbcinst.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     20 Nov 1 16:22 libodbcinst.so.1 -&gt; libodbcinst.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     20 Nov 1 16:22 libodbcinst.so -&gt; libodbcinst.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    981 Nov 1 16:22 libodbcinst.la</span><br><span class="line">-rwxr-xr-x 1 root root 169157 Nov 1 16:22 libodbc.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     16 Nov 1 16:22 libodbc.so.1 -&gt; libodbc.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     16 Nov 1 16:22 libodbc.so -&gt; libodbc.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    957 Nov 1 16:22 libodbc.la</span><br><span class="line">-rwxr-xr-x 1 root root 489405 Nov 1 16:22 libodbccr.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     18 Nov 1 16:22 libodbccr.so.1 -&gt; libodbccr.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     18 Nov 1 16:22 libodbccr.so -&gt; libodbccr.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    969 Nov 1 16:22 libodbccr.la</span><br></pre></td></tr></table></figure>

<p><strong>第三步：安装 mysql Connector/ODBC</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf mysql-connector-odbc-5.1.11-linux-el6-x86-64bit.tar.gz</span><br><span class="line"><span class="built_in">cd</span> mysql-connector-odbc-5.1.11-linux-el6-x86-64bit/lib</span><br><span class="line">cp libmyodbc5.so /usr/<span class="built_in">local</span>/lib</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> bin</span><br></pre></td></tr></table></figure>
<p><strong>注册驱动</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./myodbc-installer -d -a -n <span class="string">&quot;MySQL ODBC 5.1 Driver&quot;</span> -t <span class="string">&quot;DRIVER=/usr/local/lib/libmyodbc5.so;SETUP=/usr/local/lib/libmyodbc5.so&quot;</span></span><br><span class="line"></span><br><span class="line">//odbc 5.3及以上是libmyodbc5a.so和libmyodbc5w.so。其中c5a是Ansi版，c5w是Unicode版</span><br></pre></td></tr></table></figure>
<p>假如注册的时候报错找不到libodbc.so.2,但是之前确实装成功了unixodbc,可能是因为系统找不到/usr/local/lib库目录，需要添加系统搜索库目录路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line">//将/usr/<span class="built_in">local</span>/lib直接添加在配置文件里</span><br><span class="line"></span><br><span class="line">ldconfig</span><br><span class="line"></span><br><span class="line">//重新缓存配置文件(为了加快程序执行时对共享库的定位速度，避免使用搜索路径查找共享库的低效率，所以是直接读取库列表文件/etc/ld.so.cache缓存文件并从中进行搜索的)</span><br></pre></td></tr></table></figure>

<p><strong>第四步：配置 ODBC.INI</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">odbcinst -j</span><br><span class="line"></span><br><span class="line">unixODBC 2.3.1</span><br><span class="line">DRIVERS............: /etc/odbcinst.ini</span><br><span class="line">SYSTEM DATA SOURCES: /etc/odbc.ini</span><br><span class="line">FILE DATA SOURCES..: /etc/ODBCDataSources</span><br><span class="line">USER DATA SOURCES..: /root/.odbc.ini</span><br><span class="line">SQLULEN Size.......: 8</span><br><span class="line">SQLLEN Size........: 8</span><br><span class="line">SQLSETPOSIROW Size.: 8</span><br></pre></td></tr></table></figure>
<p>编辑文件<code>/etc/odbc.ini</code>，把下面的内容加上去。不同版本<code>mysql</code>驱动的配置方法，有细微差异。此处使用的版本是<code>mysql Connector 3.51</code>。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqlDSN]</span></span><br><span class="line"><span class="attr">Driver</span>      = /usr/local/lib/libmyodbc5.so</span><br><span class="line"><span class="attr">Description</span> = MyODBC <span class="number">5</span> Driver DSN</span><br><span class="line"><span class="attr">SERVER</span>      = <span class="number">172.31</span>.<span class="number">108.133</span></span><br><span class="line"><span class="attr">PORT</span>        = <span class="number">3306</span></span><br><span class="line"><span class="attr">USER</span>        = root</span><br><span class="line"><span class="attr">Password</span>    = <span class="number">123456</span></span><br><span class="line"><span class="attr">Database</span>    = PM</span><br><span class="line"><span class="attr">OPTION</span>      = <span class="number">3</span></span><br><span class="line"><span class="attr">charset</span>     = UTF8</span><br></pre></td></tr></table></figure>

<p><strong>第五步：设置环境变量</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> DBCINI=/usr/<span class="built_in">local</span>/etc/odbc.ini</span><br><span class="line"><span class="built_in">export</span> DBCSYSINI=/usr/<span class="built_in">local</span>/etc</span><br></pre></td></tr></table></figure>

<p><strong>第六步：重启电脑</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<p><strong>第七步：测试ODBC配置是否成功</strong><br>isql 是 unixODBC 带的一个 ODBC 客户端访问工具，使用<code>isql +数据源名</code>来访问目标数据库。如果 ODBC 配置正确，会显示下面的界面。在<code>SQL&gt;</code>提示符下输入 SQL 语句查询数据库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">isql mysqlDSN</span><br><span class="line"></span><br><span class="line">+---------------------------------------+</span><br><span class="line">| Connected!                           |</span><br><span class="line">|                                      |</span><br><span class="line">| sql-statement                        |</span><br><span class="line">| <span class="built_in">help</span> [tablename]                     |</span><br><span class="line">| quit                                 |</span><br><span class="line">|                                      |</span><br><span class="line">+---------------------------------------+</span><br></pre></td></tr></table></figure>

<p><strong>遇到的问题：</strong></p>
<ul>
<li>问题1<br>在第三步安装 mysql connector/ODBC 中的注册驱动中，我总是会出现<code>./myodbc-installer: error while loading shared libraries: libodbc.so.2: cannot open shared object file: No such file or directory.</code>这种错误，后来发现错误有两点：<ol>
<li>我下载的是 mysql-connector-5.3.6 ，可能版本比较高，而我初次下载用的是unixODBC-2.3.0，版本较低，里面没有 libodbc.so.2 这个库文件（可以用<code>find / -name libodbc.so.2</code>来查）。后来下载了一个 unixODBC-2.3.4 就好了。</li>
<li>改了版本之后，我发现还是有这个错误，在网上查了下，说是程序查找默认路径为 /lib 和 /usr/lib，而我的 libmyodbc5w.so 和 libmmyodbc5a.so 都在 /usr/local/lib 中，所以查不到，所以需要设置一下共享库路径，以下我贴一下网上查的内容：</li>
</ol>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/ld.so.conf</span><br><span class="line">include ld.so.conf.d/*.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/usr/local/lib&quot;</span> &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>

<ul>
<li><p>问题2<br>如果共享库文件安装到了其它非<code>/lib</code>或<code>/usr/lib</code>目录下，但是又不想在<code>/etc/ld.so.conf</code>中加路径(或者是没有权限加路径)。那可以 export 一个全局变量<code>LD_LIBRARY_PATH</code>，然后运行程序的时候就会去这个目录中找共享库。<code>LD_LIBRARY_PATH</code>的意思是告诉 loader 在哪些目录中可以找到共享库。<br>可以设置多个搜索目录，这些目录之间用冒号分隔开。<br>比如：<br>安装了一个 mysql 到<code>/usr/local/mysql</code>目录下，其中有一大堆库文件在<code>/usr/local/mysql/lib</code>下面，则可以在 .bashrc 或 .bash_profile 或 shell 里加入以下语句即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>
<p>一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用。</p>
</li>
<li><p>问题3<br>如果程序需要的库文件比系统目前存在的村文件版本低，可以做一个链接<br>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error while loading shared libraries: libncurses.so.4: cannot open shared</span><br><span class="line">object file: No such file or directory</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /usr/lib/libncu*</span><br><span class="line">/usr/lib/libncurses.a   /usr/lib/libncurses.so.5</span><br><span class="line">/usr/lib/libncurses.so  /usr/lib/libncurses.so.5.3</span><br></pre></td></tr></table></figure>
<p>可见虽然没有 libncurses.so.4，但有 libncurses.so.5，是可以向下兼容的<br>建一个链接就好了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s  /usr/lib/libncurses.so.5.3  /usr/lib/libncurses.so.4</span><br></pre></td></tr></table></figure>
</li>
<li><p>问题4<br>isql 连接数据库失败，重新注册驱动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/myodbc-installer  -d -a -n <span class="string">&quot;MySQL_UNICODE&quot;</span>  -t <span class="string">&quot;DRIVER=/usr/lib64/libmyodbc8w.so;SETUP=/usr/lib64/libmyodbc8w.so&quot;</span></span><br><span class="line">/usr/bin/myodbc-installer  -d -a -n <span class="string">&quot;MySQL_ANSI&quot;</span>  -t <span class="string">&quot;DRIVER=/usr/lib64/libmyodbc8a.so;SETUP=/usr/lib64/libmyodbc8a.so&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用 rpm 命令查看 rpm 包的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qpl xxx.rpm</span><br></pre></td></tr></table></figure>
<p>可以看到<code>mysql-connector-odbc-8.0.20-1.el7.x86_64.rpm</code>的包内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">warning: mysql-connector-odbc-8.0.20-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">/usr/bin/myodbc-installer</span><br><span class="line">/usr/lib64/libmyodbc8a.so</span><br><span class="line">/usr/lib64/libmyodbc8w.so</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/ChangeLog</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/INFO_BIN</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/INFO_SRC</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/LICENSE.txt</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/README.txt</span><br></pre></td></tr></table></figure>
<p>可以知道 rpm 包 安装的时候各个基础件的安装位置。</p>
</li>
</ul>
<h3 id="NGINX-的配置与基础命令"><a href="#NGINX-的配置与基础命令" class="headerlink" title="NGINX 的配置与基础命令"></a>NGINX 的配置与基础命令</h3><p><strong>nginx 配置</strong></p>
<p><strong>查看 nginx 配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/nginx/nginx.conf</span><br><span class="line">cat /etc/nginx/conf.d/xxxxxxxx.conf</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">可以看到 `stdname` 对应的监听端口设置 nginx 监听 18026 并转发至 stdnameSvr 的 监听端口 19026。</span><br><span class="line"></span><br><span class="line">```conf</span><br><span class="line">server &#123;</span><br><span class="line">        listen       18026;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location /stdname/  &#123;</span><br><span class="line">                fastcgi_pass   127.0.0.1:19026;</span><br><span class="line">                fastcgi_index index.cgi;</span><br><span class="line">                <span class="comment">#fastcgi_param SCRIPT_FILENAME fcgi$fastcgi_script_name;</span></span><br><span class="line">                include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<p><strong>验证 nginx 配置文件是否正确</strong></p>
<p>进入 nginx 安装目录 sbin 下，输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./nginx -t</span><br></pre></td></tr></table></figure>

<p>看到如下显示 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx: the configuration file /.../nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /.../nginx.conf <span class="built_in">test</span> is successful</span><br></pre></td></tr></table></figure>

<p>说明配置文件正确！</p>
<p><strong>运行 nginx</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/path_of_nginx/nginx -c /path_of_nginx.conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p><code>-c</code>：指定 nginx 运行时使用的 conf 文件路径<br><code>-t</code>：加上<code>-t</code>可以测试 nginx 配置是否正确</p>
<p><strong>停止 nginx</strong></p>
<p>查看进程号然后杀死进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br><span class="line"><span class="built_in">kill</span> -QUIT &lt;pid_of_nginx&gt;   //从容停止</span><br><span class="line"><span class="built_in">kill</span> -TERM &lt;pid_of_nginx&gt;   //快速停止</span><br><span class="line"><span class="built_in">kill</span> -INT &lt;pid_of_nginx&gt;    //快速停止</span><br><span class="line"><span class="built_in">kill</span> -9 nginx               //强制停止</span><br></pre></td></tr></table></figure>

<p><strong>重启 nginx</strong></p>
<p><strong>方法一：</strong><br>找到 nginx 可执行文件路径，然后输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

</br>

<p><strong>方法二：</strong><br>查找当前 nginx 进程号，然后输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;pid_of_nginx&gt;</span><br></pre></td></tr></table></figure>

<p>实现重启 nginx 服务。</p>
<h3 id="Docker-端口映射"><a href="#Docker-端口映射" class="headerlink" title="Docker 端口映射"></a>Docker 端口映射</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -p 8080:18026 &lt;REPOSITORY&gt;:&lt;TAG&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<p><code>-p</code>：是容器内部端口绑定到指定的主机端口。这里指将主机的8080端口映射到容器的18026端口。</p>
</br>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -p 127.0.0.1:8080:18026 &lt;REPOSITORY&gt;:&lt;TAG&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<p>这样我们就可以通过访问 127.0.0.1:8080 来访问容器的 18026 端口。</p>
</br>

<p>上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 /udp。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -p 127.0.0.1:8080:18026/udp &lt;REPOSITORY&gt;:&lt;TAG&gt; /bin/bash</span><br></pre></td></tr></table></figure>

</br>

<p><code>docker port &lt;CONTAINER ID&gt; &lt;PORT&gt;</code>命令可以让我们快捷地查看端口的绑定情况。</p>
<h3 id="启动微服务"><a href="#启动微服务" class="headerlink" title="启动微服务"></a>启动微服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recurse-submodules https://gitlab.xxxxxxxx.net/.../*.git</span><br><span class="line">//带这个参数，才会把 public 下载到子目录里面去</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /path_of_project/</span><br><span class="line"></span><br><span class="line">sh build.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> bin/root_of_work_dir/</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> VEHICLE_DATA_CONFIG=/root_of_work_dir/vehicle/config/config.xml</span><br><span class="line">//代码中有对 VEHICLE_DATA_CONFIG 的宏定义，修改为本地路径</span><br><span class="line"></span><br><span class="line">spawn_fcgi -a 127.0.0.1 -p 19026 -C 25 -U nginx -f stdnameSvr -F 1</span><br><span class="line">//运行 stdnameSvr 服务</span><br><span class="line"></span><br><span class="line">netstat -ntpl</span><br><span class="line">//查看 nginx 和 stdnameSvr 服务是否均已开启</span><br></pre></td></tr></table></figure>

<p><strong>注释：**</strong>spawn-fcgi 用法了解**</p>
<p>spawn-fcgi 是一个小程序，作用是管理 fast-cgi 进程。</p>
<p>用 spawn 启动 FCGI 程序的方式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./spawn-fcgi -a 127.0.0.1 -p 8080 -F <span class="variable">$&#123;count&#125;</span> -f <span class="variable">$&#123;webroot&#125;</span>/bin/demo.fcgi</span><br></pre></td></tr></table></figure>

<p>这样就会启动 count 个 demo.fcgi 程序，他们共同监听同一个 listen 端口 8080，从而提供服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./spawn_fcgi -h</span><br><span class="line">Usage: spawn-fcgi [options] [-- &lt;fcgiapp&gt; [fcgi app arguments]]</span><br><span class="line"></span><br><span class="line">spawn-fcgi v1.6.5 - spawns FastCGI processes</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -f &lt;path&gt;      filename of the fcgi-application (deprecated; ignored <span class="keyword">if</span></span><br><span class="line">                &lt;fcgiapp&gt; is given; needs /bin/sh)</span><br><span class="line"> -d &lt;directory&gt; <span class="built_in">chdir</span> to directory before spawning</span><br><span class="line"> -a &lt;address&gt;   <span class="built_in">bind</span> to IPv4/IPv6 address (defaults to 0.0.0.0)</span><br><span class="line"> -p &lt;port&gt;      <span class="built_in">bind</span> to TCP-port</span><br><span class="line"> -s &lt;path&gt;      <span class="built_in">bind</span> to Unix domain socket</span><br><span class="line"> -M &lt;mode&gt;      change Unix domain socket mode (octal <span class="built_in">integer</span>, default: allow</span><br><span class="line">                <span class="built_in">read</span>+write <span class="keyword">for</span> user and group as far as <span class="built_in">umask</span> allows it)</span><br><span class="line"> -C &lt;children&gt;  (PHP only) numbers of childs to spawn (default: not setting</span><br><span class="line">                the PHP_FCGI_CHILDREN environment variable - PHP defaults to 0)</span><br><span class="line"> -F &lt;children&gt;  number of children to fork (default 1)</span><br><span class="line"> -b &lt;backlog&gt;   backlog to allow on the socket (default 1024)</span><br><span class="line"> -P &lt;path&gt;      name of PID-file <span class="keyword">for</span> spawned process (ignored <span class="keyword">in</span> no-fork mode)</span><br><span class="line"> -n             no fork (<span class="keyword">for</span> daemontools)</span><br><span class="line"> -v             show version</span><br><span class="line"> -?, -h         show this <span class="built_in">help</span></span><br><span class="line">(root only)</span><br><span class="line"> -c &lt;directory&gt; chroot to directory</span><br><span class="line"> -S             create socket before chroot() (default is to create the socket</span><br><span class="line">                <span class="keyword">in</span> the chroot)</span><br><span class="line"> -u &lt;user&gt;      change to user-id</span><br><span class="line"> -g &lt;group&gt;     change to group-id (default: primary group of user <span class="keyword">if</span> -u</span><br><span class="line">                is given)</span><br><span class="line"> -U &lt;user&gt;      change Unix domain socket owner to user-id</span><br><span class="line"> -G &lt;group&gt;     change Unix domain socket group to group-id</span><br></pre></td></tr></table></figure>

<h2 id="C-OTL-流处理包"><a href="#C-OTL-流处理包" class="headerlink" title="C++ OTL 流处理包"></a>C++ OTL 流处理包</h2><p><a href="#toc">&lt;返回目录&gt;</a><br>otl的源码只有一个头文件——otlv4.h。下面以一个例子来说明如何使用otl。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;otlv4.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OTL_ORA10G</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CAboutDlg::OnBnClickedOk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    otl_connect OracleDb;  <span class="comment">// 定义一个oracle数据库的连接对象</span></span><br><span class="line"></span><br><span class="line">    OracleDb.otl_initialize(TRUE);<span class="comment">// 以线程安全模式初始化OCI环境 </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> szConnectString = _T(<span class="string">&quot;system/zjc@ORCL&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 连接数据库</span></span><br><span class="line">        OracleDb.rlogon(szConnectString.c_str(), <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 查询数据库中所有用户</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> strSql = _T(<span class="string">&quot;SELECT username FROM dba_users&quot;</span>);</span><br><span class="line">        <span class="function">otl_stream <span class="title">i</span><span class="params">(<span class="number">1024</span>, <span class="comment">// buffer size  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                     strSql.c_str(),</span></span></span><br><span class="line"><span class="function"><span class="params">                     OracleDb <span class="comment">// connect object  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nNumUser = <span class="number">0</span>;</span><br><span class="line">        TCHAR szNum[<span class="number">64</span>];</span><br><span class="line">        <span class="keyword">while</span> (!i.eof())<span class="comment">// while not end-of-data  </span></span><br><span class="line">        &#123;</span><br><span class="line">            i &gt;&gt; szNum; <span class="comment">//获取单个用户名</span></span><br><span class="line">            nNumUser++;</span><br><span class="line">        &#125;</span><br><span class="line">        CString strNum;</span><br><span class="line">        strNum.Format((<span class="string">&quot;当前oracle数据库用户个数为：%d&quot;</span>), nNumUser);</span><br><span class="line">        AfxMessageBox(strNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (otl_exception &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        TRACE(_T(<span class="string">&quot;Oracle connecterror(msg:%s, stm_text: %s, sqlstate: %s, var_info: %s)&quot;</span>), p.msg, p.stm_text,</span><br><span class="line">              p.sqlstate, p.var_info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OnOK();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码例子连接<code>Oracle</code>数据库用到了<code>rlogon()</code>函数，调用它时需要为它提供一个连接字符串，一般是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[User Name]&#x2F;[Password]@[TNS Alias]</span><br></pre></td></tr></table></figure>
<p>这里的<code>TNS Alias</code>指在<code>tnsnames.ora</code>中配置<code>TNS</code>名，比如我的<code>tnsnames.ora</code>里有以下的配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tnsnames.ora Network Configuration File: D:\oracle\product\10.2.0\db_1\network\admin\tnsnames.ora</span></span><br><span class="line"><span class="comment"># Generated by Oracle configuration tools.</span></span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ORCL &#x3D;</span><br><span class="line">  (DESCRIPTION &#x3D;</span><br><span class="line">    (ADDRESS &#x3D; (PROTOCOL &#x3D; TCP)(HOST &#x3D; zjc)(PORT &#x3D; 1521))</span><br><span class="line">    (CONNECT_DATA &#x3D;</span><br><span class="line">      (SERVER &#x3D; DEDICATED)</span><br><span class="line">      (SERVICE_NAME &#x3D; orcl)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">EXTPROC_CONNECTION_DATA &#x3D;</span><br><span class="line">  (DESCRIPTION &#x3D;</span><br><span class="line">    (ADDRESS_LIST &#x3D;</span><br><span class="line">      (ADDRESS &#x3D; (PROTOCOL &#x3D; IPC)(KEY &#x3D; EXTPROC1))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA &#x3D;</span><br><span class="line">      (SID &#x3D; PLSExtProc)</span><br><span class="line">      (PRESENTATION &#x3D; RO)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>那么<code>TNS Alias</code>就是<code>ORCL</code>。 </p>
<p>此外需要注意的是使用<code>otl</code>连接<code>oracle</code>数据库需要链接<code>oci.lib</code>，也就是说需要包含它的头文件和库文件路径。</p>
<h2 id="Vector-遍历的几种方法"><a href="#Vector-遍历的几种方法" class="headerlink" title="Vector 遍历的几种方法"></a>Vector 遍历的几种方法</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<blockquote>
<p><code>vector&lt;int&gt; v1&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10&#125;;</code></p>
</blockquote>
<h3 id="一、通过数组下标遍历"><a href="#一、通过数组下标遍历" class="headerlink" title="一、通过数组下标遍历"></a>一、通过数组下标遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v1.at(i) &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h3 id="二、通过迭代器遍历"><a href="#二、通过迭代器遍历" class="headerlink" title="二、通过迭代器遍历"></a>二、通过迭代器遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = v1.begin(); iter != v1.end(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="三、C-11标准，auto关键字遍历"><a href="#三、C-11标准，auto关键字遍历" class="headerlink" title="三、C++11标准，auto关键字遍历"></a>三、C++11标准，auto关键字遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = v1.begin(); iter != v1.end(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="四、for-each加函数"><a href="#四、for-each加函数" class="headerlink" title="四、for_each加函数"></a>四、for_each加函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printer</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    for_each(v1.cbegin(), v1.cend(), printer&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>


<h2 id="C-计时方法——chrono"><a href="#C-计时方法——chrono" class="headerlink" title="C++ 计时方法——chrono"></a>C++ 计时方法——chrono</h2><p><a href="#toc">&lt;返回目录&gt;</a><br><strong>传统计时方法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> start = clock();</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line"><span class="keyword">clock_t</span> end   = clock();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;花费了&quot;</span> &lt;&lt; (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;秒&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>此方法可以精确到毫秒，输出样例：<strong>花费了0.123秒</strong></p>
<p><strong>C++11 最佳计时方法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;   </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> chrono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> start = system_clock::now();</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line"><span class="keyword">auto</span> end   = system_clock::now();</span><br><span class="line"><span class="keyword">auto</span> duration = duration_cast&lt;microseconds&gt;(end - start);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;  <span class="string">&quot;花费了&quot;</span> &lt;&lt; <span class="keyword">double</span>(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; <span class="string">&quot;秒&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//duration_cast&lt; &gt; 表示类型转换</span></span><br><span class="line"><span class="comment">//microseconds 表示微妙。除此之外，还有五种时间单位：hours, minutes, seconds, milliseconds, nanoseconds</span></span><br><span class="line"><span class="comment">//num 和 den分别表示分子(numerator)和分母(denominator)。在我给出的代码中，num等于1， den等于1,000,000</span></span><br><span class="line"><span class="comment">//count( ) 用来返回时间</span></span><br></pre></td></tr></table></figure>


<h2 id="其他开发过程中可能会遇到的坑"><a href="#其他开发过程中可能会遇到的坑" class="headerlink" title="其他开发过程中可能会遇到的坑"></a>其他开发过程中可能会遇到的坑</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">private</span> <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">explicit</span> <span class="keyword">extern</span></span><br></pre></td></tr></table></figure>

<ul>
<li>以上限定词的作用以及继承关系的嵌套需要更加明晰，很容易被这些限定词把逻辑弄乱。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CurlCXX <span class="title">curl</span><span class="params">(url, <span class="number">1</span>)</span></span>; <span class="comment">//1s timeout</span></span><br><span class="line">curl.post(body);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意学会<code>curl</code>发包的用法，并且<code>post</code>时，<code>body</code>当中要注意<code>fastcgi</code>框架当中约定了<code>post</code>数据格式为<code>x-www-form-urlencoded/form-data</code>，因此一定要注意<code>body</code>里面的数据，单个字段内不能出现容易导致解析错误的<code>&#39;&amp;&#39;</code>字符，若不得不包含<code>&#39;&amp;&#39;</code>字符，则要用转义字符<code>&#39;\&amp;&#39;</code>包起来，否则会导致参数错误。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CallRecord *app;</span><br><span class="line">app = app_ptr();</span><br><span class="line"><span class="keyword">const_cast</span>&lt;CallRecord *&gt;(app)-&gt;reload_cache();</span><br></pre></td></tr></table></figure>

<ul>
<li>注意对<code>const</code>类型的对象操作时，需要用<code>const_cast&lt;XXXXXX&gt;</code>对该对象进行强制类型转换。</li>
</ul>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p><a href="#toc">&lt;返回目录&gt;</a></p>
<h2 id="SQL-SELECT-DISTINCT-语句"><a href="#SQL-SELECT-DISTINCT-语句" class="headerlink" title="SQL SELECT DISTINCT 语句"></a>SQL SELECT DISTINCT 语句</h2><p><a href="#toc">&lt;返回目录&gt;</a><br>在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。DISTINCT 关键词用于返回唯一不同的值。</p>
<p><strong>SQL SELECT DISTINCT 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>

<!---more--->

<h2 id="SQL-UPDATE-语句"><a href="#SQL-UPDATE-语句" class="headerlink" title="SQL UPDATE 语句"></a>SQL UPDATE 语句</h2><p><a href="#toc">&lt;返回目录&gt;</a><br>UPDATE 语句用于更新表中已存在的记录。</p>
<p><strong>SQL UPDATE 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1=value1,column2=value2,...</span><br><span class="line"><span class="keyword">WHERE</span> some_column=some_value;</span><br></pre></td></tr></table></figure>

<p><strong>请注意</strong> : SQL UPDATE 语句中的 WHERE 子句！WHERE 子句规定哪条记录或者哪些记录需要更新。如果您省略了 WHERE 子句，所有的记录都将被更新！</p>
<h2 id="SQL-DELETE-语句"><a href="#SQL-DELETE-语句" class="headerlink" title="SQL DELETE 语句"></a>SQL DELETE 语句</h2><p><a href="#toc">&lt;返回目录&gt;</a><br>DELETE 语句用于删除表中的行(记录)。</p>
<p><strong>SQL DELETE 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> some_column=some_value;</span><br></pre></td></tr></table></figure>

<p><strong>请注意</strong> : SQL DELETE 语句中的 WHERE 子句！WHERE 子句规定哪条记录或者哪些记录需要删除。如果您省略了 WHERE 子句，所有的记录都将被删除！</p>
<h2 id="SQL-REGEXP-语句"><a href="#SQL-REGEXP-语句" class="headerlink" title="SQL REGEXP 语句"></a>SQL REGEXP 语句</h2><p><a href="#toc">&lt;返回目录&gt;</a><br>作为一个更为复杂的示例，正则表达式 <code>B[an]*s</code> 匹配下述字符串中的任何一个：<code>Bananas，Baaaaas，Bs</code>，以及以 B 开始，以 s 结束、并在其中包含任意数目 a 或 n 字符的任何其他字符串。</p>
<p>以下是可用于随 REGEXP 操作符的表的模式。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghb5zvmhrhj30ff08r754.jpg"></p>
<p>应用示例，查找用户表中 Email 格式错误的用户记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">users</span></span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">NOT</span> REGEXP <span class="string">&#x27;^[A-Z0-9._%-]+@[A-Z0-9.-]+.[A-Z]&#123;2,4&#125;$&#x27;</span></span><br></pre></td></tr></table></figure>

<p>MySQL 数据库中正则表达式的语法，主要包括各种符号的含义。</p>
<p><strong>^ 字符</strong></p>
<p>匹配字符串的开始位置，如 <code>^a</code> 表示以字母 a 开头的字符串。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &#x27;xxxyyy&#x27; REGEXP &#x27;^xx&#x27;;</span><br><span class="line"> </span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| &#x27;xxxyyy&#x27; REGEXP &#x27;^xx&#x27; |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">|           1 |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>查询 xxxyyy 字符串中是否以 xx 开头，结果值为 1，表示值为 true，满足条件。</p>
<p><strong>$ 字符</strong></p>
<p>匹配字符串的结束位置，如 <code>X$</code> 表示以字母 X 结尾的字符串。</p>
<p><strong>. 字符</strong></p>
<p>这个字符就是英文下的点，它匹配任何一个字符，包括回车、换行等。</p>
<p><strong>* 字符</strong></p>
<p>星号匹配 0 个或多个字符，在它之前必须有内容。如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &#x27;xxxyyy&#x27; REGEXP &#x27;x*&#x27;;</span><br></pre></td></tr></table></figure>

<p>这个 SQL 语句，正则匹配为 true。</p>
<p><strong>+ 字符</strong></p>
<p>加号匹配 1 个或多个字符，在它之前也必须有内容。加号跟星号的用法类似，只是星号允许出现 0 次，加号则必须至少出现一次。</p>
<p><strong>? 字符</strong></p>
<p>问号匹配 0 次或 1 次。</p>
<p><strong>实例:</strong><br>查询找到所有的名字以 st 开头：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;^st&#x27;;</span><br><span class="line">//查询找到所有的名字以 ok 结尾：</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;ok$&#x27;;</span><br><span class="line">//查询找到所有的名字包函 mar 的字符串：</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;mar&#x27;;</span><br><span class="line">//查询找到所有名称以元音开始和 ok 结束的：</span><br><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;^[aeiou]|ok$&#x27;;</span><br></pre></td></tr></table></figure>

<p>一个正则表达式中的可以使用以下保留字。</p>
<p><strong>^</strong><br>所匹配的字符串以后面的字符串开头：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;fonfo&quot; REGEXP &quot;^fo$&quot;; -&gt; 0（表示不匹配） </span><br><span class="line">mysql&gt; SELECT &quot;fofo&quot; REGEXP &quot;^fo&quot;; -&gt; 1（表示匹配）</span><br></pre></td></tr></table></figure>

<p><strong>$</strong><br>所匹配的字符串以前面的字符串结尾：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;fono&quot; REGEXP &quot;^fono$&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;fono&quot; REGEXP &quot;^fo$&quot;; -&gt; 0（表示不匹配） </span><br></pre></td></tr></table></figure>

<p><strong>.</strong><br>匹配任何字符（包括新行）：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;fofo&quot; REGEXP &quot;^f.*&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;fonfo&quot; REGEXP &quot;^f.*&quot;; -&gt; 1（表示匹配）</span><br></pre></td></tr></table></figure>

<p>*<em>a**</em><br>匹配任意多个 a（包括空串)：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;Ban&quot; REGEXP &quot;^Ba*n&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;Baaan&quot; REGEXP &quot;^Ba*n&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;Bn&quot; REGEXP &quot;^Ba*n&quot;; -&gt; 1（表示匹配）</span><br></pre></td></tr></table></figure>

<p><strong>a+</strong><br>匹配任意多个 a（不包括空串)：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;Ban&quot; REGEXP &quot;^Ba+n&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;Bn&quot; REGEXP &quot;^Ba+n&quot;; -&gt; 0（表示不匹配）</span><br></pre></td></tr></table></figure>

<p><strong>a?</strong><br>匹配一个或零个 a：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;Bn&quot; REGEXP &quot;^Ba?n&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;Ban&quot; REGEXP &quot;^Ba?n&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;Baan&quot; REGEXP &quot;^Ba?n&quot;; -&gt; 0（表示不匹配）</span><br></pre></td></tr></table></figure>

<p><strong>de|abc</strong><br>匹配 de 或 abc：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;pi&quot; REGEXP &quot;pi|apa&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;axe&quot; REGEXP &quot;pi|apa&quot;; -&gt; 0（表示不匹配） </span><br><span class="line">mysql&gt; SELECT &quot;apa&quot; REGEXP &quot;pi|apa&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;apa&quot; REGEXP &quot;^(pi|apa)$&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;pi&quot; REGEXP &quot;^(pi|apa)$&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;pix&quot; REGEXP &quot;^(pi|apa)$&quot;; -&gt; 0（表示不匹配）</span><br></pre></td></tr></table></figure>

<p>*<em>(abc)**</em><br>匹配任意多个abc（包括空串)：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;pi&quot; REGEXP &quot;^(pi)*$&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;pip&quot; REGEXP &quot;^(pi)*$&quot;; -&gt; 0（表示不匹配） </span><br><span class="line">mysql&gt; SELECT &quot;pipi&quot; REGEXP &quot;^(pi)*$&quot;; -&gt; 1（表示匹配）</span><br></pre></td></tr></table></figure>

<p><strong>{1}</strong><br><strong>{2,3}</strong><br>这是一个更全面的方法，它可以实现前面好几种保留字的功能。<br>*<em>a**</em> 可以写成 <code>a&#123;0,&#125;</code>。<br><strong>a+</strong> 可以写成 <code>a&#123;1,&#125;</code>。<br><strong>a?</strong> 可以写成 <code>a&#123;0,1&#125;</code>。</p>
<p>在 {} 内只有一个整型参数 i，表示字符只能出现 i 次；在 {} 内有一个整型参数 i，后面跟一个 ,，表示字符可以出现 i 次或 i 次以上；在 {} 内只有一个整型参数 i，后面跟一个 ,，再跟一个整型参数 j, 表示字符只能出现 i 次以上，j 次以下（包括 i 次和 j 次）。其中的整型参数必须大于等于 0，小于等于 RE_DUP_MAX（默认是 255）。 如果有两个参数，第二个必须大于等于第一个。</p>
<p><strong>[a-dX]</strong> 匹配 <code>“a”、“b”、“c”、“d”</code> 或 <code>“X”</code>。<br>**[^a-dX]** 匹配除 <code>“a”、“b”、“c”、“d”、“X”</code> 以外的任何字符。</p>
<p><strong>“[”、“]”</strong>必须成对使用：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;aXbc&quot; REGEXP &quot;[a-dXYZ]&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;aXbc&quot; REGEXP &quot;^[a-dXYZ]$&quot;; -&gt; 0（表示不匹配） </span><br><span class="line">mysql&gt; SELECT &quot;aXbc&quot; REGEXP &quot;^[a-dXYZ]+$&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;aXbc&quot; REGEXP &quot;^[^a-dXYZ]+$&quot;; -&gt; 0（表示不匹配） </span><br><span class="line">mysql&gt; SELECT &quot;gheis&quot; REGEXP &quot;^[^a-dXYZ]+$&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;gheisa&quot; REGEXP &quot;^[^a-dXYZ]+$&quot;; -&gt; 0（表示不匹配）</span><br></pre></td></tr></table></figure>

<h2 id="SQL-IN-操作符"><a href="#SQL-IN-操作符" class="headerlink" title="SQL IN 操作符"></a>SQL IN 操作符</h2><p><a href="#toc">&lt;返回目录&gt;</a><br>IN 操作符允许您在 WHERE 子句中规定多个值。</p>
<p><strong>SQL IN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (value1,value2,...);</span><br></pre></td></tr></table></figure>

<h2 id="SQL-BETWEEN-操作符"><a href="#SQL-BETWEEN-操作符" class="headerlink" title="SQL BETWEEN 操作符"></a>SQL BETWEEN 操作符</h2><p><a href="#toc">&lt;返回目录&gt;</a><br>BETWEEN 操作符选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。</p>
<p><strong>SQL BETWEEN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">BETWEEN</span> value1 <span class="keyword">AND</span> value2;</span><br></pre></td></tr></table></figure>

<h2 id="SQL-别名"><a href="#SQL-别名" class="headerlink" title="SQL 别名"></a>SQL 别名</h2><p><a href="#toc">&lt;返回目录&gt;</a><br>通过使用 SQL，可以为表名称或列名称指定别名。基本上，创建别名是为了让列名称的可读性更强。</p>
<p><strong>列的 SQL 别名语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<p><strong>表的 SQL 别名语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name <span class="keyword">AS</span> alias_name;</span><br></pre></td></tr></table></figure>

<h2 id="SQL-JOIN"><a href="#SQL-JOIN" class="headerlink" title="SQL JOIN"></a>SQL JOIN</h2><p><a href="#toc">&lt;返回目录&gt;</a><br>SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。</p>
<p><code>INNER JOIN</code>：如果表中有至少一个匹配，则返回行<br><code>LEFT JOIN</code>：即使右表中没有匹配，也从左表返回所有的行<br><code>RIGHT JOIN</code>：即使左表中没有匹配，也从右表返回所有的行<br><code>FULL JOIN</code>：只要其中一个表中存在匹配，则返回行</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghb9w54nksj30qu0l40wf.jpg"></p>
<h3 id="SQL-INNER-JOIN-关键字"><a href="#SQL-INNER-JOIN-关键字" class="headerlink" title="SQL INNER JOIN 关键字"></a>SQL INNER JOIN 关键字</h3><p>INNER JOIN 关键字在表中存在至少一个匹配时返回行。</p>
<p><strong>SQL INNER JOIN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghba0un8qgj305k041dfs.jpg"></p>
<p><strong>注释</strong>：INNER JOIN 与 JOIN 是相同的。</p>
<h3 id="SQL-LEFT-JOIN-关键字"><a href="#SQL-LEFT-JOIN-关键字" class="headerlink" title="SQL LEFT JOIN 关键字"></a>SQL LEFT JOIN 关键字</h3><p>LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。</p>
<p><strong>SQL LEFT JOIN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghbafmyirgj305k041aa0.jpg"></p>
<p><strong>注释</strong>：在某些数据库中，LEFT JOIN 称为 LEFT OUTER JOIN。<br><strong>注释</strong>：LEFT JOIN 关键字从左表（Websites）返回所有的行，即使右表（access_log）中没有匹配。</p>
<h3 id="SQL-RIGHT-JOIN-关键字"><a href="#SQL-RIGHT-JOIN-关键字" class="headerlink" title="SQL RIGHT JOIN 关键字"></a>SQL RIGHT JOIN 关键字</h3><p>RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。</p>
<p><strong>SQL RIGHT JOIN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghbagmz2yhj305k041dfs.jpg"></p>
<p><strong>注释</strong>：在某些数据库中，RIGHT JOIN 称为 RIGHT OUTER JOIN。<br><strong>注释</strong>：RIGHT JOIN 关键字从右表（Websites）返回所有的行，即使左表（access_log）中没有匹配。</p>
<h3 id="SQL-FULL-OUTER-JOIN-关键字"><a href="#SQL-FULL-OUTER-JOIN-关键字" class="headerlink" title="SQL FULL OUTER JOIN 关键字"></a>SQL FULL OUTER JOIN 关键字</h3><p>FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行。</p>
<p>FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。</p>
<p><strong>SQL FULL OUTER JOIN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghbahzrrmtj305k0413yh.jpg"></p>
<p><strong>注释</strong>：FULL OUTER JOIN 关键字返回左表（Websites）和右表（access_log）中所有的行。如果 “Websites” 表中的行在 “access_log” 中没有匹配或者 “access_log” 表中的行在 “Websites” 表中没有匹配，也会列出这些行。<br><strong>注释</strong>：MySQL中不支持 FULL OUTER JOIN</p>
<h2 id="SQL-UNION-操作符"><a href="#SQL-UNION-操作符" class="headerlink" title="SQL UNION 操作符"></a>SQL UNION 操作符</h2><p><a href="#toc">&lt;返回目录&gt;</a><br>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p>
<p>请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</p>
<p><strong>SQL UNION 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong>：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</p>
<p><strong>SQL UNION ALL 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong>：UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。</p>
<h2 id="SQL-INSERT-INTO-SELECT-语句"><a href="#SQL-INSERT-INTO-SELECT-语句" class="headerlink" title="SQL INSERT INTO SELECT 语句"></a>SQL INSERT INTO SELECT 语句</h2><p><a href="#toc">&lt;返回目录&gt;</a><br>通过 SQL，您可以从一个表复制信息到另一个表。<br>INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。</p>
<p><strong>SQL INSERT INTO SELECT 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//我们可以从一个表中复制所有的列插入到另一个已存在的表中：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table2</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1;</span><br><span class="line"></span><br><span class="line">//或者我们可以只复制希望的列插入到另一个已存在的表中：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table2</span><br><span class="line">(column_name(s))</span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1;</span><br></pre></td></tr></table></figure>

<h2 id="MySQL-复制表-MySQL的SELECT-INTO-FROM-语句"><a href="#MySQL-复制表-MySQL的SELECT-INTO-FROM-语句" class="headerlink" title="MySQL 复制表(MySQL的SELECT INTO FROM 语句)"></a>MySQL 复制表(MySQL的SELECT INTO FROM 语句)</h2><p><a href="#toc">&lt;返回目录&gt;</a><br><strong>复制表结构及其数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name_new <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name_old</span><br></pre></td></tr></table></figure>

<p><strong>只复制表结构：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name_new <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name_old <span class="keyword">WHERE</span> <span class="number">1</span>=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>或者：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name_new <span class="keyword">LIKE</span> table_name_old</span><br></pre></td></tr></table></figure>

<p><strong>只复制表数据：</strong></p>
<ul>
<li>如果两个表结构一样：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name_new <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name_old</span><br></pre></td></tr></table></figure>

<ul>
<li>如果两个表结构不一样：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name_new(column1,column2...) <span class="keyword">SELECT</span> column1,column2... <span class="keyword">FROM</span> table_name_old</span><br></pre></td></tr></table></figure>

<p><strong>SELECT INTO FROM 和 INSERT INTO SELECT 的区别：</strong></p>
<p>主要区别：SELECT INTO FROM 要求目标表不存在，因为在插入时会自动创建；INSERT INTO SELECT FROM 要求目标表存在。</p>
<p><strong>SELECT INTO FROM</strong> ：将查询出来的数据整理到一张新表中保存，表结构与查询结构一致。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *（查询出来的结果） <span class="keyword">INTO</span> newtable（新的表名）<span class="keyword">FROM</span> <span class="keyword">WHERE</span> （后续条件）</span><br></pre></td></tr></table></figure>

<p>即，查询出来结果—&gt;复制一张同结构的空表—&gt;将数据拷贝进去。</p>
<p><strong>INSERT INTO SELECT</strong> ：为已经存在的表批量添加新数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>  (准备好的表) <span class="keyword">SELECT</span> *（或者取用自己想要的结构）<span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 各种条件</span><br></pre></td></tr></table></figure>
<p>即，指定一张想要插入数据的表格—&gt;对数据进行加工筛选—&gt;填入一张准备好的表格。</p>
<h2 id="SQL-约束（Constraints）"><a href="#SQL-约束（Constraints）" class="headerlink" title="SQL 约束（Constraints）"></a>SQL 约束（Constraints）</h2><p><a href="#toc">&lt;返回目录&gt;</a><br>SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。</p>
<p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p>
<p><strong>SQL CREATE TABLE + CONSTRAINT 语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(</span><br><span class="line">column_name1 data_type(<span class="keyword">size</span>) constraint_name,</span><br><span class="line">column_name2 data_type(<span class="keyword">size</span>) constraint_name,</span><br><span class="line">column_name3 data_type(<span class="keyword">size</span>) constraint_name,</span><br><span class="line">....</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在 SQL 中，我们有如下约束：</p>
<ul>
<li><code>NOT NULL</code> - 指示某列不能存储 NULL 值。</li>
<li><code>UNIQUE</code> - 保证某列的每行必须有唯一的值。</li>
<li><code>PRIMARY KEY</code> - (<code>NOT NULL</code> 和 <code>UNIQUE</code> 的结合)。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>
<li><code>FOREIGN KEY</code> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li>
<li><code>CHECK</code> - 保证列中的值符合指定的条件。</li>
<li><code>DEFAULT</code> - 规定没有给列赋值时的默认值。</li>
</ul>
<h2 id="SQL-ALTER-TABLE-语句"><a href="#SQL-ALTER-TABLE-语句" class="headerlink" title="SQL ALTER TABLE 语句"></a>SQL ALTER TABLE 语句</h2><p><a href="#toc">&lt;返回目录&gt;</a><br>ALTER TABLE 语句用于在已有的表中添加、删除或修改列。</p>
<p><strong>SQL ALTER TABLE 语法：</strong></p>
<p>如需在表中添加列，请使用下面的语法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> column_name datatype</span><br></pre></td></tr></table></figure>

<p>如需删除表中的列，请使用下面的语法（请注意，某些数据库系统不允许这种在数据库表中删除列的方式）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name</span><br></pre></td></tr></table></figure>

<p>要改变表中列的数据类型，请使用下面的语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> column_name datatype</span><br></pre></td></tr></table></figure>

<h2 id="SQL-AUTO-INCREMENT-字段"><a href="#SQL-AUTO-INCREMENT-字段" class="headerlink" title="SQL AUTO INCREMENT 字段"></a>SQL AUTO INCREMENT 字段</h2><p><a href="#toc">&lt;返回目录&gt;</a><br>AUTO-INCREMENT 会在新记录插入表中时生成一个唯一的数字。</p>
<p><strong>AUTO INCREMENT 字段</strong><br>我们通常希望在每次插入新记录时，自动地创建主键字段的值。</p>
<h2 id="SQL-CREATE-VIEW-语句"><a href="#SQL-CREATE-VIEW-语句" class="headerlink" title="SQL CREATE VIEW 语句"></a>SQL CREATE VIEW 语句</h2><p><a href="#toc">&lt;返回目录&gt;</a><br>在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。</p>
<p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。</p>
<p>您可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。</p>
<p><strong>SQL CREATE VIEW 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> condition</span><br></pre></td></tr></table></figure>
<p><strong>注释：</strong>视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。</p>
<h2 id="SQL-撤销视图"><a href="#SQL-撤销视图" class="headerlink" title="SQL 撤销视图"></a>SQL 撤销视图</h2><p><a href="#toc">&lt;返回目录&gt;</a><br>您可以通过 DROP VIEW 命令来删除视图。</p>
<p><strong>SQL DROP VIEW 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name</span><br></pre></td></tr></table></figure>

<h2 id="MySQL中修改表名，表属性名等操作"><a href="#MySQL中修改表名，表属性名等操作" class="headerlink" title="MySQL中修改表名，表属性名等操作"></a>MySQL中修改表名，表属性名等操作</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">CHANGE</span> 原列名 新列名  类型； <span class="comment">--修改表的列属性名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">MODIFY</span> 列名 类型 ；  <span class="comment">--修改表的类类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 列名；  <span class="comment">--删除表的某一列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span>  列名 类型；<span class="comment">--添加某一列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">RENAME</span> 新表名； <span class="comment">--修改表名</span></span><br></pre></td></tr></table></figure>


<h2 id="其他的问题"><a href="#其他的问题" class="headerlink" title="其他的问题"></a>其他的问题</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<h3 id="mysql清空表数据后如何让自增ID仍从1开始"><a href="#mysql清空表数据后如何让自增ID仍从1开始" class="headerlink" title="mysql清空表数据后如何让自增ID仍从1开始?"></a>mysql清空表数据后如何让自增ID仍从1开始?</h3><blockquote>
<p>也就是说如何重排 auto_increment</p>
</blockquote>
<p><strong>两种方法：</strong></p>
<p><strong>1、</strong>清空表时使用<code>truncate</code>命令，而不用<code>delete</code>命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name ;</span><br></pre></td></tr></table></figure>
<p>使用<code>truncate</code>命令的好处：</p>
<blockquote>
<p>1）、速度快<br>2）、可以对自增 ID 进行重排，使自增 ID 仍从1开始计算</p>
</blockquote>
<p><strong>2、</strong>清空表数据后，使用alter修改表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name AUTO_INCREMENT = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="mysql-建立索引"><a href="#mysql-建立索引" class="headerlink" title="mysql 建立索引"></a>mysql 建立索引</h3><p>INDEX <code>idx_interface_name</code> ( <code>interface_name</code> ) USING BTREE 建立B树索引</p>
<h3 id="mysql-插入数据"><a href="#mysql-插入数据" class="headerlink" title="mysql 插入数据"></a>mysql 插入数据</h3><p>如果对应元素有默认值，则可以，在 INSERT 时为空，不然会报错。</p>
<h3 id="mysql-时间戳设置"><a href="#mysql-时间戳设置" class="headerlink" title="mysql 时间戳设置"></a>mysql 时间戳设置</h3><p>DEFAULT CURRENT_TIMESTAMP 表示当插入数据的时候，该字段默认值为当前时间<br>ON UPDATE CURRENT_TIMESTAMP 在数据库数据有更新的时候UPDATE_TIME的时间会自动更新</p>
<h3 id="mysql-主键自增设置"><a href="#mysql-主键自增设置" class="headerlink" title="mysql 主键自增设置"></a>mysql 主键自增设置</h3><p>AUTO_INCREMENT 用于主键自动增长</p>
<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p><a href="#toc">&lt;返回目录&gt;</a></p>
<h2 id="python-读取-Excel-文档"><a href="#python-读取-Excel-文档" class="headerlink" title="python 读取 Excel 文档"></a>python 读取 Excel 文档</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_excel</span>(<span class="params">self, path</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.info(<span class="string">&quot;begin read %s&quot;</span> % path)</span><br><span class="line">        <span class="comment"># 读取 Excel 预处理动作↓，使用 xlrd 包将 Excel 文件读入 book 中</span></span><br><span class="line">        book = xlrd.open_workbook(path,encoding_override=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        data = dict()</span><br><span class="line">        sheets = book.sheets()</span><br><span class="line">        <span class="keyword">for</span> cur <span class="keyword">in</span> sheets:</span><br><span class="line">            sheet_name = cur.name</span><br><span class="line">            nrows = cur.nrows</span><br><span class="line">            ncols = cur.ncols</span><br><span class="line">            logger.info(<span class="string">&quot;nrows=%d,ncols=%d&quot;</span> % (nrows, ncols))</span><br><span class="line">            sheet_val = list()</span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">0</span>, nrows):</span><br><span class="line">                line = cur.row_values(idx)</span><br><span class="line">                <span class="comment"># sheet_val 为对应该页面每行数据的 list 数据</span></span><br><span class="line">                sheet_val.append(line)</span><br><span class="line">            <span class="comment"># data 为整个 Excel 文件每一张 sheet 的 Map 数据</span></span><br><span class="line">            data[sheet_name] = sheet_val</span><br><span class="line">        logger.info(<span class="string">&quot;read end, sheet=%d&quot;</span> % len(data))</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.info(<span class="string">&quot;read %s fail, err=%s&quot;</span> % (path, str(e)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>


<h2 id="python-Excel-数据处理"><a href="#python-Excel-数据处理" class="headerlink" title="python Excel 数据处理"></a>python Excel 数据处理</h2><p><a href="#toc">&lt;返回目录&gt;</a><br><strong>Excel 转换成 SQL 语句</strong></p>
<p>单独拉出一列，在首行传入该函数后，复制到每一行，可拉取对应列的数据，并转换为 sql 语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;CONCATENATE(&quot;INSERT INTO table_name (list_1,list_2,list_3) VALUES (&#39;&quot;,A1,&quot;&#39;,&#39;&quot;,B1,&quot;&#39;,&#39;&quot;,C1,&quot;&#39;);&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>Python 批量处理 Excel</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">连接数据库</span></span><br><span class="line"><span class="string">args：db_name（数据库名称）</span></span><br><span class="line"><span class="string">returns:db</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysql_link</span>(<span class="params">db_name</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        db = pymysql.connect(host=<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>,</span><br><span class="line">                             port=xxxx,</span><br><span class="line">                             user=<span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">                             passwd=<span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">                             db=db_name,</span><br><span class="line">                             charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">&quot;could not connect to mysql server&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">读取excel函数</span></span><br><span class="line"><span class="string">args：excel_file（excel文件，目录在py文件同目录）</span></span><br><span class="line"><span class="string">returns：book</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_excel</span>(<span class="params">excel_file</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        book = xlrd.open_workbook(excel_file)  <span class="comment"># 文件名，把文件与py文件放在同一目录下</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">&quot;open excel file failed!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> book</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">执行插入操作</span></span><br><span class="line"><span class="string">args:db_name（数据库名称）</span></span><br><span class="line"><span class="string">table_name(表名称）</span></span><br><span class="line"><span class="string">excel_file（excel文件名，把文件与py文件放在同一目录下）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">store_to</span>(<span class="params">db_name: object, table_name: object, excel_file: object</span>) -&gt; object:</span></span><br><span class="line">    db = mysql_link(db_name)  <span class="comment"># 打开数据库连接</span></span><br><span class="line">    cursor = db.cursor()  <span class="comment"># 使用 cursor() 方法创建一个游标对象 cursor</span></span><br><span class="line">    book = open_excel(excel_file)  <span class="comment"># 打开excel文件</span></span><br><span class="line">    sheets = book.sheet_names()  <span class="comment"># 获取所有sheet表名</span></span><br><span class="line">    <span class="keyword">for</span> sheet <span class="keyword">in</span> sheets:</span><br><span class="line">        sh = book.sheet_by_name(sheet)  <span class="comment"># 打开每一张表</span></span><br><span class="line">        row_num = sh.nrows</span><br><span class="line">        <span class="keyword">if</span> row_num != <span class="number">0</span>:</span><br><span class="line">            print(row_num - <span class="number">1</span>)</span><br><span class="line">        data_list = []  <span class="comment"># 定义列表用来存放数据</span></span><br><span class="line">        num = <span class="number">0</span>  <span class="comment"># 用来控制每次插入的数量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, row_num):  <span class="comment"># 第一行是标题名，对应表中的字段名所以应该从第二行开始，计算机以0开始计数，所以值是1</span></span><br><span class="line">            row_data = sh.row_values(i)  <span class="comment"># 按行获取excel的值</span></span><br><span class="line">            value = (</span><br><span class="line">                row_data[<span class="number">0</span>], row_data[<span class="number">1</span>], row_data[<span class="number">2</span>], row_data[<span class="number">3</span>], row_data[<span class="number">4</span>], row_data[<span class="number">5</span>], row_data[<span class="number">6</span>], row_data[<span class="number">7</span>],</span><br><span class="line">                row_data[<span class="number">8</span>])</span><br><span class="line">            sql = <span class="string">&quot;INSERT INTO &quot;</span> + str(table_name) + <span class="string">&quot;(brand,sub_model_name,v8_10,`year`,trans_code,oe_code,std_name,&quot;</span> \</span><br><span class="line">                                                     <span class="string">&quot;`level`,specification,creator,updator) VALUES(%s,%s,%s,%s,%s,&quot;</span> \</span><br><span class="line">                                                     <span class="string">&quot;%s,%s,%s,%s,\&quot;xing.liuxing1218\&quot;,\&quot;xing.liuxing1218\&quot;) &quot;</span></span><br><span class="line">            data_list.append(value)  <span class="comment"># 将数据暂存在列表</span></span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt;= <span class="number">1000</span>:  <span class="comment"># 每一千条数据执行一次插入</span></span><br><span class="line">                cursor.executemany(sql, data_list)  <span class="comment"># 执行sql语句</span></span><br><span class="line">                data_list.clear()  <span class="comment"># 清空list</span></span><br><span class="line">                print(<span class="string">&quot;worksheets: &quot;</span> + sheet + <span class="string">&quot; has been inserted 1000 data!&quot;</span>)</span><br><span class="line">                num = <span class="number">0</span>  <span class="comment"># 计数归零</span></span><br><span class="line">        cursor.executemany(sql, data_list)  <span class="comment"># 执行sql语句</span></span><br><span class="line">        data_list.clear()  <span class="comment"># 清空list</span></span><br><span class="line">        print(<span class="string">&quot;worksheets: &quot;</span> + sheet + <span class="string">&quot; has been inserted &quot;</span> + str(num) + <span class="string">&quot; data!&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> row_num != <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">&quot;Success: worksheets: &quot;</span> + sheet + <span class="string">&quot; has been inserted &quot;</span> + str(row_num - <span class="number">1</span>) + <span class="string">&quot; data!&quot;</span>)</span><br><span class="line">    db.commit()  <span class="comment"># 提交</span></span><br><span class="line">    cursor.close()  <span class="comment"># 关闭连接</span></span><br><span class="line">    db.close()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    store_to(<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;xxx.xls&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="python-复制文件"><a href="#python-复制文件" class="headerlink" title="python 复制文件"></a>python 复制文件</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">shutil.copy(src, dst)</span><br></pre></td></tr></table></figure>


<h2 id="python-字符串处理"><a href="#python-字符串处理" class="headerlink" title="python 字符串处理"></a>python 字符串处理</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将变量转化成字符串类型</span></span><br><span class="line">str(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串全大写/全小写</span></span><br><span class="line">name = name.upper()</span><br><span class="line">name = name.lower()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类 C 语言中的字符串格式化语言，python 中用 % 处理变量转化</span></span><br><span class="line">ftp_name = <span class="string">&quot;%s_%s&quot;</span>%(xx_id, sec[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># strip()去掉字符串首位多余字符，为空时去掉多余空格</span></span><br><span class="line"><span class="comment"># split()将字符串通过参数中的字符，分割成若干字符串存在数组中</span></span><br><span class="line">plist = pic_advantage.strip().split(<span class="string">&quot;，&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># re模块处理正则表达式，以下为将 code 转化为[^a-zA-Z0-9]字符的函数</span></span><br><span class="line">pattern_code_trim = re.compile(<span class="string">&quot;[^a-zA-Z0-9]&quot;</span>)</span><br><span class="line">src_code_trim = pattern_code_trim.sub(<span class="string">&#x27;&#x27;</span>, code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python中没有自增</span></span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="python-字典的遍历"><a href="#python-字典的遍历" class="headerlink" title="python 字典的遍历"></a>python 字典的遍历</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># keys() 该方法会返回字典的所有的key</span></span><br><span class="line"><span class="comment"># 该方法会返回一个序列，序列中保存有字典的所有的键</span></span><br><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">print(d.keys())</span><br><span class="line"><span class="comment"># 通过遍历keys()来获取所有的键</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d.keys() :</span><br><span class="line">    print(k , d[k])</span><br><span class="line"></span><br><span class="line"><span class="comment"># values()</span></span><br><span class="line"><span class="comment"># 该方法会返回一个序列，序列中保存有字典的所有的值</span></span><br><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> d.values():</span><br><span class="line">    print(v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># items()</span></span><br><span class="line"><span class="comment"># 该方法会返回字典中所有的项</span></span><br><span class="line"><span class="comment"># 它会返回一个序列，序列中包含有双值子序列</span></span><br><span class="line"><span class="comment"># 双值分别是，字典中的key和value</span></span><br><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">print(d.items())</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</span><br><span class="line">    print(k, <span class="string">&#x27;=&#x27;</span>, v)</span><br></pre></td></tr></table></figure>


<h2 id="python解析json字符串"><a href="#python解析json字符串" class="headerlink" title="python解析json字符串"></a>python解析json字符串</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = json.loads(req.text)</span><br><span class="line">print(d[<span class="string">&#x27;element&#x27;</span>])</span><br><span class="line">print(d[<span class="string">&#x27;element_parent&#x27;</span>][<span class="string">&#x27;element_child&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> d.items():</span><br><span class="line">    print(item[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> item[<span class="number">1</span>][<span class="string">&#x27;element1&#x27;</span>] == <span class="string">&#x27;xx&#x27;</span>:</span><br><span class="line">        <span class="keyword">print</span> item[<span class="number">1</span>][<span class="string">&#x27;element2&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="python常用的去重方式"><a href="#python常用的去重方式" class="headerlink" title="python常用的去重方式"></a>python常用的去重方式</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<h3 id="对列表去重"><a href="#对列表去重" class="headerlink" title="对列表去重"></a>对列表去重</h3><p>**1.**用循环查找的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">news_li = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> li:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> news_li:</span><br><span class="line">        news_li.append(i)</span><br><span class="line"><span class="keyword">print</span> (news_li)</span><br></pre></td></tr></table></figure>

<p>**2.**用集合的特性set()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li1 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">new_li1 = list(set(li1))</span><br></pre></td></tr></table></figure>

<p>**3.**使用itertools模块的grouby方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">li2 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">li2.sort() <span class="comment"># 排序</span></span><br><span class="line">it = itertools.groupby(li2)</span><br><span class="line"><span class="keyword">for</span> k, g <span class="keyword">in</span> it:</span><br><span class="line">    <span class="keyword">print</span> (k)</span><br></pre></td></tr></table></figure>

<p>**4.**运用while循环遍历的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quchong</span>(<span class="params">lb</span>):</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> lb:</span><br><span class="line">        <span class="keyword">while</span> lb.count(x)&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">del</span> lb[lb.index(x)]</span><br><span class="line">    <span class="keyword">return</span> lb</span><br><span class="line">li3 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">quchong(li3)</span><br></pre></td></tr></table></figure>

<p>**5.**使用keys()方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li4 = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">5</span>]</span><br><span class="line">formatli = list(&#123;&#125;.fromkeys(li4).keys())</span><br><span class="line"><span class="keyword">print</span> (formatli)</span><br></pre></td></tr></table></figure>

<h3 id="对数据框去重"><a href="#对数据框去重" class="headerlink" title="对数据框去重"></a>对数据框去重</h3><p>**1.**用unique()对单属性列去重</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;<span class="string">&#x27;id&#x27;</span>:[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;A&#x27;</span>],<span class="string">&#x27;age&#x27;</span>:[<span class="number">18</span>,<span class="number">20</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">14</span>,<span class="number">65</span>,<span class="number">14</span>,<span class="number">98</span>]&#125;</span><br><span class="line">data = pd.DataFrame(data)</span><br><span class="line">data.id.unique()</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.unique(data.id)</span><br></pre></td></tr></table></figure>

<p>**2.**用frame.drop_duplicates()对单属性列去重</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.drop_duplicates([<span class="string">&#x27;id&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>**3.**用frame.drop_duplicates()对多属性列去重</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.drop_duplicates([<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>**4.**用frame.duplicated()对多属性列去重</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isduplicated = data.duplicated([<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;age&#x27;</span>],keep=<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">data.loc[~isduplicated,:]</span><br></pre></td></tr></table></figure>

<h2 id="python-查找列表中重复元素以及重复元素的次数"><a href="#python-查找列表中重复元素以及重复元素的次数" class="headerlink" title="python 查找列表中重复元素以及重复元素的次数"></a>python 查找列表中重复元素以及重复元素的次数</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">&quot;奔奔&quot;</span>, <span class="string">&quot;benben&quot;</span>, <span class="string">&quot;奔奔&quot;</span>]</span><br><span class="line">b = dict(Counter(a))</span><br><span class="line"><span class="comment"># 只展示重复元素</span></span><br><span class="line"><span class="keyword">print</span> ([key <span class="keyword">for</span> key,value <span class="keyword">in</span> b.items() <span class="keyword">if</span> value &gt; <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 展现重复元素和重复次数</span></span><br><span class="line"><span class="keyword">print</span> (&#123;key:value <span class="keyword">for</span> key,value <span class="keyword">in</span> b.items()<span class="keyword">if</span> value &gt; <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>方法一：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">myset = set(mylist)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> myset:</span><br><span class="line">    print(<span class="string">&quot;the %d has found %d&quot;</span> %(item,mylist.count(item)))</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">the 1 has found 1</span><br><span class="line">the 2 has found 4</span><br><span class="line">the 3 has found 3</span><br><span class="line">the 4 has found 4</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">Counter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Counter(&#123;2: 4, 4: 4, 3: 3, 1: 1&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>方法三：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">List=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">a = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> List:</span><br><span class="line">    <span class="keyword">if</span> List.count(i) &gt; <span class="number">1</span>:</span><br><span class="line">        a[i] = List.count(i)</span><br><span class="line"><span class="keyword">print</span> (a)</span><br></pre></td></tr></table></figure>

<h2 id="python-print-格式化输出"><a href="#python-print-格式化输出" class="headerlink" title="python print 格式化输出"></a>python print 格式化输出</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<h3 id="动态指定长度的实现"><a href="#动态指定长度的实现" class="headerlink" title="动态指定长度的实现"></a>动态指定长度的实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print %s固定长度格式输出：</span></span><br><span class="line">print(<span class="string">&quot;%10s, %20s&quot;</span> % (A, B))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果长度不定，以变量len代替：</span></span><br><span class="line">print(<span class="string">&quot;%*s&quot;</span> % (len, A))</span><br></pre></td></tr></table></figure>

<h3 id="以指定宽度格式化输出（format）"><a href="#以指定宽度格式化输出（format）" class="headerlink" title="以指定宽度格式化输出（format）"></a>以指定宽度格式化输出（format）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mat = <span class="string">&quot;&#123;:20&#125;\t&#123;:28&#125;\t&#123;:32&#125;&quot;</span></span><br><span class="line">print(mat.format(<span class="string">&quot;占4个长度&quot;</span>,<span class="string">&quot;占8个长度&quot;</span>, <span class="string">&quot;占12长度&quot;</span>))</span><br><span class="line"><span class="comment"># 如果需要居中输出在宽度前面加一个^</span></span><br><span class="line">mat = <span class="string">&quot;&#123;:^20&#125;\t&#123;:^28&#125;\t&#123;:^32&#125;&quot;</span></span><br><span class="line">print(mat.format(<span class="string">&quot;占4个长度&quot;</span>,<span class="string">&quot;占8个长度&quot;</span>, <span class="string">&quot;占12长度&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="python-Set-集合-相关函数操作"><a href="#python-Set-集合-相关函数操作" class="headerlink" title="python Set(集合)相关函数操作"></a>python Set(集合)相关函数操作</h2><p><a href="#toc">&lt;返回目录&gt;</a><br><strong>python</strong>的<code>set</code>和其他语言类似, 是一个无序不重复元素集。基本功能包括关系测试和消除重复元素。集合对象还支持<code>union(联合)</code>, <code>intersection(交)</code>, <code>difference(差)</code>和<code>sysmmetric difference(对称差集)</code>等数学运算。</p>
<p><code>set</code> 支持 <code>x in set</code>, <code>len(set)</code>, 和 <code>for x in set</code>。作为一个无序的集合，<code>set</code>不记录元素位置或者插入点。因此，<code>set</code>不支持 <code>indexing</code>,<code> slicing</code>, 或其它类序列<code>sequence-like</code>的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = set()</span><br><span class="line"></span><br><span class="line">len(s) </span><br><span class="line"><span class="comment"># set 的长度</span></span><br><span class="line"></span><br><span class="line">x <span class="keyword">in</span> s </span><br><span class="line"><span class="comment"># 测试 x 是否是 s 的成员</span></span><br><span class="line"></span><br><span class="line">x <span class="keyword">not</span> <span class="keyword">in</span> s </span><br><span class="line"><span class="comment"># 测试 x 是否不是 s 的成员</span></span><br><span class="line"></span><br><span class="line">s.issubset(t) s &lt;= t </span><br><span class="line"><span class="comment"># 测试是否 s 中的每一个元素都在 t 中</span></span><br><span class="line"></span><br><span class="line">s.issuperset(t) s &gt;= t </span><br><span class="line"><span class="comment"># 测试是否 t 中的每一个元素都在 s 中</span></span><br><span class="line"></span><br><span class="line">s.union(t) s | t </span><br><span class="line"><span class="comment"># 返回一个新的 set 包含 s 和 t 中的每一个元素</span></span><br><span class="line"></span><br><span class="line">s.intersection(t) s &amp; t </span><br><span class="line"><span class="comment"># 返回一个新的 set 包含 s 和 t 中的公共元素</span></span><br><span class="line"></span><br><span class="line">s.difference(t) s - t </span><br><span class="line"><span class="comment"># 返回一个新的 set 包含 s 中有但是 t 中没有的元素</span></span><br><span class="line"></span><br><span class="line">s.symmetric_difference(t) s ^ t </span><br><span class="line"><span class="comment"># 返回一个新的 set 包含 s 和 t 中不重复的元素</span></span><br><span class="line"></span><br><span class="line">s.copy() </span><br><span class="line"><span class="comment"># 返回 set “s”的一个浅复制</span></span><br><span class="line"></span><br><span class="line">hash(s)</span><br><span class="line"><span class="comment"># 返回 s 的 hash 值</span></span><br><span class="line"></span><br><span class="line">s.update(t)</span><br><span class="line">s |= t</span><br><span class="line"><span class="comment"># 返回增加了 set “t”中元素后的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.intersection_update(t)</span><br><span class="line">s &amp;= t</span><br><span class="line"><span class="comment"># 返回只保留含有 set “t”中元素的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.difference_update(t)</span><br><span class="line">s -= t</span><br><span class="line"><span class="comment"># 返回删除了 set “t”中含有的元素后的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.symmetric_difference_update(t)</span><br><span class="line">s ^= t</span><br><span class="line"><span class="comment"># 返回含有 set “t”或者 set “s”中有而不是两者都有的元素的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.add(x)</span><br><span class="line"><span class="comment"># 向 set “s”中增加元素 x</span></span><br><span class="line"></span><br><span class="line">s.remove(x)</span><br><span class="line"><span class="comment"># 从 set “s”中删除元素 x, 如果不存在则引发 KeyError</span></span><br><span class="line"></span><br><span class="line">s.discard(x)</span><br><span class="line"><span class="comment"># 如果在 set “s”中存在元素 x, 则删除</span></span><br><span class="line"></span><br><span class="line">s.pop()</span><br><span class="line"><span class="comment"># 删除并且返回 set “s”中的一个不确定的元素, 如果为空则引发 KeyError</span></span><br><span class="line"></span><br><span class="line">s.clear()</span><br><span class="line"><span class="comment"># 删除 set “s”中的所有元素</span></span><br></pre></td></tr></table></figure>

<h1 id="Markdown-技能分享"><a href="#Markdown-技能分享" class="headerlink" title="Markdown 技能分享"></a>Markdown 技能分享</h1><p><a href="#toc">&lt;返回目录&gt;</a><br><strong>Markdown是一种轻量级的「标记语言」</strong></p>
<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”</p>
<blockquote>
<p>Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如<del>Pandoc</del>，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p>
</blockquote>
<p><img src="https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png" alt="Pandao editor.md" title="Pandao editor.md"></p>
<h2 id="Markdown的功能列表演示"><a href="#Markdown的功能列表演示" class="headerlink" title="Markdown的功能列表演示"></a>Markdown的功能列表演示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 标题H1</span><br></pre></td></tr></table></figure>

<h1 id="标题H1"><a href="#标题H1" class="headerlink" title="标题H1"></a>标题H1</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 标题H2</span><br></pre></td></tr></table></figure>

<h2 id="标题H2"><a href="#标题H2" class="headerlink" title="标题H2"></a>标题H2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 标题H3</span><br></pre></td></tr></table></figure>

<h3 id="标题H3"><a href="#标题H3" class="headerlink" title="标题H3"></a>标题H3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 标题H4</span><br></pre></td></tr></table></figure>

<h4 id="标题H4"><a href="#标题H4" class="headerlink" title="标题H4"></a>标题H4</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##### 标题H5</span><br></pre></td></tr></table></figure>

<h5 id="标题H5"><a href="#标题H5" class="headerlink" title="标题H5"></a>标题H5</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###### 标题H6</span><br></pre></td></tr></table></figure>

<h6 id="标题H6"><a href="#标题H6" class="headerlink" title="标题H6"></a>标题H6</h6><h3 id="字符效果和横线等"><a href="#字符效果和横线等" class="headerlink" title="字符效果和横线等"></a>字符效果和横线等</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~删除线~~ &lt;s&gt;删除线（开启识别HTML标签时）&lt;&#x2F;s&gt;</span><br></pre></td></tr></table></figure>

<p><del>删除线</del> <s>删除线（开启识别HTML标签时）</s></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体字*      _斜体字_</span><br></pre></td></tr></table></figure>

<p><em>斜体字</em>      <em>斜体字</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**粗体**  __粗体__</span><br></pre></td></tr></table></figure>

<p><strong>粗体</strong>  <strong>粗体</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***粗斜体*** ___粗斜体___</span><br></pre></td></tr></table></figure>

<p><strong><em>粗斜体</em></strong> <strong><em>粗斜体</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上标：X&lt;sub&gt;2&lt;&#x2F;sub&gt;，下标：O&lt;sup&gt;2&lt;&#x2F;sup&gt;</span><br></pre></td></tr></table></figure>

<p>上标：X<sub>2</sub>，下标：O<sup>2</sup></p>
<p><strong>缩写(同HTML的abbr标签)</strong></p>
<blockquote>
<p>即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The &lt;abbr title&#x3D;&quot;Hyper Text Markup Language&quot;&gt;HTML&lt;&#x2F;abbr&gt; specification is maintained by the &lt;abbr title&#x3D;&quot;World Wide Web Consortium&quot;&gt;W3C&lt;&#x2F;abbr&gt;.</span><br></pre></td></tr></table></figure>

<p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p>
<h3 id="引用-Blockquotes"><a href="#引用-Blockquotes" class="headerlink" title="引用 Blockquotes"></a>引用 Blockquotes</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 引用文本 Blockquotes</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用文本 Blockquotes</p>
</blockquote>
<p>引用的行内混合 Blockquotes</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 引用：如果想要插入空白换行&#96;即&lt;br &#x2F;&gt;标签&#96;，在插入处先键入两个以上的空格然后回车即可，[普通链接](https:&#x2F;&#x2F;www.mdeditor.com&#x2F;)。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用：如果想要插入空白换行<code>即&lt;br /&gt;标签</code>，在插入处先键入两个以上的空格然后回车即可，<a href="https://www.mdeditor.com/">普通链接</a>。</p>
</blockquote>
<h3 id="锚点与链接-Links"><a href="#锚点与链接-Links" class="headerlink" title="锚点与链接 Links"></a>锚点与链接 Links</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[普通链接](https:&#x2F;&#x2F;www.mdeditor.com&#x2F;)</span><br><span class="line">[普通链接带标题](https:&#x2F;&#x2F;www.mdeditor.com&#x2F; &quot;普通链接带标题&quot;)</span><br><span class="line">直接链接：&lt;https:&#x2F;&#x2F;www.mdeditor.com&gt;</span><br><span class="line">[锚点链接][anchor-id]</span><br><span class="line">[anchor-id]: https:&#x2F;&#x2F;www.mdeditor.com&#x2F;</span><br><span class="line">[mailto:test.test@gmail.com](mailto:test.test@gmail.com)</span><br><span class="line">GFM a-tail link @pandao</span><br><span class="line">邮箱地址自动链接 test.test@gmail.com  www@vip.qq.com</span><br><span class="line">&gt; @pandao</span><br></pre></td></tr></table></figure>

<p><a href="https://www.mdeditor.com/">普通链接</a><br><a href="https://www.mdeditor.com/" title="普通链接带标题">普通链接带标题</a><br>直接链接：<a href="https://www.mdeditor.com/">https://www.mdeditor.com</a><br>[锚点链接][anchor-id]<br>[anchor-id]: <a href="https://www.mdeditor.com/">https://www.mdeditor.com/</a><br><a href="mailto:test.test@gmail.com">mailto:test.test@gmail.com</a><br>GFM a-tail link @pandao<br>邮箱地址自动链接 <a href="mailto:&#116;&#x65;&#115;&#116;&#46;&#x74;&#x65;&#115;&#116;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;">&#116;&#x65;&#115;&#116;&#46;&#x74;&#x65;&#115;&#116;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;</a>  <a href="mailto:&#x77;&#119;&#119;&#64;&#118;&#105;&#112;&#46;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;">&#x77;&#119;&#119;&#64;&#118;&#105;&#112;&#46;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;</a></p>
<blockquote>
<p>@pandao</p>
</blockquote>
<h3 id="多语言代码高亮-Codes"><a href="#多语言代码高亮-Codes" class="headerlink" title="多语言代码高亮 Codes"></a>多语言代码高亮 Codes</h3><h4 id="行内代码-Inline-code"><a href="#行内代码-Inline-code" class="headerlink" title="行内代码 Inline code"></a>行内代码 Inline code</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行命令：&#96;npm install marked&#96;</span><br></pre></td></tr></table></figure>

<p>执行命令：<code>npm install marked</code></p>
<h4 id="缩进风格"><a href="#缩进风格" class="headerlink" title="缩进风格"></a>缩进风格</h4><p>即缩进四个空格，也做为实现类似 <code>&lt;pre&gt;</code> 预格式化文本 ( Preformatted Text ) 的功能。</p>
<pre><code>&lt;?php
    echo &quot;Hello world!&quot;;
?&gt;</code></pre>
<p>预格式化文本：</p>
<pre><code>| First Header  | Second Header |
| ------------- | ------------- |
| Content Cell  | Content Cell  |
| Content Cell  | Content Cell  |</code></pre>
<h4 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HTML-代码-HTML-codes"><a href="#HTML-代码-HTML-codes" class="headerlink" title="HTML 代码 HTML codes"></a>HTML 代码 HTML codes</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mate</span> <span class="attr">charest</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Editor.md, Markdown, Editor&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;<span class="attribute">color</span>:<span class="number">#444</span>;<span class="attribute">font-family</span>: <span class="string">&quot;Microsoft Yahei&quot;</span>, Tahoma, <span class="string">&quot;Hiragino Sans GB&quot;</span>, Arial;<span class="attribute">background</span>:<span class="number">#fff</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">ul</span>&#123;<span class="attribute">list-style</span>: none;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">img</span>&#123;<span class="attribute">border</span>:none;<span class="attribute">vertical-align</span>: middle;&#125;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;text-xxl&quot;</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text-green&quot;</span>&gt;</span>Plain text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="图片-Images"><a href="#图片-Images" class="headerlink" title="图片 Images"></a>图片 Images</h3><p>图片加链接 (Image + Link)：</p>
<p><a href="https://www.mdeditor.com/images/logos/markdown.png" title="markdown"><img src="https://www.mdeditor.com/images/logos/markdown.png"></a></p>
<blockquote>
<p>Follow your heart.</p>
</blockquote>
<hr>
<h3 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表 Lists"></a>列表 Lists</h3><h4 id="无序列表（减号）Unordered-Lists"><a href="#无序列表（减号）Unordered-Lists" class="headerlink" title="无序列表（减号）Unordered Lists (-)"></a>无序列表（减号）Unordered Lists (-)</h4><ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h4 id="无序列表（星号）Unordered-Lists"><a href="#无序列表（星号）Unordered-Lists" class="headerlink" title="无序列表（星号）Unordered Lists (*)"></a>无序列表（星号）Unordered Lists (*)</h4><ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h4 id="无序列表（加号和嵌套）Unordered-Lists"><a href="#无序列表（加号和嵌套）Unordered-Lists" class="headerlink" title="无序列表（加号和嵌套）Unordered Lists (+)"></a>无序列表（加号和嵌套）Unordered Lists (+)</h4><ul>
<li>列表一</li>
<li>列表二<ul>
<li>列表二-1</li>
<li>列表二-2</li>
<li>列表二-3</li>
</ul>
</li>
<li>列表三<ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
</li>
</ul>
<h4 id="有序列表-Ordered-Lists"><a href="#有序列表-Ordered-Lists" class="headerlink" title="有序列表 Ordered Lists (-)"></a>有序列表 Ordered Lists (-)</h4><ol>
<li>第一行</li>
<li>第二行</li>
<li>第三行</li>
</ol>
<h4 id="GFM-task-list"><a href="#GFM-task-list" class="headerlink" title="GFM task list"></a>GFM task list</h4><ul>
<li><input checked="" disabled="" type="checkbox"> GFM task list 1</li>
<li><input checked="" disabled="" type="checkbox"> GFM task list 2</li>
<li><input disabled="" type="checkbox"> GFM task list 3<ul>
<li><input disabled="" type="checkbox"> GFM task list 3-1</li>
<li><input disabled="" type="checkbox"> GFM task list 3-2</li>
<li><input disabled="" type="checkbox"> GFM task list 3-3</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> GFM task list 4<ul>
<li><input disabled="" type="checkbox"> GFM task list 4-1</li>
<li><input disabled="" type="checkbox"> GFM task list 4-2</li>
</ul>
</li>
</ul>
<hr>
<h3 id="绘制表格-Tables"><a href="#绘制表格-Tables" class="headerlink" title="绘制表格 Tables"></a>绘制表格 Tables</h3><table>
<thead>
<tr>
<th>项目</th>
<th align="right">价格</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td>计算机</td>
<td align="right">$1600</td>
<td align="center">5</td>
</tr>
<tr>
<td>手机</td>
<td align="right">$12</td>
<td align="center">12</td>
</tr>
<tr>
<td>管线</td>
<td align="right">$1</td>
<td align="center">234</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Function name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>help()</code></td>
<td>Display the help window.</td>
</tr>
<tr>
<td><code>destroy()</code></td>
<td><strong>Destroy your computer!</strong></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">Left-Aligned</th>
<th align="center">Center Aligned</th>
<th align="right">Right Aligned</th>
</tr>
</thead>
<tbody><tr>
<td align="left">col 3 is</td>
<td align="center">some wordy text</td>
<td align="right">$1600</td>
</tr>
<tr>
<td align="left">col 2 is</td>
<td align="center">centered</td>
<td align="right">$12</td>
</tr>
<tr>
<td align="left">zebra stripes</td>
<td align="center">are neat</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Item</th>
<th align="right">Value</th>
</tr>
</thead>
<tbody><tr>
<td>Computer</td>
<td align="right">$1600</td>
</tr>
<tr>
<td>Phone</td>
<td align="right">$12</td>
</tr>
<tr>
<td>Pipe</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<hr>
<h4 id="特殊符号-HTML-Entities-Codes"><a href="#特殊符号-HTML-Entities-Codes" class="headerlink" title="特殊符号 HTML Entities Codes"></a>特殊符号 HTML Entities Codes</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;copy; &amp;  &amp;uml; &amp;trade; &amp;iexcl; &amp;pound;</span><br><span class="line"></span><br><span class="line">&amp; &lt; &gt; &amp;yen; &amp;euro; &amp;reg; </span><br><span class="line"></span><br><span class="line">&amp;plusmn; &amp;para; &amp;sect; &amp;brvbar; &amp;macr; &amp;laquo; &amp;middot;</span><br><span class="line"></span><br><span class="line">X&amp;sup2; Y&amp;sup3; &amp;frac34; &amp;frac14;  &amp;times;  &amp;divide;   &amp;raquo;</span><br><span class="line"></span><br><span class="line">18&amp;ordm;C  &quot;  &amp;apos;</span><br></pre></td></tr></table></figure>

<p>&copy; &amp;  &uml; &trade; &iexcl; &pound;</p>
<p>&amp; &lt; &gt; &yen; &euro; &reg; </p>
<p>&plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot;</p>
<p>X&sup2; Y&sup3; &frac34; &frac14;  &times;  &divide;   &raquo;</p>
<p>18&ordm;C  &quot;  &apos;</p>
<hr>
<h3 id="Emoji表情-smiley"><a href="#Emoji表情-smiley" class="headerlink" title="Emoji表情 :smiley:"></a>Emoji表情 :smiley:</h3><blockquote>
<p>Blockquotes :star:</p>
</blockquote>
<h4 id="GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x"><a href="#GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x" class="headerlink" title="GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:"></a>GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:</h4><ul>
<li><input checked="" disabled="" type="checkbox"> :smiley: @mentions, :smiley: #refs, <a href="">links</a>, <strong>formatting</strong>, and <del>tags</del> supported :editormd-logo:;</li>
<li><input checked="" disabled="" type="checkbox"> list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;</li>
<li><input checked="" disabled="" type="checkbox"> [ ] :smiley: this is a complete item :smiley:;</li>
<li><input disabled="" type="checkbox"> []this is an incomplete item <a href="#">test link</a> :fa-star: @pandao;</li>
<li><input disabled="" type="checkbox"> [ ]this is an incomplete item :fa-star: :fa-gear:;<ul>
<li><input disabled="" type="checkbox"> :smiley: this is an incomplete item <a href="#">test link</a> :fa-star: :fa-gear:;</li>
<li><input disabled="" type="checkbox"> :smiley: this is  :fa-star: :fa-gear: an incomplete item <a href="#">test link</a>;</li>
</ul>
</li>
</ul>
<h4 id="反斜杠-Escape"><a href="#反斜杠-Escape" class="headerlink" title="反斜杠 Escape"></a>反斜杠 Escape</h4><p>*literal asterisks*</p>
<hr>
<h3 id="科学公式-TeX-KaTeX"><a href="#科学公式-TeX-KaTeX" class="headerlink" title="科学公式 TeX(KaTeX)"></a>科学公式 TeX(KaTeX)</h3><p>$$E=mc^2$$</p>
<p>行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。</p>
<p>$$x &gt; y$$</p>
<p>$$(\sqrt{3x-1}+(1+x)^2)$$</p>
<p>$$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$</p>
<p>多行公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n a\_k b\_k \right)^2</span><br><span class="line">\leq</span><br><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n a\_k^2 \right)</span><br><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n b\_k^2 \right)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">    \frac&#123;1&#125;&#123;</span><br><span class="line">        \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;</span><br><span class="line">        \frac25 \pi&#125;&#125; &#x3D; 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;</span><br><span class="line">        1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span><br><span class="line">        &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125;</span><br><span class="line">         &#123;1+\cdots&#125; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">f(x) = <span class="tag">\<span class="name">int</span></span>_&#123;-<span class="tag">\<span class="name">infty</span></span>&#125;^<span class="tag">\<span class="name">infty</span></span></span><br><span class="line">    <span class="tag">\<span class="name">hat</span></span> f(<span class="tag">\<span class="name">xi</span></span>)<span class="tag">\<span class="name">,</span></span>e^&#123;2 <span class="tag">\<span class="name">pi</span></span> i <span class="tag">\<span class="name">xi</span></span> x&#125;</span><br><span class="line">    <span class="tag">\<span class="name">,</span></span>d<span class="tag">\<span class="name">xi</span></span></span><br></pre></td></tr></table></figure>
<h3 id="分页符-Page-break"><a href="#分页符-Page-break" class="headerlink" title="分页符 Page break"></a>分页符 Page break</h3><blockquote>
<p>Print Test: Ctrl + P</p>
</blockquote>
<hr>
<h3 id="绘制流程图-Flowchart"><a href="#绘制流程图-Flowchart" class="headerlink" title="绘制流程图 Flowchart"></a>绘制流程图 Flowchart</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 用户登陆</span><br><span class="line">op&#x3D;&gt;operation: 登陆操作</span><br><span class="line">cond&#x3D;&gt;condition: 登陆成功 Yes or No?</span><br><span class="line">e&#x3D;&gt;end: 进入后台</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="绘制序列图-Sequence-Diagram"><a href="#绘制序列图-Sequence-Diagram" class="headerlink" title="绘制序列图 Sequence Diagram"></a>绘制序列图 Sequence Diagram</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello</span><br><span class="line">Note right of China: China thinks\nabout it</span><br><span class="line">China--&gt;Andrew: How are you?</span><br><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span><br></pre></td></tr></table></figure>
<h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git 免重复输入密码</span></span><br><span class="line">git config --global credential.helper store</span><br><span class="line"></span><br><span class="line"><span class="comment"># zsh gi 模块，自动生产.gitignore 文件</span></span><br><span class="line">gi python &gt; .gitignore</span><br><span class="line"></span><br><span class="line"><span class="comment"># git 从本地连接远端仓库(非 git clone 下来的代码)</span></span><br><span class="line">git remote add origin &lt;url&gt;</span><br><span class="line">git pull --rebase origin master</span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># git 强制拉取最新代码</span></span><br><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/&lt;develop&gt;</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h2 id="git-撤销命令详解"><a href="#git-撤销命令详解" class="headerlink" title="git 撤销命令详解"></a>git 撤销命令详解</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<h3 id="修改最后一次commit的内容"><a href="#修改最后一次commit的内容" class="headerlink" title="修改最后一次commit的内容"></a>修改最后一次commit的内容</h3><p>文件修改后<code>git add</code>了，也<code>git commit</code>了，发现哪里错了或者是漏<code>add</code>了一个文件，可以先<code>git add file</code>后，再<code>git commit –amend</code>这样只会记录一次<code>commit</code>（相当于将两次<code>commit</code>合并成了一次<code>commit</code>）。</p>
<h3 id="取消加入暂存区的文件"><a href="#取消加入暂存区的文件" class="headerlink" title="取消加入暂存区的文件"></a>取消加入暂存区的文件</h3><p>不小心用了<code>git add .</code>将所有文件加入了暂存区或者是<code>add</code>多了文件，可以使用<code>git reset HEAD &lt;file&gt;</code>将文件拉回到已修改但是未提交到暂存区的状态。（在<code>add</code>后，通过<code>git status</code>可以看到相应提示，教你如何撤销提交）</p>
<h3 id="取消对当前目录下文件的修改"><a href="#取消对当前目录下文件的修改" class="headerlink" title="取消对当前目录下文件的修改"></a>取消对当前目录下文件的修改</h3><p>不小心将文件改崩了，或者发现文件根本没必要修改，可以用<code>git checkout — &lt;file&gt;</code>取消工作区的文件的修改。（同样的，在修改文件后，通过<code>git status</code>可以看到相应提示）</p>
<h3 id="reset-命令的3种模式"><a href="#reset-命令的3种模式" class="headerlink" title="reset 命令的3种模式"></a>reset 命令的3种模式</h3><p><code>git reset –option &lt;commitid&gt;</code>是回滚命令，option 有三个参数可选：</p>
<ol>
<li><code>git reset –mixed</code>，这也是默认方式（即不带参数默认是这种），回退暂存区和版本库信息，工作区的源码不会变化，可以重新add，重新commit。</li>
<li><code>git reset –soft</code>，回退版本库信息，暂存区和工作区都不会变化，如果还要提交，直接commit即可。</li>
<li><code>git reset –hard</code>，彻底回退，3个区都回退到历史某个版本。</li>
</ol>
<h3 id="回滚某个文件"><a href="#回滚某个文件" class="headerlink" title="回滚某个文件"></a>回滚某个文件</h3><ol>
<li><code>git log –pretty=oneline &lt;file&gt;</code>可以查看某个文件的修改历史。</li>
<li><code>git show commit_id &lt;file&gt;</code>可以查看对应某个<code>commit</code>时期<code>file</code>的内容。</li>
<li><code>git reset commit_id &lt;file&gt;</code>可以将<code>file</code>回退到某个版本</li>
<li>执行完第3步后提示：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Unstaged changes after reset:</span><br><span class="line">M       README.md</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>执行<code>git status</code>，提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br></pre></td></tr></table></figure>
<p>执行<code>git checkout — &lt;file&gt;</code>后，README.md成功回滚到指定版本。</p>
<h2 id="git-去掉多余的commit"><a href="#git-去掉多余的commit" class="headerlink" title="git 去掉多余的commit"></a>git 去掉多余的commit</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i &lt;commit_ID&gt;</span><br><span class="line">git rebase -i master</span><br><span class="line">git rebase -i HEAD~&lt;num&gt;</span><br><span class="line"></span><br><span class="line">// squash：将这一行的 commit 与上一个 commit 进行合并</span><br><span class="line">// fixup：与 squash 相同，只是不会保留这行 commit 的提交 message 信息</span><br><span class="line"></span><br><span class="line">// 修改上一次 commit 提交的 message</span><br><span class="line">git commit --amend</span><br><span class="line">// 不过只能修正上一次的 commit。如果很多个 commit 之前就有 message 写错，就得用上我们之前说的 git rebase 了</span><br><span class="line"></span><br><span class="line">// 自动标记这一次的 commit 为上一个 commit 的 fix</span><br><span class="line">git commit --fixup &lt;commit&gt;</span><br><span class="line">// 自动组织合并两个 commit</span><br><span class="line">git rebase -i --autosquash</span><br><span class="line"></span><br><span class="line">// 撤销过去的 commit 重建一个新的</span><br><span class="line">git reset HEAD~2</span><br><span class="line">git add .</span><br><span class="line">git commit -am <span class="string">&quot;This is the new feature&quot;</span></span><br><span class="line">git push --force</span><br></pre></td></tr></table></figure>

<h2 id="git-commit-技巧"><a href="#git-commit-技巧" class="headerlink" title="git commit 技巧"></a>git commit 技巧</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -s -m  </span><br><span class="line">// 在git <span class="built_in">log</span> 的时候会多展示 signed-off-by  行</span><br><span class="line"></span><br><span class="line">git commit -a -m </span><br><span class="line">// 用于提交跟踪过的文件 ；会自动把修改的文件，先暂存，然后直接commit </span><br><span class="line">// 相当于git add . 与git commit –m “本次提交描述”两句操作合并为一句进行使用。</span><br></pre></td></tr></table></figure>

<h1 id="linux-Unix"><a href="#linux-Unix" class="headerlink" title="linux/Unix"></a>linux/Unix</h1><p><a href="#toc">&lt;返回目录&gt;</a></p>
<h2 id="访问本机接口"><a href="#访问本机接口" class="headerlink" title="访问本机接口"></a>访问本机接口</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --location --request POST <span class="string">&#x27;http://本机IP/接口&#x27;</span> --header <span class="string">&#x27;Content-Type: application/x-www-form-urlencoded&#x27;</span> --data-urlencode <span class="string">&#x27;data=[&#123;&quot;type&quot;:1,&quot;brand&quot;:&quot;GE&quot;,&quot;ae_oe_code&quot;:&quot;9261317&quot;&#125;]&#x27;</span></span><br><span class="line"></span><br><span class="line">curl --location --request GET <span class="string">&#x27;http://127.0.0.1:18016/honda/oe_by_std_name?vin=LVHRM1836D5019492&amp;std_name=%E6%B3%A2%E7%AE%B1%E6%B2%B9&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="查看-log-技巧"><a href="#查看-log-技巧" class="headerlink" title="查看 log 技巧"></a>查看 log 技巧</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tail -f &lt;file&gt; i//自动刷新查看文件，适用于查看日志，相对于cat的优点在于不用全部打开，只会看最新的几行，看大文件时不会那么容易卡死</span><br><span class="line"></span><br><span class="line">//查看nginx日志，并进行过滤</span><br><span class="line">tail -f /var/<span class="built_in">log</span>/nginx/access.log | grep XXX </span><br></pre></td></tr></table></figure>

<h2 id="vim-常用快捷键"><a href="#vim-常用快捷键" class="headerlink" title="vim 常用快捷键"></a>vim 常用快捷键</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ </span><br><span class="line">// 光标移动到最后一个字符</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> </span><br><span class="line">// 光标移动到首位</span><br><span class="line"></span><br><span class="line">ZZ </span><br><span class="line">// 保存退出</span><br><span class="line"></span><br><span class="line">dt<span class="symbol">&lt;character&gt;</span></span><br><span class="line">// 删除到该字符</span><br><span class="line"></span><br><span class="line"><span class="keyword">f</span><span class="symbol">&lt;character&gt;</span></span><br><span class="line">// 将光标移动到，从光标当前位置开始第一个该字符的位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<h3 id="brew-相关命令"><a href="#brew-相关命令" class="headerlink" title="brew 相关命令"></a>brew 相关命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">更新：brew update</span><br><span class="line">查看版本：brew -v</span><br><span class="line">帮助信息：brew -h</span><br><span class="line"></span><br><span class="line">查询软件的详细信息：brew info &lt;软件名&gt;</span><br><span class="line">查看安装列表：brew list</span><br><span class="line"></span><br><span class="line">安装软件包：brew install &lt;软件名&gt;</span><br><span class="line">卸载软件包：brew uninstall &lt;软件名&gt;</span><br><span class="line">彻底卸载指定软件，包括旧版本：brew uninstall --force &lt;软件名&gt;</span><br><span class="line"></span><br><span class="line">搜索软件：brew search &lt;正则表达式&#x2F;软件名&gt;</span><br><span class="line">更新所有软件包：brew upgrade &lt;软件名&gt;</span><br><span class="line">查询有更新版本的软件：brew outdated</span><br><span class="line">清理指定软件的过时包：brew cleanup &lt;软件名&gt;</span><br><span class="line">清理所有的过时软件：brew cleanup</span><br><span class="line">列出需要清理的内容：brew cleanup -n</span><br><span class="line"></span><br><span class="line">用浏览器打开相关包的页面：brew home &lt;软件名&gt;</span><br><span class="line">显示包依赖：brew deps &lt;软件名&gt;</span><br><span class="line">锁定某个包：brew pin $FORMULA</span><br><span class="line">取消锁定：brew unpin $FORMULA</span><br><span class="line">查看已安装的包的依赖，树形显示：brew deps --installed --tree </span><br></pre></td></tr></table></figure>

<h3 id="brew-应用包"><a href="#brew-应用包" class="headerlink" title="brew 应用包"></a>brew 应用包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tree</span><br><span class="line">// 显示目录层级关系</span><br><span class="line"></span><br><span class="line">youtube-dl</span><br><span class="line">// 下载youtube视频</span><br><span class="line"></span><br><span class="line">ncdu</span><br><span class="line">// 查看磁盘占用情况</span><br><span class="line"></span><br><span class="line">ffmpeg</span><br><span class="line">// 音视频格式转换转码</span><br><span class="line"></span><br><span class="line">you-get</span><br><span class="line">// 下载爬取视频</span><br><span class="line"></span><br><span class="line">thefuck</span><br><span class="line">// 自动重输正确的建议命令</span><br></pre></td></tr></table></figure>

<h2 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h2><p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git</span><br><span class="line">// git 快捷指令 由↓查看快捷指令</span><br><span class="line">// cat ~/.oh-my-zsh/plugins/git/git.plugin.zsh</span><br><span class="line"></span><br><span class="line">gitignore</span><br><span class="line">// 自动生成gitignore文件</span><br><span class="line">// gi &lt;c/c++/python/...&gt; &gt; .gitignore</span><br><span class="line"></span><br><span class="line">zsh_reload</span><br><span class="line">// src 重载zsh</span><br><span class="line"></span><br><span class="line">git-open</span><br><span class="line">// 在任何一个git目录，输入git-open 就可以打开github对应的页面</span><br><span class="line"></span><br><span class="line">safe-paste</span><br><span class="line">// 当你往 zsh 粘贴脚本时，它不会被立刻运行</span><br><span class="line"></span><br><span class="line">extract</span><br><span class="line">// 万能解压命令</span><br><span class="line"></span><br><span class="line">gh-md-toc</span><br><span class="line">// md目录生成工具，<span class="built_in">alias</span> -&gt; mdtoc</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Personal</tag>
      </tags>
  </entry>
  <entry>
    <title>spawn-fcgi 用法了解</title>
    <url>/2020/08/29/C++%20spawn-fcgi%20%E7%94%A8%E6%B3%95%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="spawn-fcgi-用法了解"><a href="#spawn-fcgi-用法了解" class="headerlink" title="spawn-fcgi 用法了解"></a>spawn-fcgi 用法了解</h1><p>spawn-fcgi 是一个小程序，作用是管理 fast-cgi 进程。</p>
<p>用 spawn 启动 FCGI 程序的方式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./spawn-fcgi -a 127.0.0.1 -p 8080 -F <span class="variable">$&#123;count&#125;</span> -f <span class="variable">$&#123;webroot&#125;</span>/bin/demo.fcgi</span><br></pre></td></tr></table></figure>

 <a id="more"></a>

<p>这样就会启动 count 个 demo.fcgi 程序，他们共同监听同一个 listen 端口 8080，从而提供服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./spawn_fcgi -h</span><br><span class="line">Usage: spawn-fcgi [options] [-- &lt;fcgiapp&gt; [fcgi app arguments]]</span><br><span class="line"></span><br><span class="line">spawn-fcgi v1.6.5 - spawns FastCGI processes</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -f &lt;path&gt;      filename of the fcgi-application (deprecated; ignored <span class="keyword">if</span></span><br><span class="line">                &lt;fcgiapp&gt; is given; needs /bin/sh)</span><br><span class="line"> -d &lt;directory&gt; <span class="built_in">chdir</span> to directory before spawning</span><br><span class="line"> -a &lt;address&gt;   <span class="built_in">bind</span> to IPv4/IPv6 address (defaults to 0.0.0.0)</span><br><span class="line"> -p &lt;port&gt;      <span class="built_in">bind</span> to TCP-port</span><br><span class="line"> -s &lt;path&gt;      <span class="built_in">bind</span> to Unix domain socket</span><br><span class="line"> -M &lt;mode&gt;      change Unix domain socket mode (octal <span class="built_in">integer</span>, default: allow</span><br><span class="line">                <span class="built_in">read</span>+write <span class="keyword">for</span> user and group as far as <span class="built_in">umask</span> allows it)</span><br><span class="line"> -C &lt;children&gt;  (PHP only) numbers of childs to spawn (default: not setting</span><br><span class="line">                the PHP_FCGI_CHILDREN environment variable - PHP defaults to 0)</span><br><span class="line"> -F &lt;children&gt;  number of children to fork (default 1)</span><br><span class="line"> -b &lt;backlog&gt;   backlog to allow on the socket (default 1024)</span><br><span class="line"> -P &lt;path&gt;      name of PID-file <span class="keyword">for</span> spawned process (ignored <span class="keyword">in</span> no-fork mode)</span><br><span class="line"> -n             no fork (<span class="keyword">for</span> daemontools)</span><br><span class="line"> -v             show version</span><br><span class="line"> -?, -h         show this <span class="built_in">help</span></span><br><span class="line">(root only)</span><br><span class="line"> -c &lt;directory&gt; chroot to directory</span><br><span class="line"> -S             create socket before chroot() (default is to create the socket</span><br><span class="line">                <span class="keyword">in</span> the chroot)</span><br><span class="line"> -u &lt;user&gt;      change to user-id</span><br><span class="line"> -g &lt;group&gt;     change to group-id (default: primary group of user <span class="keyword">if</span> -u</span><br><span class="line">                is given)</span><br><span class="line"> -U &lt;user&gt;      change Unix domain socket owner to user-id</span><br><span class="line"> -G &lt;group&gt;     change Unix domain socket group to group-id</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 知识总结</title>
    <url>/2020/08/29/C++%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="C-Vector-遍历"><a href="#C-Vector-遍历" class="headerlink" title="C++ Vector 遍历"></a>C++ Vector 遍历</h1><blockquote>
<p><code>vector&lt;int&gt; v1&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10&#125;;</code></p>
</blockquote>
<h2 id="一、通过数组下标遍历"><a href="#一、通过数组下标遍历" class="headerlink" title="一、通过数组下标遍历"></a>一、通过数组下标遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v1.at(i) &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="二、通过迭代器遍历"><a href="#二、通过迭代器遍历" class="headerlink" title="二、通过迭代器遍历"></a>二、通过迭代器遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = v1.begin(); iter != v1.end(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

 <a id="more"></a>

<h2 id="三、C-11标准，auto关键字遍历"><a href="#三、C-11标准，auto关键字遍历" class="headerlink" title="三、C++11标准，auto关键字遍历"></a>三、C++11标准，auto关键字遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = v1.begin(); iter != v1.end(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="四、for-each加函数"><a href="#四、for-each加函数" class="headerlink" title="四、for_each加函数"></a>四、for_each加函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printer</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    for_each(v1.cbegin(), v1.cend(), printer&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>


<h1 id="C-计时方法——chrono"><a href="#C-计时方法——chrono" class="headerlink" title="C++ 计时方法——chrono"></a>C++ 计时方法——chrono</h1><p><strong>传统计时方法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> start = clock();</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line"><span class="keyword">clock_t</span> end   = clock();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;花费了&quot;</span> &lt;&lt; (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;秒&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>此方法可以精确到毫秒，输出样例：<strong>花费了0.123秒</strong></p>
<p><strong>C++11 最佳计时方法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;   </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> chrono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> start = system_clock::now();</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line"><span class="keyword">auto</span> end   = system_clock::now();</span><br><span class="line"><span class="keyword">auto</span> duration = duration_cast&lt;microseconds&gt;(end - start);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;  <span class="string">&quot;花费了&quot;</span> &lt;&lt; <span class="keyword">double</span>(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; <span class="string">&quot;秒&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//duration_cast&lt; &gt; 表示类型转换</span></span><br><span class="line"><span class="comment">//microseconds 表示微妙。除此之外，还有五种时间单位：hours, minutes, seconds, milliseconds, nanoseconds</span></span><br><span class="line"><span class="comment">//num 和 den分别表示分子(numerator)和分母(denominator)。在我给出的代码中，num等于1， den等于1,000,000</span></span><br><span class="line"><span class="comment">//count( ) 用来返回时间</span></span><br></pre></td></tr></table></figure>

<h1 id="C-Vector-去重"><a href="#C-Vector-去重" class="headerlink" title="C++ Vector 去重"></a>C++ Vector 去重</h1><p>使用场景上来说 vector不便于做删除操作 所以一般vector的删除需要借助别的数据结构。</p>
<p><strong>方法一：</strong>使用 set</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveRepeat1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">setVec</span><span class="params">(vec.begin(), vec.end())</span></span>;</span><br><span class="line">    vec.assign(setVec.begin(), setVec.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong>使用 sort + unique 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveRepeat2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(vec.begin(),vec.end());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// unique让所有重复的数都放到最后，返回一个迭代器</span></span><br><span class="line">    <span class="comment">// 1 2 3 4 3 就是返回3的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> it = unique(vec.begin(), vec.end());</span><br><span class="line"></span><br><span class="line">    vec.erase(it, vec.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-map-插入数据的方法"><a href="#C-map-插入数据的方法" class="headerlink" title="C++ map 插入数据的方法"></a>C++ map 插入数据的方法</h1><p>在构造map容器后，我们就可以往里面插入数据了。这里有三种插入数据的方法：</p>
<p> <strong>方法一：</strong>用 insert 函数插入 pair 数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br><span class="line">mapStudent.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>,“student_one”));</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong>用 insert 函数插入 value_type 数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br><span class="line">mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">1</span>,<span class="string">&quot;student_one&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>方法三：</strong>用 make_pair</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mapStudent.insert(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>方法四：</strong>用数组方式插入数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br><span class="line">mapStudent[<span class="number">1</span>] = “student_one”;</span><br><span class="line">mapStudent[<span class="number">2</span>] = “student_two”;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mapStudent;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">m[s]++;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>insert 函数插入数据，在数据的插入上，涉及到集合的唯一性这个概念，即当 map 中有这个关键字时，insert 操作是不能再插入这个数据的，但是用数组方式就不同了，它可以覆盖以前该关键字对应的值。</p>
<p><strong>PS:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line">    m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>));</span><br><span class="line">    m.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>));</span><br><span class="line">    m.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line"></span><br><span class="line">    for_each(m.cbegin(), m.cend(), [](<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; &amp;it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;first:&quot;</span> &lt;&lt; it.first &lt;&lt; <span class="string">&quot; second:&quot;</span> &lt;&lt; it.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lambda 中的参数列表要写成 pair 类型，因为 map 返回的是一对数据，是 pair 型的，不可只用 map&lt;int,string&gt;::iterator it 迭代器来遍历。</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 那些年我们总会遇到的坑</title>
    <url>/2020/08/29/C++%20%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E6%80%BB%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h1 id="那些年我们总会遇到的坑"><a href="#那些年我们总会遇到的坑" class="headerlink" title="那些年我们总会遇到的坑"></a>那些年我们总会遇到的坑</h1><h1 id="1-curl"><a href="#1-curl" class="headerlink" title="1. curl"></a>1. curl</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CurlCXX <span class="title">curl</span><span class="params">(url, <span class="number">1</span>)</span></span>; <span class="comment">//1s timeout</span></span><br><span class="line">curl.post(body);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意学会<code>curl</code>发包的用法，并且<code>post</code>时，<code>body</code>当中要注意<code>fastcgi</code>框架当中约定了<code>post</code>数据格式为<code>x-www-form-urlencoded/form-data</code>，因此一定要注意<code>body</code>里面的数据，单个字段内不能出现容易导致解析错误的<code>&#39;&amp;&#39;</code>字符，若不得不包含<code>&#39;&amp;&#39;</code>字符，则要用转义字符<code>&#39;\&amp;&#39;</code>包起来，否则会导致参数错误。</p>
<a id="more"></a>

</li>
</ul>
<h1 id="2-const"><a href="#2-const" class="headerlink" title="2. const"></a>2. const</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CallRecord *app;</span><br><span class="line">app = app_ptr();</span><br><span class="line"><span class="keyword">const_cast</span>&lt;CallRecord *&gt;(app)-&gt;reload_cache();</span><br></pre></td></tr></table></figure>

<ul>
<li>注意对<code>const</code>类型的对象操作时，需要用<code>const_cast&lt;XXXXXX&gt;</code>对该对象进行强制类型转换。</li>
</ul>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 面试指导</title>
    <url>/2020/08/29/Golang%20%E9%9D%A2%E8%AF%95%E6%8C%87%E5%AF%BC/</url>
    <content><![CDATA[<h1 id="如果你是一个Golang面试官，你会问哪些问题"><a href="#如果你是一个Golang面试官，你会问哪些问题" class="headerlink" title="如果你是一个Golang面试官，你会问哪些问题?"></a>如果你是一个Golang面试官，你会问哪些问题?</h1><ul>
<li>语言设计中空引用(null reference)的存在有什么问题？假设你想要将空引用的概念从你的首选语言中移除，可能导致什么结果？</li>
<li>为什么函数式编程重要？什么时候适用函数式语言？</li>
<li>设计(design)、架构(architecture)、功能(functionality)和美学(aesthetic)之间有什么区别？讨论一下。</li>
<li>微软、谷歌、欧朋(opera)和火狐这类公司是如何从他们的浏览器中获利的?</li>
<li>为什么打开TCP套接字有很大的开销？ 封装的重要性体现在哪儿？</li>
<li>什么是实时系统？它与普通系统有什么区别？ 实时语言(real-time language)和堆内存分配(heap memory allocation)之间的关系是什么？ 不变性(Immutability)是指?</li>
<li>(变量的)值只能在创建的时候被设置一次，之后就不能被改变。为什么不变性对写更加安全的代码有帮助？ </li>
<li>可变值(mutable values)和不可变值(immutable values)有哪些优缺点？ </li>
<li>什么是O/R阻抗失衡(Object-Relational impedence mismatch)？ </li>
<li>如果你需要使用缓存，你使用哪些原则来确定缓存的大小？ TCP和HTTP有什么区别？</li>
</ul>
<a id="more"></a>


<p>原文参考：<a href="https://www.jianshu.com/p/6bdb4d3b8eaf">如果你是一个Golang面试官，你会问哪些问题?</a></p>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>python 文件处理</title>
    <url>/2020/08/14/python%20%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="python-读取-Excel-文档"><a href="#python-读取-Excel-文档" class="headerlink" title="python 读取 Excel 文档"></a>python 读取 Excel 文档</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_excel</span>(<span class="params">self, path</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.info(<span class="string">&quot;begin read %s&quot;</span> % path)</span><br><span class="line">        <span class="comment"># 读取 Excel 预处理动作↓，使用 xlrd 包将 Excel 文件读入 book 中</span></span><br><span class="line">        book = xlrd.open_workbook(path,encoding_override=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        data = dict()</span><br><span class="line">        sheets = book.sheets()</span><br><span class="line">        <span class="keyword">for</span> cur <span class="keyword">in</span> sheets:</span><br><span class="line">            sheet_name = cur.name</span><br><span class="line">            nrows = cur.nrows</span><br><span class="line">            ncols = cur.ncols</span><br><span class="line">            logger.info(<span class="string">&quot;nrows=%d,ncols=%d&quot;</span> % (nrows, ncols))</span><br><span class="line">            sheet_val = list()</span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">0</span>, nrows):</span><br><span class="line">                line = cur.row_values(idx)</span><br><span class="line">                <span class="comment"># sheet_val 为对应该页面每行数据的 list 数据</span></span><br><span class="line">                sheet_val.append(line)</span><br><span class="line">            <span class="comment"># data 为整个 Excel 文件每一张 sheet 的 Map 数据</span></span><br><span class="line">            data[sheet_name] = sheet_val</span><br><span class="line">        logger.info(<span class="string">&quot;read end, sheet=%d&quot;</span> % len(data))</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.info(<span class="string">&quot;read %s fail, err=%s&quot;</span> % (path, str(e)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

 <a id="more"></a>

<h1 id="python-Excel-数据处理"><a href="#python-Excel-数据处理" class="headerlink" title="python Excel 数据处理"></a>python Excel 数据处理</h1><p><strong>Excel 转换成 SQL 语句</strong></p>
<p>单独拉出一列，在首行传入该函数后，复制到每一行，可拉取对应列的数据，并转换为 sql 语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;CONCATENATE(&quot;INSERT INTO table_name (list_1,list_2,list_3) VALUES (&#39;&quot;,A1,&quot;&#39;,&#39;&quot;,B1,&quot;&#39;,&#39;&quot;,C1,&quot;&#39;);&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>Python 批量处理 Excel</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">连接数据库</span></span><br><span class="line"><span class="string">args：db_name（数据库名称）</span></span><br><span class="line"><span class="string">returns:db</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysql_link</span>(<span class="params">db_name</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        db = pymysql.connect(host=<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>,</span><br><span class="line">                             port=xxxx,</span><br><span class="line">                             user=<span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">                             passwd=<span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">                             db=db_name,</span><br><span class="line">                             charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">&quot;could not connect to mysql server&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">读取excel函数</span></span><br><span class="line"><span class="string">args：excel_file（excel文件，目录在py文件同目录）</span></span><br><span class="line"><span class="string">returns：book</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_excel</span>(<span class="params">excel_file</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        book = xlrd.open_workbook(excel_file)  <span class="comment"># 文件名，把文件与py文件放在同一目录下</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">&quot;open excel file failed!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> book</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">执行插入操作</span></span><br><span class="line"><span class="string">args:db_name（数据库名称）</span></span><br><span class="line"><span class="string">table_name(表名称）</span></span><br><span class="line"><span class="string">excel_file（excel文件名，把文件与py文件放在同一目录下）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">store_to</span>(<span class="params">db_name: object, table_name: object, excel_file: object</span>) -&gt; object:</span></span><br><span class="line">    db = mysql_link(db_name)  <span class="comment"># 打开数据库连接</span></span><br><span class="line">    cursor = db.cursor()  <span class="comment"># 使用 cursor() 方法创建一个游标对象 cursor</span></span><br><span class="line">    book = open_excel(excel_file)  <span class="comment"># 打开excel文件</span></span><br><span class="line">    sheets = book.sheet_names()  <span class="comment"># 获取所有sheet表名</span></span><br><span class="line">    <span class="keyword">for</span> sheet <span class="keyword">in</span> sheets:</span><br><span class="line">        sh = book.sheet_by_name(sheet)  <span class="comment"># 打开每一张表</span></span><br><span class="line">        row_num = sh.nrows</span><br><span class="line">        <span class="keyword">if</span> row_num != <span class="number">0</span>:</span><br><span class="line">            print(row_num - <span class="number">1</span>)</span><br><span class="line">        data_list = []  <span class="comment"># 定义列表用来存放数据</span></span><br><span class="line">        num = <span class="number">0</span>  <span class="comment"># 用来控制每次插入的数量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, row_num):  <span class="comment"># 第一行是标题名，对应表中的字段名所以应该从第二行开始，计算机以0开始计数，所以值是1</span></span><br><span class="line">            row_data = sh.row_values(i)  <span class="comment"># 按行获取excel的值</span></span><br><span class="line">            value = (</span><br><span class="line">                row_data[<span class="number">0</span>], row_data[<span class="number">1</span>], row_data[<span class="number">2</span>], row_data[<span class="number">3</span>], row_data[<span class="number">4</span>], row_data[<span class="number">5</span>], row_data[<span class="number">6</span>], row_data[<span class="number">7</span>],</span><br><span class="line">                row_data[<span class="number">8</span>])</span><br><span class="line">            sql = <span class="string">&quot;INSERT INTO &quot;</span> + str(table_name) + <span class="string">&quot;(brand,sub_model_name,v8_10,`year`,trans_code,oe_code,std_name,&quot;</span> \</span><br><span class="line">                                                     <span class="string">&quot;`level`,specification,creator,updator) VALUES(%s,%s,%s,%s,%s,&quot;</span> \</span><br><span class="line">                                                     <span class="string">&quot;%s,%s,%s,%s,\&quot;xing.liuxing1218\&quot;,\&quot;xing.liuxing1218\&quot;) &quot;</span></span><br><span class="line">            data_list.append(value)  <span class="comment"># 将数据暂存在列表</span></span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt;= <span class="number">1000</span>:  <span class="comment"># 每一千条数据执行一次插入</span></span><br><span class="line">                cursor.executemany(sql, data_list)  <span class="comment"># 执行sql语句</span></span><br><span class="line">                data_list.clear()  <span class="comment"># 清空list</span></span><br><span class="line">                print(<span class="string">&quot;worksheets: &quot;</span> + sheet + <span class="string">&quot; has been inserted 1000 data!&quot;</span>)</span><br><span class="line">                num = <span class="number">0</span>  <span class="comment"># 计数归零</span></span><br><span class="line">        cursor.executemany(sql, data_list)  <span class="comment"># 执行sql语句</span></span><br><span class="line">        data_list.clear()  <span class="comment"># 清空list</span></span><br><span class="line">        print(<span class="string">&quot;worksheets: &quot;</span> + sheet + <span class="string">&quot; has been inserted &quot;</span> + str(num) + <span class="string">&quot; data!&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> row_num != <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">&quot;Success: worksheets: &quot;</span> + sheet + <span class="string">&quot; has been inserted &quot;</span> + str(row_num - <span class="number">1</span>) + <span class="string">&quot; data!&quot;</span>)</span><br><span class="line">    db.commit()  <span class="comment"># 提交</span></span><br><span class="line">    cursor.close()  <span class="comment"># 关闭连接</span></span><br><span class="line">    db.close()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    store_to(<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;xxx.xls&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="python-复制文件"><a href="#python-复制文件" class="headerlink" title="python 复制文件"></a>python 复制文件</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">shutil.copy(src, dst)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 语法总结</title>
    <url>/2020/08/14/python%20%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="python-字符串处理"><a href="#python-字符串处理" class="headerlink" title="python 字符串处理"></a>python 字符串处理</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将变量转化成字符串类型</span></span><br><span class="line">str(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串全大写/全小写</span></span><br><span class="line">name = name.upper()</span><br><span class="line">name = name.lower()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类 C 语言中的字符串格式化语言，python 中用 % 处理变量转化</span></span><br><span class="line">ftp_name = <span class="string">&quot;%s_%s&quot;</span>%(cass_id, sec[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># strip()去掉字符串首位多余字符，为空时去掉多余空格</span></span><br><span class="line"><span class="comment"># split()将字符串通过参数中的字符，分割成若干字符串存在数组中</span></span><br><span class="line">plist = pic_advantage.strip().split(<span class="string">&quot;，&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># re模块处理正则表达式，以下为将 code 转化为[^a-zA-Z0-9]字符的函数</span></span><br><span class="line">pattern_code_trim = re.compile(<span class="string">&quot;[^a-zA-Z0-9]&quot;</span>)</span><br><span class="line">src_code_trim = pattern_code_trim.sub(<span class="string">&#x27;&#x27;</span>, code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python中没有自增</span></span><br><span class="line">i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure>

 <a id="more"></a>

<h1 id="python-字典的遍历"><a href="#python-字典的遍历" class="headerlink" title="python 字典的遍历"></a>python 字典的遍历</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># keys() 该方法会返回字典的所有的key</span></span><br><span class="line"><span class="comment"># 该方法会返回一个序列，序列中保存有字典的所有的键</span></span><br><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">print(d.keys())</span><br><span class="line"><span class="comment"># 通过遍历keys()来获取所有的键</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d.keys() :</span><br><span class="line">    print(k , d[k])</span><br><span class="line"></span><br><span class="line"><span class="comment"># values()</span></span><br><span class="line"><span class="comment"># 该方法会返回一个序列，序列中保存有字典的所有的值</span></span><br><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> d.values():</span><br><span class="line">    print(v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># items()</span></span><br><span class="line"><span class="comment"># 该方法会返回字典中所有的项</span></span><br><span class="line"><span class="comment"># 它会返回一个序列，序列中包含有双值子序列</span></span><br><span class="line"><span class="comment"># 双值分别是，字典中的key和value</span></span><br><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">print(d.items())</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</span><br><span class="line">    print(k, <span class="string">&#x27;=&#x27;</span>, v)</span><br></pre></td></tr></table></figure>


<h1 id="python解析json字符串"><a href="#python解析json字符串" class="headerlink" title="python解析json字符串"></a>python解析json字符串</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = json.loads(req.text)</span><br><span class="line">print(d[<span class="string">&#x27;element&#x27;</span>])</span><br><span class="line">print(d[<span class="string">&#x27;element_parent&#x27;</span>][<span class="string">&#x27;element_child&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> d.items():</span><br><span class="line">    print(item[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> item[<span class="number">1</span>][<span class="string">&#x27;element1&#x27;</span>] == <span class="string">&#x27;xx&#x27;</span>:</span><br><span class="line">        <span class="keyword">print</span> item[<span class="number">1</span>][<span class="string">&#x27;element2&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h1 id="python常用的去重方式"><a href="#python常用的去重方式" class="headerlink" title="python常用的去重方式"></a>python常用的去重方式</h1><h2 id="对列表去重"><a href="#对列表去重" class="headerlink" title="对列表去重"></a>对列表去重</h2><p>**1.**用循环查找的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">news_li = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> li:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> news_li:</span><br><span class="line">        news_li.append(i)</span><br><span class="line"><span class="keyword">print</span> (news_li)</span><br></pre></td></tr></table></figure>

<p>**2.**用集合的特性set()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li1 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">new_li1 = list(set(li1))</span><br></pre></td></tr></table></figure>

<p>**3.**使用itertools模块的grouby方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">li2 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">li2.sort() <span class="comment"># 排序</span></span><br><span class="line">it = itertools.groupby(li2)</span><br><span class="line"><span class="keyword">for</span> k, g <span class="keyword">in</span> it:</span><br><span class="line">    <span class="keyword">print</span> (k)</span><br></pre></td></tr></table></figure>

<p>**4.**运用while循环遍历的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quchong</span>(<span class="params">lb</span>):</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> lb:</span><br><span class="line">        <span class="keyword">while</span> lb.count(x)&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">del</span> lb[lb.index(x)]</span><br><span class="line">    <span class="keyword">return</span> lb</span><br><span class="line">li3 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">quchong(li3)</span><br></pre></td></tr></table></figure>

<p>**5.**使用keys()方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li4 = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">5</span>]</span><br><span class="line">formatli = list(&#123;&#125;.fromkeys(li4).keys())</span><br><span class="line"><span class="keyword">print</span> (formatli)</span><br></pre></td></tr></table></figure>

<h2 id="对数据框去重"><a href="#对数据框去重" class="headerlink" title="对数据框去重"></a>对数据框去重</h2><p>**1.**用unique()对单属性列去重</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;<span class="string">&#x27;id&#x27;</span>:[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;A&#x27;</span>],<span class="string">&#x27;age&#x27;</span>:[<span class="number">18</span>,<span class="number">20</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">14</span>,<span class="number">65</span>,<span class="number">14</span>,<span class="number">98</span>]&#125;</span><br><span class="line">data = pd.DataFrame(data)</span><br><span class="line">data.id.unique()</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.unique(data.id)</span><br></pre></td></tr></table></figure>

<p>**2.**用frame.drop_duplicates()对单属性列去重</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.drop_duplicates([<span class="string">&#x27;id&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>**3.**用frame.drop_duplicates()对多属性列去重</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.drop_duplicates([<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>**4.**用frame.duplicated()对多属性列去重</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isduplicated = data.duplicated([<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;age&#x27;</span>],keep=<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">data.loc[~isduplicated,:]</span><br></pre></td></tr></table></figure>

<h1 id="python-查找列表中重复元素以及重复元素的次数"><a href="#python-查找列表中重复元素以及重复元素的次数" class="headerlink" title="python 查找列表中重复元素以及重复元素的次数"></a>python 查找列表中重复元素以及重复元素的次数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">&quot;奔奔&quot;</span>, <span class="string">&quot;benben&quot;</span>, <span class="string">&quot;奔奔&quot;</span>]</span><br><span class="line">b = dict(Counter(a))</span><br><span class="line"><span class="comment"># 只展示重复元素</span></span><br><span class="line"><span class="keyword">print</span> ([key <span class="keyword">for</span> key,value <span class="keyword">in</span> b.items() <span class="keyword">if</span> value &gt; <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 展现重复元素和重复次数</span></span><br><span class="line"><span class="keyword">print</span> (&#123;key:value <span class="keyword">for</span> key,value <span class="keyword">in</span> b.items()<span class="keyword">if</span> value &gt; <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>方法一：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">myset = set(mylist)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> myset:</span><br><span class="line">    print(<span class="string">&quot;the %d has found %d&quot;</span> %(item,mylist.count(item)))</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">the 1 has found 1</span><br><span class="line">the 2 has found 4</span><br><span class="line">the 3 has found 3</span><br><span class="line">the 4 has found 4</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">Counter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Counter(&#123;2: 4, 4: 4, 3: 3, 1: 1&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>方法三：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">List=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">a = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> List:</span><br><span class="line">    <span class="keyword">if</span> List.count(i) &gt; <span class="number">1</span>:</span><br><span class="line">        a[i] = List.count(i)</span><br><span class="line"><span class="keyword">print</span> (a)</span><br></pre></td></tr></table></figure>

<h1 id="python-print-格式化输出"><a href="#python-print-格式化输出" class="headerlink" title="python print 格式化输出"></a>python print 格式化输出</h1><h2 id="动态指定长度的实现"><a href="#动态指定长度的实现" class="headerlink" title="动态指定长度的实现"></a>动态指定长度的实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print %s固定长度格式输出：</span></span><br><span class="line">print(<span class="string">&quot;%10s, %20s&quot;</span> % (A, B))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果长度不定，以变量len代替：</span></span><br><span class="line">print(<span class="string">&quot;%*s&quot;</span> % (len, A))</span><br></pre></td></tr></table></figure>

<h2 id="以指定宽度格式化输出（format）"><a href="#以指定宽度格式化输出（format）" class="headerlink" title="以指定宽度格式化输出（format）"></a>以指定宽度格式化输出（format）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mat = <span class="string">&quot;&#123;:20&#125;\t&#123;:28&#125;\t&#123;:32&#125;&quot;</span></span><br><span class="line">print(mat.format(<span class="string">&quot;占4个长度&quot;</span>,<span class="string">&quot;占8个长度&quot;</span>, <span class="string">&quot;占12长度&quot;</span>))</span><br><span class="line"><span class="comment"># 如果需要居中输出在宽度前面加一个^</span></span><br><span class="line">mat = <span class="string">&quot;&#123;:^20&#125;\t&#123;:^28&#125;\t&#123;:^32&#125;&quot;</span></span><br><span class="line">print(mat.format(<span class="string">&quot;占4个长度&quot;</span>,<span class="string">&quot;占8个长度&quot;</span>, <span class="string">&quot;占12长度&quot;</span>))</span><br></pre></td></tr></table></figure>

<h1 id="python-Set-集合-相关函数操作"><a href="#python-Set-集合-相关函数操作" class="headerlink" title="python Set(集合)相关函数操作"></a>python Set(集合)相关函数操作</h1><p><strong>python</strong>的<code>set</code>和其他语言类似, 是一个无序不重复元素集。基本功能包括关系测试和消除重复元素。集合对象还支持<code>union(联合)</code>, <code>intersection(交)</code>, <code>difference(差)</code>和<code>sysmmetric difference(对称差集)</code>等数学运算。</p>
<p><code>set</code> 支持 <code>x in set</code>, <code>len(set)</code>, 和 <code>for x in set</code>。作为一个无序的集合，<code>set</code>不记录元素位置或者插入点。因此，<code>set</code>不支持 <code>indexing</code>,<code> slicing</code>, 或其它类序列<code>sequence-like</code>的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = set()</span><br><span class="line"></span><br><span class="line">len(s) </span><br><span class="line"><span class="comment"># set 的长度</span></span><br><span class="line"></span><br><span class="line">x <span class="keyword">in</span> s </span><br><span class="line"><span class="comment"># 测试 x 是否是 s 的成员</span></span><br><span class="line"></span><br><span class="line">x <span class="keyword">not</span> <span class="keyword">in</span> s </span><br><span class="line"><span class="comment"># 测试 x 是否不是 s 的成员</span></span><br><span class="line"></span><br><span class="line">s.issubset(t) s &lt;= t </span><br><span class="line"><span class="comment"># 测试是否 s 中的每一个元素都在 t 中</span></span><br><span class="line"></span><br><span class="line">s.issuperset(t) s &gt;= t </span><br><span class="line"><span class="comment"># 测试是否 t 中的每一个元素都在 s 中</span></span><br><span class="line"></span><br><span class="line">s.union(t) s | t </span><br><span class="line"><span class="comment"># 返回一个新的 set 包含 s 和 t 中的每一个元素</span></span><br><span class="line"></span><br><span class="line">s.intersection(t) s &amp; t </span><br><span class="line"><span class="comment"># 返回一个新的 set 包含 s 和 t 中的公共元素</span></span><br><span class="line"></span><br><span class="line">s.difference(t) s - t </span><br><span class="line"><span class="comment"># 返回一个新的 set 包含 s 中有但是 t 中没有的元素</span></span><br><span class="line"></span><br><span class="line">s.symmetric_difference(t) s ^ t </span><br><span class="line"><span class="comment"># 返回一个新的 set 包含 s 和 t 中不重复的元素</span></span><br><span class="line"></span><br><span class="line">s.copy() </span><br><span class="line"><span class="comment"># 返回 set “s”的一个浅复制</span></span><br><span class="line"></span><br><span class="line">hash(s)</span><br><span class="line"><span class="comment"># 返回 s 的 hash 值</span></span><br><span class="line"></span><br><span class="line">s.update(t)</span><br><span class="line">s |= t</span><br><span class="line"><span class="comment"># 返回增加了 set “t”中元素后的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.intersection_update(t)</span><br><span class="line">s &amp;= t</span><br><span class="line"><span class="comment"># 返回只保留含有 set “t”中元素的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.difference_update(t)</span><br><span class="line">s -= t</span><br><span class="line"><span class="comment"># 返回删除了 set “t”中含有的元素后的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.symmetric_difference_update(t)</span><br><span class="line">s ^= t</span><br><span class="line"><span class="comment"># 返回含有 set “t”或者 set “s”中有而不是两者都有的元素的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.add(x)</span><br><span class="line"><span class="comment"># 向 set “s”中增加元素 x</span></span><br><span class="line"></span><br><span class="line">s.remove(x)</span><br><span class="line"><span class="comment"># 从 set “s”中删除元素 x, 如果不存在则引发 KeyError</span></span><br><span class="line"></span><br><span class="line">s.discard(x)</span><br><span class="line"><span class="comment"># 如果在 set “s”中存在元素 x, 则删除</span></span><br><span class="line"></span><br><span class="line">s.pop()</span><br><span class="line"><span class="comment"># 删除并且返回 set “s”中的一个不确定的元素, 如果为空则引发 KeyError</span></span><br><span class="line"></span><br><span class="line">s.clear()</span><br><span class="line"><span class="comment"># 删除 set “s”中的所有元素</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 的配置与基础命令</title>
    <url>/2020/08/06/Nginx%20%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="NGINX-的配置与基础命令"><a href="#NGINX-的配置与基础命令" class="headerlink" title="NGINX 的配置与基础命令"></a>NGINX 的配置与基础命令</h1><p><strong>nginx 配置</strong></p>
<p><strong>查看 nginx 配置文件</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /etc/nginx/nginx.conf</span><br><span class="line">cat /etc/nginx/conf.d/xxxxxxxx.conf</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"> &lt;!--more--&gt;</span><br><span class="line"> </span><br><span class="line">可以看到 `stdname` 对应的监听端口设置 nginx 监听 18026 并转发至 stdnameSvr 的 监听端口 19026。</span><br><span class="line"></span><br><span class="line">```conf</span><br><span class="line">server &#123;</span><br><span class="line">        listen       18026;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location /stdname/  &#123;</span><br><span class="line">                fastcgi_pass   127.0.0.1:19026;</span><br><span class="line">                fastcgi_index index.cgi;</span><br><span class="line">                <span class="comment">#fastcgi_param SCRIPT_FILENAME fcgi$fastcgi_script_name;</span></span><br><span class="line">                include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<p><strong>验证 nginx 配置文件是否正确</strong></p>
<p>进入 nginx 安装目录 sbin 下，输入命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./nginx -t</span><br></pre></td></tr></table></figure>

<p>看到如下显示 </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nginx: the configuration file /.../nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /.../nginx.conf <span class="built_in">test</span> is successful</span><br></pre></td></tr></table></figure>

<p>说明配置文件正确！</p>
<p><strong>运行 nginx</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/path_of_nginx/nginx -c /path_of_nginx.conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p><code>-c</code>：指定 nginx 运行时使用的 conf 文件路径<br><code>-t</code>：加上<code>-t</code>可以测试 nginx 配置是否正确</p>
<p><strong>停止 nginx</strong></p>
<p>查看进程号然后杀死进程</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br><span class="line"><span class="built_in">kill</span> -QUIT &lt;pid_of_nginx&gt;   //从容停止</span><br><span class="line"><span class="built_in">kill</span> -TERM &lt;pid_of_nginx&gt;   //快速停止</span><br><span class="line"><span class="built_in">kill</span> -INT &lt;pid_of_nginx&gt;    //快速停止</span><br><span class="line"><span class="built_in">kill</span> -9 nginx               //强制停止</span><br></pre></td></tr></table></figure>

<p><strong>重启 nginx</strong></p>
<p><strong>方法一：</strong><br>找到 nginx 可执行文件路径，然后输入命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

</br>

<p><strong>方法二：</strong><br>查找当前 nginx 进程号，然后输入命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;pid_of_nginx&gt;</span><br></pre></td></tr></table></figure>

<p>实现重启 nginx 服务。</p>
]]></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下 MySQL 的 ODBC 配置</title>
    <url>/2020/07/20/Linux%20%E4%B8%8B%20MySQL%20%E7%9A%84%20ODBC%20%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>在<strong>安装</strong>配置之前，需要先大概了解一下 MyODBC 的架构，MyODBC 体系结构建立在 5 个组件上，如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggwm30f77xj30a20b3aah.jpg"></p>
<!---more--->

<p><strong>Driver Manager</strong><br>负责管理应用程序和驱动程序间的通信，主要功能包括：解析 DSN (数据源名称，ODBC 的数据源名称在 odbc.ini 文件中配置)，加载和卸载驱动程序，处理 ODBC 调用，将其传递给驱动程序。</p>
<p><strong>ODBC.INI</strong><br>odbc.ini 是 ODBC 配置文件，记录了连接到服务器所需的驱动信息和数据库信息xxxxxx。Driver Manager 将使用它来确定加载哪个驱动程序（使用数据源名 DSN ）。驱动程序将根据指定的DSN来读取连接参数。</p>
<p><strong>Connector/ODBC(MyODBC驱动程序)</strong><br>实现 ODBC API 所提供的功能，它负责处理 ODBC 函数调用，将 SQL 请求提交给 MySQL 服务器，并将结果返回给应用程序。</p>
<p>在 Linux 下配置 mysql ODBC 需要有以下步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 安装 Driver Manager，本案例使用 unixODBC 来作为 Driver Manager。</span><br><span class="line">2. 安装 MySQL 驱动程序，本案例使用 Connector&#x2F;ODBC。</span><br><span class="line">3. 配置 ODBC.INI</span><br></pre></td></tr></table></figure>

<h2 id="第一步：下载安装包"><a href="#第一步：下载安装包" class="headerlink" title="第一步：下载安装包"></a>第一步：下载安装包</h2><p>需要下载两个安装包 <code>unixODBC 2.3.0</code> 和 <code>mysql Connector/ODBC 3.51</code><br>unixODBC 源码包：<code>ftp://ftp.unixodbc.org/pub/unixODBC/unixODBC-2.3.0.tar.gz</code><br>mysql Connector/ODBC 源码包：<code>http://dev.mysql.com/downloads/connector/odbc/3.51.html%23downloads</code><br>选择</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">版本：5.1.11</span><br><span class="line">平台：Oracle&amp;Red Hat Linux6</span><br><span class="line">下载：mysql-connector-odbc-5.1.11-linux-el6-x86-64bit.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="第二步：安装-unixODBC"><a href="#第二步：安装-unixODBC" class="headerlink" title="第二步：安装 unixODBC"></a>第二步：安装 unixODBC</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf unixODBC-2.3.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> unixODBC-2.3.4</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/unixODBC-2.3.4 --includedir=/usr/include --libdir=/usr/<span class="built_in">local</span>/lib -bindir=/usr/bin --sysconfdir=/usr/<span class="built_in">local</span>/etc</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>安装完成后,可以在/usr/bin目录下有下面的文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root      75312 Nov 1 16:22 odbcinst</span><br><span class="line">-rwxr-xr-x 1 root root      10922 Nov 1 16:22 odbc_config</span><br><span class="line">-rwxr-xr-x 1 root root      37650 Nov 1 16:22 iusql</span><br><span class="line">-rwxr-xr-x 1 root root      44400 Nov 1 16:22 isql</span><br><span class="line">-rwxr-xr-x 1 root root      95903 Nov 1 16:22 dltest</span><br></pre></td></tr></table></figure>

<p>在/usr/local/lib目录下面有这些文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root 422955 Nov 1 16:22 libodbcinst.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     20 Nov 1 16:22 libodbcinst.so.1 -&gt; libodbcinst.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     20 Nov 1 16:22 libodbcinst.so -&gt; libodbcinst.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    981 Nov 1 16:22 libodbcinst.la</span><br><span class="line">-rwxr-xr-x 1 root root 169157 Nov 1 16:22 libodbc.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     16 Nov 1 16:22 libodbc.so.1 -&gt; libodbc.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     16 Nov 1 16:22 libodbc.so -&gt; libodbc.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    957 Nov 1 16:22 libodbc.la</span><br><span class="line">-rwxr-xr-x 1 root root 489405 Nov 1 16:22 libodbccr.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     18 Nov 1 16:22 libodbccr.so.1 -&gt; libodbccr.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     18 Nov 1 16:22 libodbccr.so -&gt; libodbccr.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    969 Nov 1 16:22 libodbccr.la</span><br></pre></td></tr></table></figure>

<h2 id="第三步：安装-mysql-Connector-ODBC"><a href="#第三步：安装-mysql-Connector-ODBC" class="headerlink" title="第三步：安装 mysql Connector/ODBC"></a>第三步：安装 mysql Connector/ODBC</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf mysql-connector-odbc-5.1.11-linux-el6-x86-64bit.tar.gz</span><br><span class="line"><span class="built_in">cd</span> mysql-connector-odbc-5.1.11-linux-el6-x86-64bit/lib</span><br><span class="line">cp libmyodbc5.so /usr/<span class="built_in">local</span>/lib</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> bin</span><br></pre></td></tr></table></figure>

<p><strong>注册驱动</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./myodbc-installer -d -a -n <span class="string">&quot;MySQL ODBC 5.1 Driver&quot;</span> -t <span class="string">&quot;DRIVER=/usr/local/lib/libmyodbc5.so;SETUP=/usr/local/lib/libmyodbc5.so&quot;</span></span><br><span class="line"></span><br><span class="line">//odbc 5.3及以上是libmyodbc5a.so和libmyodbc5w.so。其中c5a是Ansi版，c5w是Unicode版</span><br></pre></td></tr></table></figure>

<p>假如注册的时候报错找不到libodbc.so.2,但是之前确实装成功了unixodbc,可能是因为系统找不到/usr/local/lib库目录，需要添加系统搜索库目录路径：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line">//将/usr/<span class="built_in">local</span>/lib直接添加在配置文件里</span><br><span class="line"></span><br><span class="line">ldconfig</span><br><span class="line"></span><br><span class="line">//重新缓存配置文件(为了加快程序执行时对共享库的定位速度，避免使用搜索路径查找共享库的低效率，所以是直接读取库列表文件/etc/ld.so.cache缓存文件并从中进行搜索的)</span><br></pre></td></tr></table></figure>

<h2 id="第四步：配置-ODBC-INI"><a href="#第四步：配置-ODBC-INI" class="headerlink" title="第四步：配置 ODBC.INI"></a>第四步：配置 ODBC.INI</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">odbcinst -j</span><br><span class="line"></span><br><span class="line">unixODBC 2.3.1</span><br><span class="line">DRIVERS............: /etc/odbcinst.ini</span><br><span class="line">SYSTEM DATA SOURCES: /etc/odbc.ini</span><br><span class="line">FILE DATA SOURCES..: /etc/ODBCDataSources</span><br><span class="line">USER DATA SOURCES..: /root/.odbc.ini</span><br><span class="line">SQLULEN Size.......: 8</span><br><span class="line">SQLLEN Size........: 8</span><br><span class="line">SQLSETPOSIROW Size.: 8</span><br></pre></td></tr></table></figure>

<p>编辑文件<code>/etc/odbc.ini</code>，把下面的内容加上去。不同版本<code>mysql</code>驱动的配置方法，有细微差异。此处使用的版本是<code>mysql Connector 3.51</code>。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqlDSN]</span></span><br><span class="line"><span class="attr">Driver</span>      = /usr/local/lib/libmyodbc5.so</span><br><span class="line"><span class="attr">Description</span> = MyODBC <span class="number">5</span> Driver DSN</span><br><span class="line"><span class="attr">SERVER</span>      = <span class="number">172.31</span>.<span class="number">108.133</span></span><br><span class="line"><span class="attr">PORT</span>        = <span class="number">3306</span></span><br><span class="line"><span class="attr">USER</span>        = root</span><br><span class="line"><span class="attr">Password</span>    = <span class="number">123456</span></span><br><span class="line"><span class="attr">Database</span>    = PM</span><br><span class="line"><span class="attr">OPTION</span>      = <span class="number">3</span></span><br><span class="line"><span class="attr">charset</span>     = UTF8</span><br></pre></td></tr></table></figure>

<h2 id="第五步：设置环境变量"><a href="#第五步：设置环境变量" class="headerlink" title="第五步：设置环境变量"></a>第五步：设置环境变量</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> DBCINI=/usr/<span class="built_in">local</span>/etc/odbc.ini</span><br><span class="line"><span class="built_in">export</span> DBCSYSINI=/usr/<span class="built_in">local</span>/etc</span><br></pre></td></tr></table></figure>

<h2 id="第六步：重启电脑"><a href="#第六步：重启电脑" class="headerlink" title="第六步：重启电脑"></a>第六步：重启电脑</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h2 id="第七步：测试ODBC配置是否成功"><a href="#第七步：测试ODBC配置是否成功" class="headerlink" title="第七步：测试ODBC配置是否成功"></a>第七步：测试ODBC配置是否成功</h2><p>isql 是 unixODBC 带的一个 ODBC 客户端访问工具，使用<code>isql +数据源名</code>来访问目标数据库。如果 ODBC 配置正确，会显示下面的界面。在<code>SQL&gt;</code>提示符下输入 SQL 语句查询数据库。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">isql mysqlDSN</span><br><span class="line"></span><br><span class="line">+---------------------------------------+</span><br><span class="line">| Connected!                           |</span><br><span class="line">|                                      |</span><br><span class="line">| sql-statement                        |</span><br><span class="line">| <span class="built_in">help</span> [tablename]                     |</span><br><span class="line">| quit                                 |</span><br><span class="line">|                                      |</span><br><span class="line">+---------------------------------------+</span><br></pre></td></tr></table></figure>

<h2 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>在第三步安装 mysql connector/ODBC 中的注册驱动中，我总是会出现<code>./myodbc-installer: error while loading shared libraries: libodbc.so.2: cannot open shared object file: No such file or directory.</code>这种错误，后来发现错误有两点：</p>
<ol>
<li>我下载的是 mysql-connector-5.3.6 ，可能版本比较高，而我初次下载用的是unixODBC-2.3.0，版本较低，里面没有 libodbc.so.2 这个库文件（可以用<code>find / -name libodbc.so.2</code>来查）。后来下载了一个 unixODBC-2.3.4 就好了。</li>
<li>改了版本之后，我发现还是有这个错误，在网上查了下，说是程序查找默认路径为 /lib 和 /usr/lib，而我的 libmyodbc5w.so 和 libmmyodbc5a.so 都在 /usr/local/lib 中，所以查不到，所以需要设置一下共享库路径，以下我贴一下网上查的内容：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /etc/ld.so.conf</span><br><span class="line">include ld.so.conf.d/*.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/usr/local/lib&quot;</span> &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>

<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>如果共享库文件安装到了其它”非 /lib 或 /usr/lib “ 目录下，但是又不想在 /etc/ld.so.conf 中加路径(或者是没有权限加路径)。那可以 export 一个全局变量 LD_LIBRARY_PATH ，然后运行程序的时候就会去这个目录中找共享库。</p>
<p>LD_LIBRARY_PATH 的意思是告诉 loader 在哪些目录中可以找到共享库。</p>
<p>可以设置多个搜索目录，这些目录之间用冒号分隔开。</p>
<p>比如：</p>
<p>安装了一个 mysql 到 /usr/local/mysql 目录下，其中有一大堆库文件在 /usr/local/mysql/lib 下面，则可以在 .bashrc 或 .bash_profile 或 shell 里加入以下语句即可：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/mysql/lib:<span class="variable">$LD_LIBRARY_PATH</span>    </span><br></pre></td></tr></table></figure>

<p>一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>如果程序需要的库文件比系统目前存在的村文件版本低，可以做一个链接<br>比如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libncurses.so.4: cannot open shared</span><br><span class="line">object file: No such file or directory</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls /usr/lib/libncu*</span><br><span class="line">/usr/lib/libncurses.a   /usr/lib/libncurses.so.5</span><br><span class="line">/usr/lib/libncurses.so  /usr/lib/libncurses.so.5.3</span><br></pre></td></tr></table></figure>

<p>可见虽然没有 libncurses.so.4，但有 libncurses.so.5，是可以向下兼容的<br>建一个链接就好了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ln -s  /usr/lib/libncurses.so.5.3  /usr/lib/libncurses.so.4</span><br></pre></td></tr></table></figure>


<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>isql 连接数据库失败，重新注册驱动：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/usr/bin/myodbc-installer  -d -a -n <span class="string">&quot;MySQL_UNICODE&quot;</span>  -t <span class="string">&quot;DRIVER=/usr/lib64/libmyodbc8w.so;SETUP=/usr/lib64/libmyodbc8w.so&quot;</span></span><br><span class="line">/usr/bin/myodbc-installer  -d -a -n <span class="string">&quot;MySQL_ANSI&quot;</span>  -t <span class="string">&quot;DRIVER=/usr/lib64/libmyodbc8a.so;SETUP=/usr/lib64/libmyodbc8a.so&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用 rpm 命令查看 rpm 包的内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -qpl xxx.rpm</span><br></pre></td></tr></table></figure>

<p>可以看到<code>mysql-connector-odbc-8.0.20-1.el7.x86_64.rpm</code>的包内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">warning: mysql-connector-odbc-8.0.20-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">/usr/bin/myodbc-installer</span><br><span class="line">/usr/lib64/libmyodbc8a.so</span><br><span class="line">/usr/lib64/libmyodbc8w.so</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/ChangeLog</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/INFO_BIN</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/INFO_SRC</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/LICENSE.txt</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/README.txt</span><br></pre></td></tr></table></figure>

<p>可以知道 rpm 包 安装的时候各个基础件的安装位置。</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 用法总结</title>
    <url>/2020/07/20/MySQL%20%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div align='center' ><font size='70'>MySQL 用法总结</font></div>

<hr>
<p>[TOC]</p>
<hr>
<h1 id="mysql清空表数据后如何让自增ID仍从1开始"><a href="#mysql清空表数据后如何让自增ID仍从1开始" class="headerlink" title="mysql清空表数据后如何让自增ID仍从1开始?"></a>mysql清空表数据后如何让自增ID仍从1开始?</h1><blockquote>
<p>也就是说如何重排 auto_increment</p>
</blockquote>
<p><strong>两种方法：</strong></p>
<p><strong>1、</strong>清空表时使用<code>truncate</code>命令，而不用<code>delete</code>命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name ;</span><br></pre></td></tr></table></figure>
<p>使用<code>truncate</code>命令的好处：</p>
<blockquote>
<p>1）、速度快<br>2）、可以对自增 ID 进行重排，使自增 ID 仍从1开始计算</p>
</blockquote>
<p><strong>2、</strong>清空表数据后，使用alter修改表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name AUTO_INCREMENT = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

 <a id="more"></a>

<h1 id="mysql-增删索引"><a href="#mysql-增删索引" class="headerlink" title="mysql 增删索引"></a>mysql 增删索引</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建表语句中建立索引</span></span><br><span class="line">INDEX `idx_interface_name` ( `interface_name` ) USING BTREE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改表结构增加索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`oe2modelcatalog`</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span>   idx_md5 ( <span class="string">`md5`</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改表结构增加索引</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="mysql-插入数据"><a href="#mysql-插入数据" class="headerlink" title="mysql 插入数据"></a>mysql 插入数据</h1><p>如果对应元素有默认值，则可以，在 INSERT 时为空，不然会报错。</p>
<h1 id="mysql-时间戳设置"><a href="#mysql-时间戳设置" class="headerlink" title="mysql 时间戳设置"></a>mysql 时间戳设置</h1><p>DEFAULT CURRENT_TIMESTAMP 表示当插入数据的时候，该字段默认值为当前时间<br>ON UPDATE CURRENT_TIMESTAMP 在数据库数据有更新的时候UPDATE_TIME的时间会自动更新</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 知识储备</title>
    <url>/2020/07/20/MySQL%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/</url>
    <content><![CDATA[<div align='center' ><font size='70'>MySQL知识储备</font></div>

<hr>
<p>[TOC]</p>
<hr>
<h1 id="SQL-SELECT-DISTINCT-语句"><a href="#SQL-SELECT-DISTINCT-语句" class="headerlink" title="SQL SELECT DISTINCT 语句"></a>SQL SELECT DISTINCT 语句</h1><p>在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。DISTINCT 关键词用于返回唯一不同的值。</p>
<p><strong>SQL SELECT DISTINCT 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>

<!---more--->

<h1 id="SQL-UPDATE-语句"><a href="#SQL-UPDATE-语句" class="headerlink" title="SQL UPDATE 语句"></a>SQL UPDATE 语句</h1><p>UPDATE 语句用于更新表中已存在的记录。</p>
<p><strong>SQL UPDATE 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1=value1,column2=value2,...</span><br><span class="line"><span class="keyword">WHERE</span> some_column=some_value;</span><br></pre></td></tr></table></figure>

<p><strong>请注意</strong> : SQL UPDATE 语句中的 WHERE 子句！WHERE 子句规定哪条记录或者哪些记录需要更新。如果您省略了 WHERE 子句，所有的记录都将被更新！</p>
<h1 id="SQL-DELETE-语句"><a href="#SQL-DELETE-语句" class="headerlink" title="SQL DELETE 语句"></a>SQL DELETE 语句</h1><p>DELETE 语句用于删除表中的行(记录)。</p>
<p><strong>SQL DELETE 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> some_column=some_value;</span><br></pre></td></tr></table></figure>

<p><strong>请注意</strong> : SQL DELETE 语句中的 WHERE 子句！WHERE 子句规定哪条记录或者哪些记录需要删除。如果您省略了 WHERE 子句，所有的记录都将被删除！</p>
<h1 id="SQL-REGEXP-语句"><a href="#SQL-REGEXP-语句" class="headerlink" title="SQL REGEXP 语句"></a>SQL REGEXP 语句</h1><p>作为一个更为复杂的示例，正则表达式 <code>B[an]*s</code> 匹配下述字符串中的任何一个：<code>Bananas，Baaaaas，Bs</code>，以及以 B 开始，以 s 结束、并在其中包含任意数目 a 或 n 字符的任何其他字符串。</p>
<p>以下是可用于随 REGEXP 操作符的表的模式。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghb5zvmhrhj30ff08r754.jpg"></p>
<p>应用示例，查找用户表中 Email 格式错误的用户记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">users</span></span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">NOT</span> REGEXP <span class="string">&#x27;^[A-Z0-9._%-]+@[A-Z0-9.-]+.[A-Z]&#123;2,4&#125;$&#x27;</span></span><br></pre></td></tr></table></figure>

<p>MySQL 数据库中正则表达式的语法，主要包括各种符号的含义。</p>
<p><strong>^ 字符</strong></p>
<p>匹配字符串的开始位置，如 <code>^a</code> 表示以字母 a 开头的字符串。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &#x27;xxxyyy&#x27; REGEXP &#x27;^xx&#x27;;</span><br><span class="line"> </span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| &#x27;xxxyyy&#x27; REGEXP &#x27;^xx&#x27; |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">|           1 |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>查询 xxxyyy 字符串中是否以 xx 开头，结果值为 1，表示值为 true，满足条件。</p>
<p><strong>$ 字符</strong></p>
<p>匹配字符串的结束位置，如 <code>X$</code> 表示以字母 X 结尾的字符串。</p>
<p><strong>. 字符</strong></p>
<p>这个字符就是英文下的点，它匹配任何一个字符，包括回车、换行等。</p>
<p><strong>* 字符</strong></p>
<p>星号匹配 0 个或多个字符，在它之前必须有内容。如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &#x27;xxxyyy&#x27; REGEXP &#x27;x*&#x27;;</span><br></pre></td></tr></table></figure>

<p>这个 SQL 语句，正则匹配为 true。</p>
<p><strong>+ 字符</strong></p>
<p>加号匹配 1 个或多个字符，在它之前也必须有内容。加号跟星号的用法类似，只是星号允许出现 0 次，加号则必须至少出现一次。</p>
<p><strong>? 字符</strong></p>
<p>问号匹配 0 次或 1 次。</p>
<p><strong>实例:</strong><br>查询找到所有的名字以 st 开头：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;^st&#x27;;</span><br><span class="line">//查询找到所有的名字以 ok 结尾：</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;ok$&#x27;;</span><br><span class="line">//查询找到所有的名字包函 mar 的字符串：</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;mar&#x27;;</span><br><span class="line">//查询找到所有名称以元音开始和 ok 结束的：</span><br><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;^[aeiou]|ok$&#x27;;</span><br></pre></td></tr></table></figure>

<p>一个正则表达式中的可以使用以下保留字。</p>
<p><strong>^</strong><br>所匹配的字符串以后面的字符串开头：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;fonfo&quot; REGEXP &quot;^fo$&quot;; -&gt; 0（表示不匹配） </span><br><span class="line">mysql&gt; SELECT &quot;fofo&quot; REGEXP &quot;^fo&quot;; -&gt; 1（表示匹配）</span><br></pre></td></tr></table></figure>

<p><strong>$</strong><br>所匹配的字符串以前面的字符串结尾：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;fono&quot; REGEXP &quot;^fono$&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;fono&quot; REGEXP &quot;^fo$&quot;; -&gt; 0（表示不匹配） </span><br></pre></td></tr></table></figure>

<p><strong>.</strong><br>匹配任何字符（包括新行）：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;fofo&quot; REGEXP &quot;^f.*&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;fonfo&quot; REGEXP &quot;^f.*&quot;; -&gt; 1（表示匹配）</span><br></pre></td></tr></table></figure>

<p>*<em>a**</em><br>匹配任意多个 a（包括空串)：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;Ban&quot; REGEXP &quot;^Ba*n&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;Baaan&quot; REGEXP &quot;^Ba*n&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;Bn&quot; REGEXP &quot;^Ba*n&quot;; -&gt; 1（表示匹配）</span><br></pre></td></tr></table></figure>

<p><strong>a+</strong><br>匹配任意多个 a（不包括空串)：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;Ban&quot; REGEXP &quot;^Ba+n&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;Bn&quot; REGEXP &quot;^Ba+n&quot;; -&gt; 0（表示不匹配）</span><br></pre></td></tr></table></figure>

<p><strong>a?</strong><br>匹配一个或零个 a：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;Bn&quot; REGEXP &quot;^Ba?n&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;Ban&quot; REGEXP &quot;^Ba?n&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;Baan&quot; REGEXP &quot;^Ba?n&quot;; -&gt; 0（表示不匹配）</span><br></pre></td></tr></table></figure>

<p><strong>de|abc</strong><br>匹配 de 或 abc：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;pi&quot; REGEXP &quot;pi|apa&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;axe&quot; REGEXP &quot;pi|apa&quot;; -&gt; 0（表示不匹配） </span><br><span class="line">mysql&gt; SELECT &quot;apa&quot; REGEXP &quot;pi|apa&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;apa&quot; REGEXP &quot;^(pi|apa)$&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;pi&quot; REGEXP &quot;^(pi|apa)$&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;pix&quot; REGEXP &quot;^(pi|apa)$&quot;; -&gt; 0（表示不匹配）</span><br></pre></td></tr></table></figure>

<p>*<em>(abc)**</em><br>匹配任意多个abc（包括空串)：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;pi&quot; REGEXP &quot;^(pi)*$&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;pip&quot; REGEXP &quot;^(pi)*$&quot;; -&gt; 0（表示不匹配） </span><br><span class="line">mysql&gt; SELECT &quot;pipi&quot; REGEXP &quot;^(pi)*$&quot;; -&gt; 1（表示匹配）</span><br></pre></td></tr></table></figure>

<p><strong>{1}</strong><br><strong>{2,3}</strong><br>这是一个更全面的方法，它可以实现前面好几种保留字的功能。<br>*<em>a**</em> 可以写成 <code>a&#123;0,&#125;</code>。<br><strong>a+</strong> 可以写成 <code>a&#123;1,&#125;</code>。<br><strong>a?</strong> 可以写成 <code>a&#123;0,1&#125;</code>。</p>
<p>在 {} 内只有一个整型参数 i，表示字符只能出现 i 次；在 {} 内有一个整型参数 i，后面跟一个 ,，表示字符可以出现 i 次或 i 次以上；在 {} 内只有一个整型参数 i，后面跟一个 ,，再跟一个整型参数 j, 表示字符只能出现 i 次以上，j 次以下（包括 i 次和 j 次）。其中的整型参数必须大于等于 0，小于等于 RE_DUP_MAX（默认是 255）。 如果有两个参数，第二个必须大于等于第一个。</p>
<p><strong>[a-dX]</strong> 匹配 <code>“a”、“b”、“c”、“d”</code> 或 <code>“X”</code>。<br>**[^a-dX]** 匹配除 <code>“a”、“b”、“c”、“d”、“X”</code> 以外的任何字符。</p>
<p><strong>“[”、“]”</strong>必须成对使用：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &quot;aXbc&quot; REGEXP &quot;[a-dXYZ]&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;aXbc&quot; REGEXP &quot;^[a-dXYZ]$&quot;; -&gt; 0（表示不匹配） </span><br><span class="line">mysql&gt; SELECT &quot;aXbc&quot; REGEXP &quot;^[a-dXYZ]+$&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;aXbc&quot; REGEXP &quot;^[^a-dXYZ]+$&quot;; -&gt; 0（表示不匹配） </span><br><span class="line">mysql&gt; SELECT &quot;gheis&quot; REGEXP &quot;^[^a-dXYZ]+$&quot;; -&gt; 1（表示匹配） </span><br><span class="line">mysql&gt; SELECT &quot;gheisa&quot; REGEXP &quot;^[^a-dXYZ]+$&quot;; -&gt; 0（表示不匹配）</span><br></pre></td></tr></table></figure>

<h1 id="SQL-IN-操作符"><a href="#SQL-IN-操作符" class="headerlink" title="SQL IN 操作符"></a>SQL IN 操作符</h1><p>IN 操作符允许您在 WHERE 子句中规定多个值。</p>
<p><strong>SQL IN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (value1,value2,...);</span><br></pre></td></tr></table></figure>

<h1 id="SQL-BETWEEN-操作符"><a href="#SQL-BETWEEN-操作符" class="headerlink" title="SQL BETWEEN 操作符"></a>SQL BETWEEN 操作符</h1><p>BETWEEN 操作符选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。</p>
<p><strong>SQL BETWEEN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">BETWEEN</span> value1 <span class="keyword">AND</span> value2;</span><br></pre></td></tr></table></figure>

<h1 id="SQL-别名"><a href="#SQL-别名" class="headerlink" title="SQL 别名"></a>SQL 别名</h1><p>通过使用 SQL，可以为表名称或列名称指定别名。基本上，创建别名是为了让列名称的可读性更强。</p>
<p><strong>列的 SQL 别名语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<p><strong>表的 SQL 别名语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name <span class="keyword">AS</span> alias_name;</span><br></pre></td></tr></table></figure>

<h1 id="SQL-JOIN"><a href="#SQL-JOIN" class="headerlink" title="SQL JOIN"></a>SQL JOIN</h1><p>SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。</p>
<p><code>INNER JOIN</code>：如果表中有至少一个匹配，则返回行<br><code>LEFT JOIN</code>：即使右表中没有匹配，也从左表返回所有的行<br><code>RIGHT JOIN</code>：即使左表中没有匹配，也从右表返回所有的行<br><code>FULL JOIN</code>：只要其中一个表中存在匹配，则返回行</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghb9w54nksj30qu0l40wf.jpg"></p>
<h2 id="SQL-INNER-JOIN-关键字"><a href="#SQL-INNER-JOIN-关键字" class="headerlink" title="SQL INNER JOIN 关键字"></a>SQL INNER JOIN 关键字</h2><p>INNER JOIN 关键字在表中存在至少一个匹配时返回行。</p>
<p><strong>SQL INNER JOIN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghba0un8qgj305k041dfs.jpg"></p>
<p><strong>注释</strong>：INNER JOIN 与 JOIN 是相同的。</p>
<h2 id="SQL-LEFT-JOIN-关键字"><a href="#SQL-LEFT-JOIN-关键字" class="headerlink" title="SQL LEFT JOIN 关键字"></a>SQL LEFT JOIN 关键字</h2><p>LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。</p>
<p><strong>SQL LEFT JOIN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghbafmyirgj305k041aa0.jpg"></p>
<p><strong>注释</strong>：在某些数据库中，LEFT JOIN 称为 LEFT OUTER JOIN。<br><strong>注释</strong>：LEFT JOIN 关键字从左表（Websites）返回所有的行，即使右表（access_log）中没有匹配。</p>
<h2 id="SQL-RIGHT-JOIN-关键字"><a href="#SQL-RIGHT-JOIN-关键字" class="headerlink" title="SQL RIGHT JOIN 关键字"></a>SQL RIGHT JOIN 关键字</h2><p>RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。</p>
<p><strong>SQL RIGHT JOIN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghbagmz2yhj305k041dfs.jpg"></p>
<p><strong>注释</strong>：在某些数据库中，RIGHT JOIN 称为 RIGHT OUTER JOIN。<br><strong>注释</strong>：RIGHT JOIN 关键字从右表（Websites）返回所有的行，即使左表（access_log）中没有匹配。</p>
<h2 id="SQL-FULL-OUTER-JOIN-关键字"><a href="#SQL-FULL-OUTER-JOIN-关键字" class="headerlink" title="SQL FULL OUTER JOIN 关键字"></a>SQL FULL OUTER JOIN 关键字</h2><p>FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行。</p>
<p>FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。</p>
<p><strong>SQL FULL OUTER JOIN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghbahzrrmtj305k0413yh.jpg"></p>
<p><strong>注释</strong>：FULL OUTER JOIN 关键字返回左表（Websites）和右表（access_log）中所有的行。如果 “Websites” 表中的行在 “access_log” 中没有匹配或者 “access_log” 表中的行在 “Websites” 表中没有匹配，也会列出这些行。<br><strong>注释</strong>：MySQL中不支持 FULL OUTER JOIN</p>
<h1 id="SQL-UNION-操作符"><a href="#SQL-UNION-操作符" class="headerlink" title="SQL UNION 操作符"></a>SQL UNION 操作符</h1><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p>
<p>请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</p>
<p><strong>SQL UNION 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong>：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</p>
<p><strong>SQL UNION ALL 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong>：UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。</p>
<h1 id="SQL-INSERT-INTO-SELECT-语句"><a href="#SQL-INSERT-INTO-SELECT-语句" class="headerlink" title="SQL INSERT INTO SELECT 语句"></a>SQL INSERT INTO SELECT 语句</h1><p>通过 SQL，您可以从一个表复制信息到另一个表。<br>INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。</p>
<p><strong>SQL INSERT INTO SELECT 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//我们可以从一个表中复制所有的列插入到另一个已存在的表中：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table2</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1;</span><br><span class="line"></span><br><span class="line">//或者我们可以只复制希望的列插入到另一个已存在的表中：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table2</span><br><span class="line">(column_name(s))</span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1;</span><br></pre></td></tr></table></figure>

<h1 id="MySQL-复制表-MySQL的SELECT-INTO-FROM-语句"><a href="#MySQL-复制表-MySQL的SELECT-INTO-FROM-语句" class="headerlink" title="MySQL 复制表(MySQL的SELECT INTO FROM 语句)"></a>MySQL 复制表(MySQL的SELECT INTO FROM 语句)</h1><p><strong>复制表结构及其数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name_new <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name_old</span><br></pre></td></tr></table></figure>

<p><strong>只复制表结构：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name_new <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name_old <span class="keyword">WHERE</span> <span class="number">1</span>=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>或者：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name_new <span class="keyword">LIKE</span> table_name_old</span><br></pre></td></tr></table></figure>

<p><strong>只复制表数据：</strong></p>
<ul>
<li>如果两个表结构一样：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name_new <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name_old</span><br></pre></td></tr></table></figure>

<ul>
<li>如果两个表结构不一样：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name_new(column1,column2...) <span class="keyword">SELECT</span> column1,column2... <span class="keyword">FROM</span> table_name_old</span><br></pre></td></tr></table></figure>

<p><strong>SELECT INTO FROM 和 INSERT INTO SELECT 的区别：</strong></p>
<p>主要区别：SELECT INTO FROM 要求目标表不存在，因为在插入时会自动创建；INSERT INTO SELECT FROM 要求目标表存在。</p>
<p><strong>SELECT INTO FROM</strong> ：将查询出来的数据整理到一张新表中保存，表结构与查询结构一致。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *（查询出来的结果） <span class="keyword">INTO</span> newtable（新的表名）<span class="keyword">FROM</span> <span class="keyword">WHERE</span> （后续条件）</span><br></pre></td></tr></table></figure>

<p>即，查询出来结果—&gt;复制一张同结构的空表—&gt;将数据拷贝进去。</p>
<p><strong>INSERT INTO SELECT</strong> ：为已经存在的表批量添加新数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>  (准备好的表) <span class="keyword">SELECT</span> *（或者取用自己想要的结构）<span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 各种条件</span><br></pre></td></tr></table></figure>
<p>即，指定一张想要插入数据的表格—&gt;对数据进行加工筛选—&gt;填入一张准备好的表格。</p>
<h1 id="SQL-约束（Constraints）"><a href="#SQL-约束（Constraints）" class="headerlink" title="SQL 约束（Constraints）"></a>SQL 约束（Constraints）</h1><p>SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。</p>
<p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p>
<p><strong>SQL CREATE TABLE + CONSTRAINT 语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(</span><br><span class="line">column_name1 data_type(<span class="keyword">size</span>) constraint_name,</span><br><span class="line">column_name2 data_type(<span class="keyword">size</span>) constraint_name,</span><br><span class="line">column_name3 data_type(<span class="keyword">size</span>) constraint_name,</span><br><span class="line">....</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在 SQL 中，我们有如下约束：</p>
<ul>
<li><code>NOT NULL</code> - 指示某列不能存储 NULL 值。</li>
<li><code>UNIQUE</code> - 保证某列的每行必须有唯一的值。</li>
<li><code>PRIMARY KEY</code> - (<code>NOT NULL</code> 和 <code>UNIQUE</code> 的结合)。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>
<li><code>FOREIGN KEY</code> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li>
<li><code>CHECK</code> - 保证列中的值符合指定的条件。</li>
<li><code>DEFAULT</code> - 规定没有给列赋值时的默认值。</li>
</ul>
<h1 id="SQL-ALTER-TABLE-语句"><a href="#SQL-ALTER-TABLE-语句" class="headerlink" title="SQL ALTER TABLE 语句"></a>SQL ALTER TABLE 语句</h1><p>ALTER TABLE 语句用于在已有的表中添加、删除或修改列。</p>
<p><strong>SQL ALTER TABLE 语法：</strong></p>
<p>如需在表中添加列，请使用下面的语法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> column_name datatype</span><br></pre></td></tr></table></figure>

<p>如需删除表中的列，请使用下面的语法（请注意，某些数据库系统不允许这种在数据库表中删除列的方式）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name</span><br></pre></td></tr></table></figure>

<p>要改变表中列的数据类型，请使用下面的语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> column_name datatype</span><br></pre></td></tr></table></figure>

<h1 id="SQL-AUTO-INCREMENT-字段"><a href="#SQL-AUTO-INCREMENT-字段" class="headerlink" title="SQL AUTO INCREMENT 字段"></a>SQL AUTO INCREMENT 字段</h1><p>AUTO-INCREMENT 会在新记录插入表中时生成一个唯一的数字。</p>
<p><strong>AUTO INCREMENT 字段</strong><br>我们通常希望在每次插入新记录时，自动地创建主键字段的值。</p>
<h1 id="SQL-CREATE-VIEW-语句"><a href="#SQL-CREATE-VIEW-语句" class="headerlink" title="SQL CREATE VIEW 语句"></a>SQL CREATE VIEW 语句</h1><p>在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。</p>
<p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。</p>
<p>您可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。</p>
<p><strong>SQL CREATE VIEW 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> condition</span><br></pre></td></tr></table></figure>
<p><strong>注释：</strong>视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。</p>
<h1 id="SQL-撤销视图"><a href="#SQL-撤销视图" class="headerlink" title="SQL 撤销视图"></a>SQL 撤销视图</h1><p>您可以通过 DROP VIEW 命令来删除视图。</p>
<p><strong>SQL DROP VIEW 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name</span><br></pre></td></tr></table></figure>

<h1 id="MySQL中修改表名，表属性名等操作"><a href="#MySQL中修改表名，表属性名等操作" class="headerlink" title="MySQL中修改表名，表属性名等操作"></a>MySQL中修改表名，表属性名等操作</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">CHANGE</span> 原列名 新列名  类型； <span class="comment">--修改表的列属性名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">MODIFY</span> 列名 类型 ；  <span class="comment">--修改表的类类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 列名；  <span class="comment">--删除表的某一列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span>  列名 类型；<span class="comment">--添加某一列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">RENAME</span> 新表名； <span class="comment">--修改表名</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 基础知识</title>
    <url>/2020/07/18/Docker%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="Docker基础知识"><a href="#Docker基础知识" class="headerlink" title="Docker基础知识"></a>Docker基础知识</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run ubuntu:15.10 /bin/<span class="built_in">echo</span> <span class="string">&quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>参数含义：</strong></p>
<ul>
<li><code>docker</code>：Docker 的二进制执行文件。</li>
<li><code>run</code>：与前面的 docker 组合来运行一个容器。</li>
<li><code>ubuntu:15.10</code>：指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li>
<li><code>/bin/echo &quot;Hello world&quot;</code>：在启动的容器里执行的命令</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -i -t ubuntu:15.10 /bin/bash</span><br></pre></td></tr></table></figure>

<p><strong>参数含义：</strong></p>
<ul>
<li><code>-t</code>：在新容器内指定一个伪终端或终端。</li>
<li><code>-i</code>：允许你对容器内的标准输入 <code>stdin</code> 进行交互</li>
<li>可以通过运行 <code>exit</code> 命令或者使用 <code>ctrl+D</code> 来退出容器，会导致容器停止</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-d</code>：让容器在后台运行。</li>
<li><code>-P</code>：将容器内部使用的网络端口随机映射到我们使用的主机上。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker commit &lt;CONTAINER ID&gt; &lt;REPOSITORY&gt;</span><br></pre></td></tr></table></figure>

<p><strong>参数含义：</strong><br><code>-a</code>：提交的镜像作者;<br><code>-c</code>：使用Dockerfile指令来创建镜像;<br><code>-m</code>：提交时的说明文字;<br><code>-p</code>：在commit时，将容器暂停</p>
<table>
<thead>
<tr>
<th>commend</th>
<th>result</th>
</tr>
</thead>
<tbody><tr>
<td><code>docker ps</code></td>
<td>查看正在运行的容器</td>
</tr>
<tr>
<td><code>docker ps -a</code></td>
<td>查看所有容器</td>
</tr>
<tr>
<td><code>docker stop &lt;CONTAINER ID/REPOSITORY&gt;</code></td>
<td>关闭容器</td>
</tr>
<tr>
<td><code>docker logs &lt;CONTAINER ID/REPOSITORY&gt;</code></td>
<td>查看容器内的标准输出</td>
</tr>
<tr>
<td><code>docker pull &lt;IMAGE_NAME&gt;</code></td>
<td>载入镜像</td>
</tr>
<tr>
<td><code>docker restart &lt;CONTAINER ID&gt;</code></td>
<td>重启停止的容器</td>
</tr>
<tr>
<td><code>docker attach &lt;CONTAINER ID&gt;</code></td>
<td>进入后台运行中的容器</td>
</tr>
<tr>
<td><code>docker exec &lt;CONTAINER ID&gt;</code></td>
<td>退出容器，不会导致容器的停止</td>
</tr>
<tr>
<td><code>docker export &lt;CONTAINER ID&gt; &gt; xxx.tar</code></td>
<td>导出本地某个容器</td>
</tr>
<tr>
<td>`cat docker/xxx.tar</td>
<td>docker import - <EPOSITORY>:<TAG>`</td>
</tr>
<tr>
<td><code>docker import &lt;URL&gt; &lt;EPOSITORY&gt;</code></td>
<td>导入容器快照</td>
</tr>
<tr>
<td><code>docker rm -f &lt;CONTAINER ID&gt;</code></td>
<td>删除容器<code>-f</code>:强制删除;<code>-no-prune</code>:不要删除未带标签的父镜像</td>
</tr>
<tr>
<td><code>docker container prune</code></td>
<td>清理掉所有处于终止状态的容器</td>
</tr>
<tr>
<td><code>docker rm $(docker container ls -aq)</code></td>
<td>删除所有容器</td>
</tr>
<tr>
<td><code>docker commit &lt;CONTAINER ID&gt; &lt;REPOSITORY&gt;</code></td>
<td>把容器打包成镜像</td>
</tr>
<tr>
<td><code>docker inspect &lt;REPOSITORY&gt;:&lt;CONTAINER ID&gt;</code></td>
<td>查看镜像的详细信息</td>
</tr>
<tr>
<td><code>docker rm $(docker container ls -f &quot;status=exited&quot; -q)</code></td>
<td>同时删除多个符合筛选条件(状态为“exited”)的容器</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 知识总结</title>
    <url>/2020/07/18/Docker%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Docker-端口映射"><a href="#Docker-端口映射" class="headerlink" title="Docker 端口映射"></a>Docker 端口映射</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it -p 8080:18026 &lt;REPOSITORY&gt;:&lt;TAG&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<p><code>-p</code>：是容器内部端口绑定到指定的主机端口。这里指将主机的8080端口映射到容器的18026端口。-p可以多个端口映射同时存在以实现复杂功能</p>
</br>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it -p 127.0.0.1:8080:18026 &lt;REPOSITORY&gt;:&lt;TAG&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<p>这样我们就可以通过访问 127.0.0.1:8080 来访问容器的 18026 端口。</p>
 <a id="more"></a>

</br>

<p>上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 /udp。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it -p 127.0.0.1:8080:18026/udp &lt;REPOSITORY&gt;:&lt;TAG&gt; /bin/bash</span><br></pre></td></tr></table></figure>

</br>

<p><code>docker port &lt;CONTAINER ID&gt; &lt;PORT&gt;</code>命令可以让我们快捷地查看端口的绑定情况。</p>
<h2 id="Docker-代码调试"><a href="#Docker-代码调试" class="headerlink" title="Docker 代码调试"></a>Docker 代码调试</h2><p>centos的依赖<code>cmake/gcc/gdb/gdb-gdbserver/openssh-server/openssh-clients</code></p>
<p>docker要以特权模式启动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --privileged=<span class="literal">true</span> -v /Users/liuxing1/Files/Docker_Files/Shared\ Folders/:/tmp -p 8080:22 -p 8000:18080 mdm_docker /usr/sbin/init</span><br></pre></td></tr></table></figure>

<p>然后通过<code>docker exec -it &lt;Container_ID&gt; /bin/bash</code>进入容器操作</p>
<p>启动sshd服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">systemctl start sshd</span><br><span class="line"> </span><br><span class="line"><span class="comment">#设置开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> sshd</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置密码</span></span><br><span class="line">passwd</span><br></pre></td></tr></table></figure>


<h1 id="Docker-容器和本机互传文件"><a href="#Docker-容器和本机互传文件" class="headerlink" title="Docker 容器和本机互传文件"></a>Docker 容器和本机互传文件</h1><p>首先需要确定 docker 容器的<code>container_id</code>,可以使用<code>docker ps -a</code>查看你要操作的 docker 容器的<code>container_id</code></p>
<h2 id="Docker-容器向本机传送文件"><a href="#Docker-容器向本机传送文件" class="headerlink" title="Docker 容器向本机传送文件"></a>Docker 容器向本机传送文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker cp container_id:docker容器内的文件全路径 本机保存文件的全路径</span><br></pre></td></tr></table></figure>

<p><strong>例如：</strong><code>docker cp 4a2f08d2c1f8:/data1/configure.txt E:\PHP\configure.txt</code></p>
<h2 id="本机向-Docker-容器传送文件"><a href="#本机向-Docker-容器传送文件" class="headerlink" title="本机向 Docker 容器传送文件"></a>本机向 Docker 容器传送文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker cp 本机保存文件的全路径 container_id:docker容器内的文件全路径</span><br></pre></td></tr></table></figure>

<p><strong>例如：</strong><code>docker cp E:\PHP\configure.txt 4a2f08d2c1f8:/data1/configure.txt</code></p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 学习笔记</title>
    <url>/2019/09/06/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="redis学习笔记"><a href="#redis学习笔记" class="headerlink" title="redis学习笔记"></a>redis学习笔记</h1></br>

<h2 id="1-redis-简介"><a href="#1-redis-简介" class="headerlink" title="1-redis 简介"></a>1-<a href="https://liuxing1tec.github.io/2019/09/05/redis1/">redis 简介</a></h2></br>

<h2 id="2-redis-基础命令"><a href="#2-redis-基础命令" class="headerlink" title="2-redis 基础命令"></a>2-<a href="https://liuxing1tec.github.io/2019/09/05/redis2/">redis 基础命令</a></h2></br>

<h2 id="3-redis-配置"><a href="#3-redis-配置" class="headerlink" title="3-redis 配置"></a>3-<a href="https://liuxing1tec.github.io/2019/09/05/redis3/">redis 配置</a></h2></br>

<!---more--->

<h2 id="4-Redis-KEY键的操作"><a href="#4-Redis-KEY键的操作" class="headerlink" title="4-Redis KEY键的操作"></a>4-<a href="https://liuxing1tec.github.io/2019/09/05/redis4/">Redis KEY键的操作</a></h2></br>

<h2 id="5-redis-数据类型"><a href="#5-redis-数据类型" class="headerlink" title="5-redis 数据类型"></a>5-<a href="https://liuxing1tec.github.io/2019/09/05/redis5/">redis 数据类型</a></h2></br>

<h2 id="6-redis-String-字符串"><a href="#6-redis-String-字符串" class="headerlink" title="6-redis String(字符串)"></a>6-<a href="https://liuxing1tec.github.io/2019/09/05/redis6/">redis String(字符串)</a></h2></br>

<h2 id="7-redis-Hash-哈希表-字典"><a href="#7-redis-Hash-哈希表-字典" class="headerlink" title="7-redis Hash(哈希表/字典)"></a>7-<a href="https://liuxing1tec.github.io/2019/09/05/redis7/">redis Hash(哈希表/字典)</a></h2></br>

<h2 id="8-redis-List-列表"><a href="#8-redis-List-列表" class="headerlink" title="8-redis List(列表)"></a>8-<a href="https://liuxing1tec.github.io/2019/09/05/redis8/">redis List(列表)</a></h2></br>

<h2 id="9-redis-Set-集合"><a href="#9-redis-Set-集合" class="headerlink" title="9-redis Set(集合)"></a>9-<a href="https://liuxing1tec.github.io/2019/09/05/redis9/">redis Set(集合)</a></h2></br>

<h2 id="10-redis-Sorted-Set-有序集合"><a href="#10-redis-Sorted-Set-有序集合" class="headerlink" title="10-redis Sorted Set(有序集合)"></a>10-<a href="https://liuxing1tec.github.io/2019/09/05/redis10/">redis Sorted Set(有序集合)</a></h2></br>

<h2 id="11-redis-常用命令"><a href="#11-redis-常用命令" class="headerlink" title="11-redis 常用命令"></a>11-<a href="https://liuxing1tec.github.io/2019/09/05/redis11/">redis 常用命令</a></h2></br>

<h2 id="12-redis-事务"><a href="#12-redis-事务" class="headerlink" title="12-redis 事务"></a>12-<a href="https://liuxing1tec.github.io/2019/09/05/redis12/">redis 事务</a></h2></br>

<h2 id="13-redis-发布订阅"><a href="#13-redis-发布订阅" class="headerlink" title="13-redis 发布订阅"></a>13-<a href="https://liuxing1tec.github.io/2019/09/05/redis13/">redis 发布订阅</a></h2>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 语法</title>
    <url>/2019/09/05/Markdown%20%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="欢迎使用-Markdown"><a href="#欢迎使用-Markdown" class="headerlink" title="欢迎使用 Markdown"></a>欢迎使用 Markdown</h1><p><strong>Markdown是一种轻量级的「标记语言」</strong></p>
<p><img src="https://www.mdeditor.com/images/logos/markdown.png" alt="markdown" title="markdown"></p>
<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”</p>
<blockquote>
<p>Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如<del>Pandoc</del>，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p>
</blockquote>
<p><img src="https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png" alt="Pandao editor.md" title="Pandao editor.md"></p>
<a id="more"></a>
<h2 id="Markdown的功能列表演示"><a href="#Markdown的功能列表演示" class="headerlink" title="Markdown的功能列表演示"></a>Markdown的功能列表演示</h2><h1 id="标题H1"><a href="#标题H1" class="headerlink" title="标题H1"></a>标题H1</h1><h2 id="标题H2"><a href="#标题H2" class="headerlink" title="标题H2"></a>标题H2</h2><h3 id="标题H3"><a href="#标题H3" class="headerlink" title="标题H3"></a>标题H3</h3><h4 id="标题H4"><a href="#标题H4" class="headerlink" title="标题H4"></a>标题H4</h4><h5 id="标题H5"><a href="#标题H5" class="headerlink" title="标题H5"></a>标题H5</h5><h6 id="标题H5-1"><a href="#标题H5-1" class="headerlink" title="标题H5"></a>标题H5</h6><h3 id="字符效果和横线等"><a href="#字符效果和横线等" class="headerlink" title="字符效果和横线等"></a>字符效果和横线等</h3><hr>
<p><del>删除线</del> <s>删除线（开启识别HTML标签时）</s></p>
<p><em>斜体字</em>      <em>斜体字</em></p>
<p><strong>粗体</strong>  <strong>粗体</strong></p>
<p><strong><em>粗斜体</em></strong> <strong><em>粗斜体</em></strong></p>
<p>上标：X<sub>2</sub>，下标：O<sup>2</sup></p>
<p><strong>缩写(同HTML的abbr标签)</strong></p>
<blockquote>
<p>即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启</p>
</blockquote>
<p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p>
<h3 id="引用-Blockquotes"><a href="#引用-Blockquotes" class="headerlink" title="引用 Blockquotes"></a>引用 Blockquotes</h3><blockquote>
<p>引用文本 Blockquotes</p>
</blockquote>
<p>引用的行内混合 Blockquotes</p>
<blockquote>
<p>引用：如果想要插入空白换行<code>即&lt;br /&gt;标签</code>，在插入处先键入两个以上的空格然后回车即可，<a href="https://www.mdeditor.com/">普通链接</a>。</p>
</blockquote>
<h3 id="锚点与链接-Links"><a href="#锚点与链接-Links" class="headerlink" title="锚点与链接 Links"></a>锚点与链接 Links</h3><p><a href="https://www.mdeditor.com/">普通链接</a><br><a href="https://www.mdeditor.com/" title="普通链接带标题">普通链接带标题</a><br>直接链接：<a href="https://www.mdeditor.com/">https://www.mdeditor.com</a><br>[锚点链接][anchor-id]<br>[anchor-id]: <a href="https://www.mdeditor.com/">https://www.mdeditor.com/</a><br><a href="mailto:test.test@gmail.com">mailto:test.test@gmail.com</a><br>GFM a-tail link @pandao<br>邮箱地址自动链接 <a href="mailto:&#116;&#101;&#115;&#116;&#x2e;&#116;&#101;&#115;&#x74;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;">&#116;&#101;&#115;&#116;&#x2e;&#116;&#101;&#115;&#x74;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;</a>  <a href="mailto:&#x77;&#x77;&#119;&#x40;&#x76;&#105;&#x70;&#46;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;">&#x77;&#x77;&#119;&#x40;&#x76;&#105;&#x70;&#46;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;</a></p>
<blockquote>
<p>@pandao</p>
</blockquote>
<h3 id="多语言代码高亮-Codes"><a href="#多语言代码高亮-Codes" class="headerlink" title="多语言代码高亮 Codes"></a>多语言代码高亮 Codes</h3><h4 id="行内代码-Inline-code"><a href="#行内代码-Inline-code" class="headerlink" title="行内代码 Inline code"></a>行内代码 Inline code</h4><p>执行命令：<code>npm install marked</code></p>
<h4 id="缩进风格"><a href="#缩进风格" class="headerlink" title="缩进风格"></a>缩进风格</h4><p>即缩进四个空格，也做为实现类似 <code>&lt;pre&gt;</code> 预格式化文本 ( Preformatted Text ) 的功能。</p>
<pre><code>&lt;?php
    echo &quot;Hello world!&quot;;
?&gt;</code></pre>
<p>预格式化文本：</p>
<pre><code>| First Header  | Second Header |
| ------------- | ------------- |
| Content Cell  | Content Cell  |
| Content Cell  | Content Cell  |</code></pre>
<h4 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HTML-代码-HTML-codes"><a href="#HTML-代码-HTML-codes" class="headerlink" title="HTML 代码 HTML codes"></a>HTML 代码 HTML codes</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mate</span> <span class="attr">charest</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Editor.md, Markdown, Editor&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;<span class="attribute">color</span>:<span class="number">#444</span>;<span class="attribute">font-family</span>: <span class="string">&quot;Microsoft Yahei&quot;</span>, Tahoma, <span class="string">&quot;Hiragino Sans GB&quot;</span>, Arial;<span class="attribute">background</span>:<span class="number">#fff</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">ul</span>&#123;<span class="attribute">list-style</span>: none;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">img</span>&#123;<span class="attribute">border</span>:none;<span class="attribute">vertical-align</span>: middle;&#125;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;text-xxl&quot;</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text-green&quot;</span>&gt;</span>Plain text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="图片-Images"><a href="#图片-Images" class="headerlink" title="图片 Images"></a>图片 Images</h3><p>图片加链接 (Image + Link)：</p>
<p><a href="https://www.mdeditor.com/images/logos/markdown.png" title="markdown"><img src="https://www.mdeditor.com/images/logos/markdown.png"></a></p>
<blockquote>
<p>Follow your heart.</p>
</blockquote>
<hr>
<h3 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表 Lists"></a>列表 Lists</h3><h4 id="无序列表（减号）Unordered-Lists"><a href="#无序列表（减号）Unordered-Lists" class="headerlink" title="无序列表（减号）Unordered Lists (-)"></a>无序列表（减号）Unordered Lists (-)</h4><ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h4 id="无序列表（星号）Unordered-Lists"><a href="#无序列表（星号）Unordered-Lists" class="headerlink" title="无序列表（星号）Unordered Lists (*)"></a>无序列表（星号）Unordered Lists (*)</h4><ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h4 id="无序列表（加号和嵌套）Unordered-Lists"><a href="#无序列表（加号和嵌套）Unordered-Lists" class="headerlink" title="无序列表（加号和嵌套）Unordered Lists (+)"></a>无序列表（加号和嵌套）Unordered Lists (+)</h4><ul>
<li>列表一</li>
<li>列表二<ul>
<li>列表二-1</li>
<li>列表二-2</li>
<li>列表二-3</li>
</ul>
</li>
<li>列表三<ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
</li>
</ul>
<h4 id="有序列表-Ordered-Lists"><a href="#有序列表-Ordered-Lists" class="headerlink" title="有序列表 Ordered Lists (-)"></a>有序列表 Ordered Lists (-)</h4><ol>
<li>第一行</li>
<li>第二行</li>
<li>第三行</li>
</ol>
<h4 id="GFM-task-list"><a href="#GFM-task-list" class="headerlink" title="GFM task list"></a>GFM task list</h4><ul>
<li><input checked="" disabled="" type="checkbox"> GFM task list 1</li>
<li><input checked="" disabled="" type="checkbox"> GFM task list 2</li>
<li><input disabled="" type="checkbox"> GFM task list 3<ul>
<li><input disabled="" type="checkbox"> GFM task list 3-1</li>
<li><input disabled="" type="checkbox"> GFM task list 3-2</li>
<li><input disabled="" type="checkbox"> GFM task list 3-3</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> GFM task list 4<ul>
<li><input disabled="" type="checkbox"> GFM task list 4-1</li>
<li><input disabled="" type="checkbox"> GFM task list 4-2</li>
</ul>
</li>
</ul>
<hr>
<h3 id="绘制表格-Tables"><a href="#绘制表格-Tables" class="headerlink" title="绘制表格 Tables"></a>绘制表格 Tables</h3><table>
<thead>
<tr>
<th>项目</th>
<th align="right">价格</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td>计算机</td>
<td align="right">$1600</td>
<td align="center">5</td>
</tr>
<tr>
<td>手机</td>
<td align="right">$12</td>
<td align="center">12</td>
</tr>
<tr>
<td>管线</td>
<td align="right">$1</td>
<td align="center">234</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Function name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>help()</code></td>
<td>Display the help window.</td>
</tr>
<tr>
<td><code>destroy()</code></td>
<td><strong>Destroy your computer!</strong></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">Left-Aligned</th>
<th align="center">Center Aligned</th>
<th align="right">Right Aligned</th>
</tr>
</thead>
<tbody><tr>
<td align="left">col 3 is</td>
<td align="center">some wordy text</td>
<td align="right">$1600</td>
</tr>
<tr>
<td align="left">col 2 is</td>
<td align="center">centered</td>
<td align="right">$12</td>
</tr>
<tr>
<td align="left">zebra stripes</td>
<td align="center">are neat</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Item</th>
<th align="right">Value</th>
</tr>
</thead>
<tbody><tr>
<td>Computer</td>
<td align="right">$1600</td>
</tr>
<tr>
<td>Phone</td>
<td align="right">$12</td>
</tr>
<tr>
<td>Pipe</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<hr>
<h4 id="特殊符号-HTML-Entities-Codes"><a href="#特殊符号-HTML-Entities-Codes" class="headerlink" title="特殊符号 HTML Entities Codes"></a>特殊符号 HTML Entities Codes</h4><p>&copy; &amp;  &uml; &trade; &iexcl; &pound;<br>&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot;</p>
<p>X&sup2; Y&sup3; &frac34; &frac14;  &times;  &divide;   &raquo;</p>
<p>18&ordm;C  &quot;  &apos;</p>
<hr>
<h3 id="Emoji表情-smiley"><a href="#Emoji表情-smiley" class="headerlink" title="Emoji表情 :smiley:"></a>Emoji表情 :smiley:</h3><blockquote>
<p>Blockquotes :star:</p>
</blockquote>
<h4 id="GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x"><a href="#GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x" class="headerlink" title="GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:"></a>GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:</h4><ul>
<li><input checked="" disabled="" type="checkbox"> :smiley: @mentions, :smiley: #refs, <a href="">links</a>, <strong>formatting</strong>, and <del>tags</del> supported :editormd-logo:;</li>
<li><input checked="" disabled="" type="checkbox"> list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;</li>
<li><input checked="" disabled="" type="checkbox"> [ ] :smiley: this is a complete item :smiley:;</li>
<li><input disabled="" type="checkbox"> []this is an incomplete item <a href="#">test link</a> :fa-star: @pandao;</li>
<li><input disabled="" type="checkbox"> [ ]this is an incomplete item :fa-star: :fa-gear:;<ul>
<li><input disabled="" type="checkbox"> :smiley: this is an incomplete item <a href="#">test link</a> :fa-star: :fa-gear:;</li>
<li><input disabled="" type="checkbox"> :smiley: this is  :fa-star: :fa-gear: an incomplete item <a href="#">test link</a>;</li>
</ul>
</li>
</ul>
<h4 id="反斜杠-Escape"><a href="#反斜杠-Escape" class="headerlink" title="反斜杠 Escape"></a>反斜杠 Escape</h4><p>*literal asterisks*</p>
<hr>
<h3 id="科学公式-TeX-KaTeX"><a href="#科学公式-TeX-KaTeX" class="headerlink" title="科学公式 TeX(KaTeX)"></a>科学公式 TeX(KaTeX)</h3><p>$$E=mc^2$$</p>
<p>行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。</p>
<p>$$x &gt; y$$</p>
<p>$$(\sqrt{3x-1}+(1+x)^2)$$</p>
<p>$$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$</p>
<p>多行公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n a\_k b\_k \right)^2</span><br><span class="line">\leq</span><br><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n a\_k^2 \right)</span><br><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n b\_k^2 \right)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">    \frac&#123;1&#125;&#123;</span><br><span class="line">        \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;</span><br><span class="line">        \frac25 \pi&#125;&#125; &#x3D; 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;</span><br><span class="line">        1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span><br><span class="line">        &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125;</span><br><span class="line">         &#123;1+\cdots&#125; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">f(x) = <span class="tag">\<span class="name">int</span></span>_&#123;-<span class="tag">\<span class="name">infty</span></span>&#125;^<span class="tag">\<span class="name">infty</span></span></span><br><span class="line">    <span class="tag">\<span class="name">hat</span></span> f(<span class="tag">\<span class="name">xi</span></span>)<span class="tag">\<span class="name">,</span></span>e^&#123;2 <span class="tag">\<span class="name">pi</span></span> i <span class="tag">\<span class="name">xi</span></span> x&#125;</span><br><span class="line">    <span class="tag">\<span class="name">,</span></span>d<span class="tag">\<span class="name">xi</span></span></span><br></pre></td></tr></table></figure>
<h3 id="分页符-Page-break"><a href="#分页符-Page-break" class="headerlink" title="分页符 Page break"></a>分页符 Page break</h3><blockquote>
<p>Print Test: Ctrl + P</p>
</blockquote>
<hr>
<h3 id="绘制流程图-Flowchart"><a href="#绘制流程图-Flowchart" class="headerlink" title="绘制流程图 Flowchart"></a>绘制流程图 Flowchart</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 用户登陆</span><br><span class="line">op&#x3D;&gt;operation: 登陆操作</span><br><span class="line">cond&#x3D;&gt;condition: 登陆成功 Yes or No?</span><br><span class="line">e&#x3D;&gt;end: 进入后台</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="绘制序列图-Sequence-Diagram"><a href="#绘制序列图-Sequence-Diagram" class="headerlink" title="绘制序列图 Sequence Diagram"></a>绘制序列图 Sequence Diagram</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello</span><br><span class="line">Note right of China: China thinks\nabout it</span><br><span class="line">China--&gt;Andrew: How are you?</span><br><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span><br></pre></td></tr></table></figure>
<h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>redis Hash(哈希表/字典)</title>
    <url>/2019/09/05/redis%20Hash(%E5%93%88%E5%B8%8C%E8%A1%A8:%E5%AD%97%E5%85%B8)/</url>
    <content><![CDATA[<h1 id="redis-Hash-哈希表-字典"><a href="#redis-Hash-哈希表-字典" class="headerlink" title="redis Hash(哈希表/字典)"></a>redis Hash(哈希表/字典)</h1></br>

<p>redis hash 可储存多个键值对，适合储存对象的属性。</p>
</br>

<pre><code class="sh">hset key fieldName fileValue    //hset即hash set，set这里是设置的意思。往hash中添加一个字段（键值对）

//示例：
hset score zhangsan 90          //score是hash的名称，zhangsan 90是一个键值对。若zhangsan这个字段名之前不存在，则添加成功返回1。
hset score lisi 85              //一个hash可储存多个键值对（40多亿）。
hset score lisi 100             //之前这个hash中已存在lisi这个字段名，会覆盖原来的字段值，返回0.

hsetnx key fieldName fieldValue //多了后缀nx，同上，只是如果这个hash中已存在fieldName，则不执行操作（不覆盖原来的值），此时返回0。即当这个hash中fieldName不存在时才添加字段。

hmset key fileName1 fieldValue1 fieldName2 fieldValue2 ......   //同时添加多个字段。hmset即hash multiple set，因为是set所以字段已存在时会覆盖原有的值。

hget key fieldName              //获取指定字段的值

hmget key fieldName1 fieldName2 ......  //同时获取一个或多个字段的值

hgetall key                     //获取所有字段的值，会同时显示fieldName、fieldValue。hgetall即hash get all。

hdel key fieldName1 fieldName2 ...      //删除一个或多个字段

hexists key fieldName           //检查该字段是否已存在，已存在则返回1，该fieldName不存在或key不存在，则返回0

hlen key                        //获取hash中的字段（键值对）数量

hkeys  key                      //获取hash中所有的feildName

hvals key                       //获取hash中所有的fieldValue

hscan key cursor [match pattern] [count count]  //迭代hash中的键值对

hincrby key fieldName acount    //将指定字段的值增加acount。原来的字段值、acount都要是整数，否则提示错误。

//示例：
hincrby score lisi 5            //返回操作后的字段值，假如之前lisi的值是80，则返回85
hincrby score lisi -10          //acount支持负整数，即减。

hincrbyfloat  key fieldName acount  //同上，但是支持浮点数，就是说整数、浮点数都行。</code></pre>
</br>

<p><strong>说明</strong>：</p>
<ul>
<li>没有 hincr 这个命令 (+1) ；</li>
<li>没有提供 hdecr 命令 (减) ；</li>
<li>都带有前缀 h 表示 hash 。</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis KEY 键的操作</title>
    <url>/2019/09/05/redis%20KEY%20%E9%94%AE%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="redis-KEY键的操作"><a href="#redis-KEY键的操作" class="headerlink" title="redis KEY键的操作"></a>redis KEY键的操作</h1></br>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> key value       //设置、修改值</span><br><span class="line"></span><br><span class="line">get key             //如果key不存在，返回nil，表示空。</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> key            //返回key对应的value的数据类型</span><br><span class="line"></span><br><span class="line">rename key newKey   //重命名key，即修改键的名称。当key和newKey重名时，或者key不存在时，会提示错误。如果newKey已存在，会覆盖原来的值。</span><br><span class="line"></span><br><span class="line">renamenx key newKey //多了nx。返回一个整数。如果newKey不存在，则执行重命名，返回1；如果newKey已存在，不执行重命名，返回0。就是说newKey不存在时才执行。</span><br><span class="line"></span><br><span class="line">randomkey           //从当前数据库中随机返回一个key</span><br><span class="line"></span><br><span class="line">keys  pattern       //返回所有满足pattern的key</span><br><span class="line"></span><br><span class="line">keys person*        //示例：假设当前数据库中有3个key——person1，person2，person3，则该命令会返回所有以person开头的key，即person1、person2、person3</span><br><span class="line"></span><br><span class="line">exists key          //检测key是否存在，存在返回1，不存在返回0</span><br><span class="line"></span><br><span class="line">dump key            //序列化指定的key，返回序列化得到的二进制数据。</span><br><span class="line"></span><br><span class="line">del  key            //删除指定的键值对。若key存在，则删除key，并返回1；若key不存在，直接返回0.</span><br><span class="line"></span><br><span class="line">expire key seconds  //设置key的过期时间，以秒为单位</span><br><span class="line"></span><br><span class="line">expire age 60       //示例：60s后age过期，会自动删除age。</span><br><span class="line"></span><br><span class="line">expireat key timestamp              //设置key的过期时间。多了at。timestamp是时间戳，到了timestamp指定的时间，key过期，自动删除key。时间戳以秒为单位。</span><br><span class="line"></span><br><span class="line">pexpire  key  milliseconds          //设置key的过期时间，以毫秒为单位。多了前缀p</span><br><span class="line"></span><br><span class="line">pexpireat key milliseconds-timestamp//设置key的过期时间，时间戳，以毫秒为单位。多了前缀p、后缀at。</span><br><span class="line"></span><br><span class="line">move key db         //将键值对移到指定的数据库，相当于剪切。返回db——当前使用的数据库的index。</span><br><span class="line"></span><br><span class="line">select db           //redis默认使用数据库0，也可以用显式指定当前使用的数据库。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line"><span class="built_in">set</span> age 10      //默认使用数据库0</span><br><span class="line">move age 1      //将age键值对移到数据库1中。返回1——表示数据库1</span><br><span class="line">exists age      //此时使用的仍是数据库0，返回0——表示当前数据库中不存在age</span><br><span class="line">select 1        //选择（切换）到数据库1</span><br><span class="line">exists age      //返回1——表示存在age</span><br></pre></td></tr></table></figure>

<!---more--->

</br>
</br>

<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6oqr11vylj30di0a6jtd.jpg" alt="select"></p>
</br>

<p>端口号后面的 [1] 表示当前使用的是数据库 1 。使用数据库 0 时默认缺省。</p>
<p>redis 中 key 、value 加不加引号均可，都默认作为 String 处理。</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis List(列表)</title>
    <url>/2019/09/05/redis%20List(%E5%88%97%E8%A1%A8)/</url>
    <content><![CDATA[<h1 id="redis-List-列表"><a href="#redis-List-列表" class="headerlink" title="redis List(列表)"></a>redis List(列表)</h1></br>

<p>redis 列表是简单的字符串列表，列表是有序的，列表中的元素可以重复。</p>
<p>可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>一个列表最多可以包含 2<sup>32</sup> - 1 个元素 (40多亿)。</p>
</br>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lpush key value1 value2 ......  //往列表的头部（左边）推入一个或多个元素，lpush的l表示left。key是列表名称，把列表中的所有元素作为一个整体（value）。若key不存在，会自动创建。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line">lpush students <span class="string">&quot;zhangsan&quot;</span> <span class="string">&quot;lisi&quot;</span> <span class="string">&quot;wangwu&quot;</span>   //返回操作后列表中的总元素个数</span><br><span class="line">//先在列表头部添加“zhangsan”，再在列表头部添加“lisi”，接着在列表头部添加“wangwu”，最后列表的前三个元素依次是<span class="string">&quot;wangwu&quot;</span>、“lisi”、“zhangsan”。</span><br><span class="line"></span><br><span class="line">lpushx key value1 value2 ...... //同上，只是key不存在时，不执行操作（不会自动创建）。要key已存在且key时list类型时才会添加元素。</span><br><span class="line"></span><br><span class="line">lpop key                        //弹出列表的第一个元素，会从列表中移除并返回该元素。</span><br><span class="line"></span><br><span class="line">//l表示left，列表的头部。</span><br><span class="line"></span><br><span class="line">rpush key value1 value2 ......  //在列表尾部推入1个或多个元素。</span><br><span class="line"></span><br><span class="line">rpushx key value1 value2 ...... //尾部，key已存在时才会推入。</span><br><span class="line"></span><br><span class="line">rpop                            //弹出列表的最后一个元素</span><br><span class="line"></span><br><span class="line">//r表示right，列表的尾部。</span><br><span class="line">//上面的l、r命令是一一对应的。</span><br><span class="line"></span><br><span class="line">rpoplpush sourceKey destKey     //弹出sourceKey的最后一个元素，并在destKey的头部推入元素，即剪切。返回该元素。rpoplpush即对sourceKey执行rpop，对destKey执行lpush。</span><br><span class="line"></span><br><span class="line">blpop key1 key2 ... timeout     //弹出一个或多个的列表的第一个元素，如果列表为空会阻塞列表直到等待超时或发现可弹出元素为止。blpop即<span class="built_in">bind</span>  lpop。</span><br><span class="line"></span><br><span class="line">//示例： </span><br><span class="line">blpop students 60               //60s</span><br><span class="line"></span><br><span class="line">brpop key1 key2 ...... timeout</span><br><span class="line"></span><br><span class="line">brpoplpush sourceKey destKey timeout</span><br><span class="line"></span><br><span class="line">llen key                        //返回列表中的元素个数</span><br><span class="line"></span><br><span class="line">lset key index value            //给指定索引处的元素设置值（即修改元素值）</span><br><span class="line"></span><br><span class="line">lindex key index                //根据index索引元素，返回指定位置上的元素</span><br><span class="line"></span><br><span class="line">lrange key start end            //返回[start，end]区间上的所有元素。start、end是索引，比如0  -1  就是返回所有元素。</span><br><span class="line"></span><br><span class="line">ltrim key start end             //修剪列表，只保留[start，end]区间上的元素，其余元素会被删除。</span><br><span class="line"></span><br><span class="line">linsert key before/after value1 value2  //在元素value1之前/之后插入元素value2。value2是要插入的元素。</span><br><span class="line"></span><br><span class="line">//示例： </span><br><span class="line">linsert student before <span class="string">&quot;lisi&quot;</span> <span class="string">&quot;zhangsan&quot;</span>//在lisi的前面插入zhangsan</span><br><span class="line">//插入成功，返回操作后列表的总长度；若value1不存在，返回-1；若key不存在或key是一个空的list，则返回0.</span><br><span class="line"></span><br><span class="line">lrem key count value            //移除列表中值为value的所有元素。lrem即list remove。count是一个整数，表示要删除的个数、搜索方向。</span><br><span class="line">//count&gt;0：从表头向表尾搜索，移除count个值为value的元素</span><br><span class="line">//count&lt;0：从表尾向表头搜索，移除count的绝对值个值为value的元素</span><br><span class="line">//count=0：移除表中所有的值为value的元素。要遍历列表，从哪边开始结果、速度都是一样的。</span><br><span class="line"></span><br><span class="line">//示例： </span><br><span class="line">lrem scores 0 90                //移除列表中所有的90</span><br></pre></td></tr></table></figure>

</br>

<p>以上几个命令中，l 表示 list 。 index 从 0 开始，支持负数索引，index 要是已存在的</p>
<p>redis 的区间，都是闭区间，[ start ，end ] ，两边都包含。</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis Set(集合)</title>
    <url>/2019/09/05/redis%20Set(%E9%9B%86%E5%90%88)/</url>
    <content><![CDATA[<h1 id="redis-Set-集合"><a href="#redis-Set-集合" class="headerlink" title="redis Set(集合)"></a>redis Set(集合)</h1></br>

<p>redis 的 Set 是 String 类型的无序集合，元素不允许重复。</p>
<p>redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p>集合中最大的元素数为 2<sup>32</sup> - 1 (40多亿)。</p>
</br>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sadd key value1 value2 ...  //向集合中添加一个或多个元素。sadd即<span class="built_in">set</span> add，key是集合的名称。返回此次添加的元素个数。</span><br><span class="line"></span><br><span class="line">scard key                   //返回集合的元素个数</span><br><span class="line"></span><br><span class="line">smembers key                //返回集合中所有的元素</span><br><span class="line"></span><br><span class="line">sismember key elementValue  //判断该集合中是否有elementValue这个元素。有返回1，没有或者key不存在则返回0.</span><br><span class="line"></span><br><span class="line">spop key                    //随机移除并返回集合中的一个元素</span><br><span class="line"></span><br><span class="line">srandmember key             //随机返回集合中的一个元素，并不移除该元素。srandmember即<span class="built_in">set</span> random  member.</span><br><span class="line">//可带一个可选参数：</span><br><span class="line">srandmember key count       //count是一个整数，指定返回的元素个数。</span><br><span class="line">//count&gt;0：随机返回count个元素，这些元素互不相同。随机确定一个返回的元素后，再从剩余的元素中随机。</span><br><span class="line">//count&lt;0：随机返回count的绝对值个元素，这些元素可能相同。每次都是从整个集合中随机一个。</span><br><span class="line">//count的绝对值大于等于集合的元素个数时，返回集合中所有的元素。</span><br><span class="line"></span><br><span class="line">srem key value1 value2 ...  //移除集合中的一个或多个元素，若集合中没有该元素，会忽略该元素。</span><br><span class="line"></span><br><span class="line">smove sourceKey destKey elementValue        //将元素从一个集合移动到另一个集合。（剪切）</span><br><span class="line"></span><br><span class="line">sscan key cursor match pattern count num    //迭代集合中的元素。cursor指定对每元素的操作。</span><br><span class="line">//2个可选参数：</span><br><span class="line">//match pattern     指定配置模式，只迭代符合pattern的元素</span><br><span class="line">//count num         指定要迭代的元素个数</span><br><span class="line"></span><br><span class="line">sinter key1 key2 ...        //返回这些集合的交集</span><br><span class="line"></span><br><span class="line">sinterstore destKey key1 key2 ...           //多了store，求key1、key2.....这些集合的交集，并将交集中的元素存储在destKey集合中，返回交集中的元素个数</span><br><span class="line">//相同用法的还有：</span><br><span class="line">//sunion    并集</span><br><span class="line">//sdiff     差集</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis Sorted Set(有序集合)</title>
    <url>/2019/09/05/redis%20Sorted%20Set(%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88)/</url>
    <content><![CDATA[<h1 id="redis-Sorted-Set-有序集合"><a href="#redis-Sorted-Set-有序集合" class="headerlink" title="redis Sorted Set(有序集合)"></a>redis Sorted Set(有序集合)</h1></br>

<p>redis Sorted Set 有序集合是 string 类型元素的集合，元素不允许重复。</p>
</br>

<p>有序集合中的每个元素都会关联一个数值型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
</br>

<p>有序集合的成员是唯一的（不可重复）,但分数(score)可以重复。</p>
</br>

<!---more--->

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zadd key score1 value1 score2 value2 ...    //往有序集合中添加一个或多个元素。score是数值型，支持整数、浮点数，支持负数。z代表sorted <span class="built_in">set</span>。</span><br><span class="line"></span><br><span class="line">//示例： </span><br><span class="line">zadd students 1 zhangsan 2 lisi 3 wangwu    //返回此次添加的元素个数。score只是附加信息，真正的元素还是value1，value2，......</span><br><span class="line">//说明：<span class="built_in">hash</span>、list、<span class="built_in">set</span>、sorted <span class="built_in">set</span>，在Reids2.4之前的版本中，1次只支持添加一个元素，不支持1次添加多个元素。</span><br><span class="line"></span><br><span class="line">zcard key                                   //返回元素个数</span><br><span class="line"></span><br><span class="line">zcount key minScore maxScore                //返回分数值在[minScore，maxScore]上的元素个数</span><br><span class="line"></span><br><span class="line">zlexcount key minValue maxValue             //返回元素值在[minValue，maxValue]上的元素个数。</span><br><span class="line">//不能直接用元素值，有3种写法：</span><br><span class="line">//[value   表示包含此元素</span><br><span class="line">//(value  表示不包含此元素</span><br><span class="line">//- 表示第一个元素（包含），+ 表示最后一个元素（包含）</span><br><span class="line">//示例：</span><br><span class="line">zadd set1 1 a 2 b 3 c 4 d</span><br><span class="line">zlexcount set1 - +          //返回总元素个数，4</span><br><span class="line">zlexcount set1 [a [b        //2 。即[a,b]上元素个数</span><br><span class="line">zlexcount set1 (a [b        //1。(a,b]</span><br><span class="line">//不能缺省 [  或  (</span><br><span class="line"> </span><br><span class="line">zrange key minIndex maxIndex [withscores]   //返回索引在[minIndex，maxIndex]上的所有元素。</span><br><span class="line">//索引从0开始，支持负数，-1表示倒数第一个元素，-2表示倒数第二个元素。</span><br><span class="line">//withscores是可选参数，带上则还会显示分数，不带则只显示元素值。</span><br><span class="line"></span><br><span class="line">zrangebyscore key minScore maxScore [withscores]    //返回score在[minScore，maxScore]上的所有元素值。</span><br><span class="line">//默认使用 [ ，闭区间。也可以显示指定为 [ 或 ( 。</span><br><span class="line">//withscores可选，带上时会显示元素的score，不带上时不显示score。</span><br><span class="line">//示例： </span><br><span class="line">zrangebyscore set1 [1 (2                    //获取score在[1,2)上的所有元素</span><br><span class="line"></span><br><span class="line">zrank key elementValue                      //返回该元素值的索引。默认按score进行升序排列。索引从0开始。</span><br><span class="line"></span><br><span class="line">//以上3个命令都是按score升序排列的。下面的3个命令：</span><br><span class="line">zrevrange</span><br><span class="line">zrevrangebyscore</span><br><span class="line">zrevrank</span><br><span class="line">//前缀加不是z，而是zrev。和之前的3个命令一一对应，用法完全相同，只不过是按score降序排列计算的。</span><br><span class="line"></span><br><span class="line">zscore key elementValue                     //返回该元素值对应的score值</span><br><span class="line"></span><br><span class="line">zincrby key increment elementValue          //increment是增量，将指定元素的score增加increment。increment支持负数，即减。</span><br><span class="line"></span><br><span class="line">zrem key value1 value2 ...                  //移除一个或多个元素</span><br><span class="line"></span><br><span class="line">zremrangebyrank key startIndex endIndex     //移除下标在[startIndex，endIndex]上的所有元素。zremrangebyrank即z  remove  range  by  rank</span><br><span class="line"></span><br><span class="line">zremrangebyscore key minScore maxScore      //移除score在[minScore，maxScore]上的所有元素</span><br><span class="line"></span><br><span class="line">zremrangebylex key value1 value2            //移除这2个元素值之间的所有元素。</span><br><span class="line">//不能直接写元素值，可以用 - + 表示，或者在元素值前面加[  (</span><br><span class="line"></span><br><span class="line">zscan key cursor [match pattern] [count num]//迭代</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</br>

<p>sorted set 也提供了计算交集、并集的命令，此处不再一一介绍。</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis string</title>
    <url>/2019/09/05/redis%20string/</url>
    <content><![CDATA[<h1 id="redis-String-字符串"><a href="#redis-String-字符串" class="headerlink" title="redis String(字符串)"></a>redis String(字符串)</h1></br>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">getset key newValue     //给key设置value，并返回旧的value，如果没有旧的value，返回nil。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line"><span class="built_in">set</span> age 10  </span><br><span class="line">getset age 20           //age 的值被设置为20，并返回旧的值10</span><br><span class="line"></span><br><span class="line">getrange key start end  //获取value的部分</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line"><span class="built_in">set</span> content <span class="string">&quot;hello world!&quot;</span> </span><br><span class="line">getrange content 0 4    //返回content对应value的[0,4]上的字符，<span class="string">&quot;hello&quot;</span>，下标</span><br><span class="line">getrange content 0 -1   //支持负数索引，-1表示最后一个字符</span><br><span class="line"></span><br><span class="line">mget key1 key2 ......   //mget即multiple get，同时获取多个key的value，若某个key不存在，该key返回nil</span><br><span class="line"></span><br><span class="line">setex key timeout value //setex即<span class="built_in">set</span> expire，给key设置timeout、value，若key已存在，会覆盖原来的timeout、value</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line">setex age 60 10         //设置age 60s后过期，value为10</span><br><span class="line"></span><br><span class="line">setnx key value         //在 key 不存在时，为 key 设置value，设置成功返回1；若key已存在，不执行（不会替换原来的value），返回0。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line"><span class="built_in">set</span> age 10              //若age已存在，会则覆盖value</span><br><span class="line">setnx age 20            //age不存在时才设置，age已存在就不设置（不会覆盖原来的value）</span><br><span class="line"></span><br><span class="line">mset key1 value1 key2 value2 ......     //mset即multiple  <span class="built_in">set</span>。同时设置多个键值对。因为是<span class="built_in">set</span>，所以若某个key已存在，会覆盖。</span><br><span class="line"></span><br><span class="line">//示例： </span><br><span class="line">mset name <span class="string">&quot;lisi&quot;</span> age 20 </span><br><span class="line"></span><br><span class="line">msetnx key1 value1 key2 value2 ......   //msetnx即multiple setnx，当key不存在时才设置该key，已存在就不设置该key</span><br><span class="line"></span><br><span class="line">append key content      //若key已存在，则在value末尾追加content；若key不存在，则为其设置值，此时相当于<span class="built_in">set</span> key value。返回操作过后，value（新）的长度</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line">append str <span class="string">&quot;hello&quot;</span>      //之前str不存在，此句命令相当于<span class="built_in">set</span> str <span class="string">&quot;hello&quot;</span></span><br><span class="line">append str <span class="string">&quot; world!&quot;</span>    //之前str已存在，则在其末尾追加<span class="string">&quot; world!&quot;</span>，现在str的值变为<span class="string">&quot;hello world!&quot;</span></span><br><span class="line"></span><br><span class="line">incr key                //incr即increase，如果value是整数（可以是负整数），将value的值+1，并返回操作后的value。如果value不是整数，提示错误。如果key不存在，先将value初始化为0，再执行+1。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line"><span class="built_in">set</span> age 10              //等价于<span class="built_in">set</span> age <span class="string">&quot;10&quot;</span>。</span><br><span class="line">incr age                //value的值+1，变为11，并返回11。value是整数才会+1。</span><br><span class="line">get age                 //11</span><br><span class="line">incr price              //之前price不存在，value会先初始化为0，再+1，返回1</span><br><span class="line">get price               //1</span><br><span class="line"></span><br><span class="line">incrby key amount       //同上，只不过是+amout，不是+1。原来的value要是整数，amount也要是整数，否则提示错误。若key不存在，先初始化value为0。支持负整数（即减）。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line"><span class="built_in">set</span> age 20 </span><br><span class="line">incrby age 5            //+5</span><br><span class="line">get age                 //25</span><br><span class="line"></span><br><span class="line">incrbyfloat key amount  //同上，只不过原来的value可以是浮点数，增量amount也可以是浮点数。当然，整数也行。支持负数（减）。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line"><span class="built_in">set</span> price 2.3 </span><br><span class="line">incrbyfloat price 1.5     </span><br><span class="line">get price               //3.8</span><br><span class="line"></span><br><span class="line">decr key                //同incr key只不过decr是减。decr即decrease。</span><br><span class="line"></span><br><span class="line">decrby key amount       //同incrby  key  amount，只不过是减</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 事务</title>
    <url>/2019/09/05/redis%20%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="redis-事务"><a href="#redis-事务" class="headerlink" title="redis 事务"></a>redis 事务</h1></br>

<p>redis 事务可以一次执行多个命令。</p>
</br>

<p>常用命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">multi       //开起一个事务，标记一个事务块的开始，multi即multiple</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span>        //执行事务块内的命令</span><br><span class="line"></span><br><span class="line">discard     //取消事务</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">使用步骤：</span><br><span class="line"></span><br><span class="line">1. 先使用 multi 命令标记事务开始</span><br><span class="line">2. 将多个命令入队( queue ，队列)</span><br><span class="line">3. 使用 <span class="built_in">exec</span> 命令执行事务</span><br><span class="line"></span><br><span class="line">&lt;!---more---&gt;</span><br><span class="line"></span><br><span class="line">&lt;/br&gt;</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">```sh</span><br><span class="line">multi                   //标记事务开始</span><br><span class="line"><span class="built_in">set</span> name <span class="string">&quot;zhangsan&quot;</span>     //依次输入多个命令。输入一条命令后会提示“QUEUED”，表示此条命令已入队</span><br><span class="line"><span class="built_in">set</span> age 20 </span><br><span class="line">get name </span><br><span class="line"><span class="built_in">exec</span>                    //执行事务，会依次执行事务块内的命令，依次显示执行结果。</span><br><span class="line">//<span class="built_in">exec</span>是执行事务，如果想取消事务，将<span class="built_in">exec</span>换为discard即可。</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6pmw8jc4pj30g60egq3t.jpg"></p>
</br>
</br>

<p>单个 redis 命令的执行是原子性的，但 redis 并没有在事务上增加任何维持原子性的机制，所以 redis 事务的执行不是原子性的。</p>
</br>

<p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p>
</br>

<p>比如执行事务时，第一条执行成功，第二条执行失败，此时并不会回滚之前的操作（此处指第一条、第二条命令），而是继续执行后面的命令。但会显示第二条的结果是Fail。</p>
</br>

<p>即事务中任意命令执行失败，其余的命令依然被执行。</p>
</br>

<p>在事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令队列中。</p>
</br>

<p>redis2.6 以后的版本，在服务器内置了 Lua 环境（Lua解释器），可以通过<code>eval</code>命令执行Lua脚本。</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 发布订阅</title>
    <url>/2019/09/05/redis%20%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[<h1 id="redis-发布订阅"><a href="#redis-发布订阅" class="headerlink" title="redis 发布订阅"></a>redis 发布订阅</h1></br>

<p>redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。<br>pub 即 publish ，推送。<br>sub 即 subscribe ，订阅。</p>
</br>

<p>订阅者订阅某个 channel（频道），发布者将消息发布到 redis 服务器， redis 服务器将消息推送给这个频道的订阅者。<br>channel 管道、通道、频道。</p>
</br>

<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6pqnr02aoj30kt08z0tw.jpg" alt="订阅发布"></p>
</br>

<p>redis 的 channel 是公共频道，谁都可以发布消息。<br>就像微信群、QQ群，谁都可以发送消息，群成员（订阅者）都会收到消息。</p>
<!---more--->

</br>

<p>redis 的消息是在线即时消息，类似于广播，只有在线的订阅者（连接到 redis  服务器的订阅者），才会收到消息。<br>若当时不在线，并不会收到消息。后面登陆了（连接到服务器），服务器也不会推送之前（这个客户端未收到）的消息。服务器只推送一遍。</p>
</br>
</br>

<hr>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p><strong>1.</strong> 启动一个客户端，连接到服务器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli -a password</span><br></pre></td></tr></table></figure>

</br>

<p><strong>2.</strong> 订阅频道</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">subscribe channel1 channel2 ... //可订阅一个或多个频道</span><br></pre></td></tr></table></figure>

<p>会显示订阅的频道的信息，一个频道显示 3 个条目:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;subscribe&quot;</span>                 //固定的值，表示这是一个订阅频道</span><br><span class="line">订阅的频道名</span><br><span class="line">一个int型的数，表示这个频道是当前客户端订阅的第几个频道</span><br></pre></td></tr></table></figure>

<p>订阅之后，当前命令提示符会阻塞，只能接收 redis 服务器推送的消息，不能再执行命令。所以我们再启动一个客户端推送消息。</p>
</br>

<p><strong>3.</strong> 在另一个 redis 客户端推送消息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">publish channel message         //channel指定要推送消息到哪个频道，message是要推送的消息</span><br></pre></td></tr></table></figure>

<p>返回当前接收到消息的订阅者的数量。1表示只有一个订阅者收到了这条消息。</p>
<p>我们看到另一个客户端已接收到消息。一条消息显示3个项：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;message&quot;</span>                   //固定值，表示这是一条消息</span><br><span class="line">这条消息来自哪个订阅频道</span><br><span class="line">消息内容</span><br></pre></td></tr></table></figure>

</br>
</br>

<p>redis 的订阅是临时订阅，只在本次连接期间有效。断开连接后，会清除这个客户端的订阅信息，即取消所有订阅的频道。</p>
</br>

<p>谁都可以是发布者，谁都可以发送消息。可以向任何频道发送消息。</p>
</br>
</br>

<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">subscribe channel1 channel2 ...     //订阅一个或多个频道</span><br><span class="line"></span><br><span class="line">unsubscribe channel1 channel2 ...   //退订一个或多个频道。多了un</span><br><span class="line"></span><br><span class="line">psubscribe pattern1 pattern2 ...    //多了一个p，即pattern，订阅该模式匹配的所有频道，可以有多个匹配模式。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line">psubscribe tv       //订阅频道tv</span><br><span class="line">psubscribe *home    //订阅所有以home结尾的频道</span><br><span class="line">psubscribe china*   //订阅所有以china开头的频道</span><br><span class="line"></span><br><span class="line">punsubscribe pattern1 pattern2 ...  //退订符合匹配的所有频道，可指定多个匹配模式，满足pattern1或者满足pattern2.....,，注意是或。</span><br><span class="line"></span><br><span class="line">publish channel message             //推送消息到某个频道</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 基础命令</title>
    <url>/2019/09/05/redis%20%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="redis-基础命令"><a href="#redis-基础命令" class="headerlink" title="redis 基础命令"></a>redis 基础命令</h1></br>

<h2 id="服务器端命令"><a href="#服务器端命令" class="headerlink" title="服务器端命令"></a>服务器端命令</h2><ul>
<li><p>启动服务： <code>redis-server --service-start</code></p>
</li>
<li><p>关闭服务： <code>redis-server --service-stop</code></p>
</li>
<li><p>使用redis.conf配置开启服务： <code>redis-server /path/to/redis.conf</code></p>
</li>
</ul>
</br>

<h2 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h2><h3 id="1、连接服务器："><a href="#1、连接服务器：" class="headerlink" title="1、连接服务器："></a>1、连接服务器：</h3><p><code>redis-cli -h 127.0.0.1 -p 6379 -a abcd</code></p>
<p>参数说明：</p>
<ul>
<li><p>redis-cli    即redis-cli.exe，我们通常缺省后缀.exe</p>
</li>
<li><p>-h    即host，服务器的IP地址</p>
</li>
<li><p>-p    即port，服务器的端口</p>
</li>
<li><p>-a    即auth，redis服务器的密码</p>
</li>
</ul>
<!---more--->

<p>如果连接远程的 redis 服务器，必须指定服务器的IP地址。参数都可缺省，缺省时默认 -h 为 127.0.0.1 ，-p 为 6379 。</p>
</br>

<p>连接本地的redis服务器： <code>redis-cli -a yourPassword</code></p>
<p>连接远程的redis服务器： <code>redis-cli -h serverIP -a yourPassword</code></p>
</br>

<p>也可以之后再输入密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"></span><br><span class="line">auth yourPassword</span><br></pre></td></tr></table></figure>

</br>

<h3 id="2、密码操作"><a href="#2、密码操作" class="headerlink" title="2、密码操作"></a>2、密码操作</h3><ul>
<li><p>设置/修改密码： <code>config set requirepass newPassword</code>，修改密码后需要重新输入密码验证。Reids默认的数据类型是String，比如设置密码为123，会自动作为字符串“123”。</p>
</li>
<li><p>查看密码： <code>config get requirepass</code></p>
</li>
</ul>
</br>

<p>也可以通过修改配置文件来实现：</p>
</br>

<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6opk9rkstj30u00uxwtl.jpg" alt="requirepass"></p>
</br>

<p>推荐使用修改配置文件的方式。</p>
</br>

<p>因为本次连接期间，对配置文件的修改（包括密码），只在本次连接期间有效，并不会同步到 redis.conf 中。</p>
<p>断开连接后，下次连接时，使用的仍是配置文件中的参数（包括密码），之前命令行修改的配置参数失效。</p>
</br>

<p>redis 命令的关键字不区分大小写，比如以下2句命令等效：</p>
<pre><code class="sh"> SET name &quot;张三&quot; 
 SET name &quot;张三&quot; </code></pre>
</br>

<h2 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h2><ul>
<li><p>查看服务器端帮助： <code>redis-server --help</code></p>
</li>
<li><p>查看客户端帮助： <code>redis-cli --help</code></p>
</li>
</ul>
<blockquote>
<p>这2个命令不能在redis命令行中使用。</p>
</blockquote>
<ul>
<li>查看某个命令的说明： <code>help command</code> 。</li>
</ul>
<blockquote>
<p>该命令要在redis命令行下使用。</p>
</blockquote>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 常用命令</title>
    <url>/2019/09/05/redis%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="redis-常用命令"><a href="#redis-常用命令" class="headerlink" title="redis 常用命令"></a>redis 常用命令</h1></br>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">auth password       //验证密码</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> message        //打印文本</span><br><span class="line"></span><br><span class="line">ping                //测试连接，ping一下redis服务器，如果连接正常（已连接到redis服务器）返回PONG。</span><br><span class="line"></span><br><span class="line">select dbIndex      //选择当前使用的数据库，默认使用数据库0，下标，从0开始。</span><br><span class="line"></span><br><span class="line">quit                //关闭当前连接，并退到上一级命令行</span><br><span class="line"></span><br><span class="line">time                //获取服务器上的当前时间。</span><br><span class="line">//有2个返回值，第一个是当前时间的时间戳（s），第二个是当前这一秒已经逝去的微秒数。</span><br><span class="line">//1秒=10^3毫秒=10^6微秒。</span><br><span class="line">//两者组合可显示微秒级的时间。</span><br><span class="line"></span><br><span class="line">config <span class="built_in">set</span> param value  //设置配置参数</span><br><span class="line"></span><br><span class="line">config get param    //获取配置参数的值</span><br><span class="line"></span><br><span class="line">config rewrite      //将本次连接中，这条命令之前，对配置的设置都同步到redis.conf文件中。</span><br><span class="line">//默认对配置的设置、修改只在本次连接期间有效，并不会同步修改redis.conf文件。断开本次连接，会清除本次连接的配置设置，下次连接时，使用的是redis.conf文件中配置。</span><br><span class="line">//比如：</span><br><span class="line">//配置文件中的密码是abc，连接到redis服务器后</span><br><span class="line">config <span class="built_in">set</span> requirepass 123  //修改密码为123</span><br><span class="line">//这次连接中，密码不再是abc，而是123。但这个修改并不会同步到redis.conf文件中，redis.conf文件中的密码仍是abc。下次连接时，使用密码123会提示密码错误，需要使用abc。</span><br><span class="line">//有2种方式同步到redis.conf文件中：</span><br><span class="line">//1. 直接在redis.conf文件中修改</span><br><span class="line">//2. 连接到redis服务器后，在命令行修改，然后使用 config rewrite 命令同步到redis.conf中。</span><br><span class="line"> </span><br><span class="line">dbsize              //返回当前数据库中，key的数量</span><br><span class="line"></span><br><span class="line">flushdb             //清除当前数据库中所有的key，即清空当前数据库。flushdb即flush  db。</span><br><span class="line"></span><br><span class="line">flushall            //清除所有数据库中的key，即清空所有数据库。flushall即flush  all。</span><br><span class="line"></span><br><span class="line">save                //将redis数据库中的所有数据同步到.rdb文件中。redis数据库中的数据是常驻内存的，save命令将内存中的redis数据库数据同步写到数据库文件.rdb中。</span><br><span class="line"></span><br><span class="line">bgsave              //同上，只不过bgsave是在后台异步保存。</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">.rdb 文件是 redis 的数据库文件，rdb即 redis db。启动 redis 服务的时候，会从 .rdb 文件加载所有的数据库数据到内存。就是说数据库数据有 2 份，一份常驻内存，一份是持久化的磁盘文件。</span><br><span class="line"></span><br><span class="line">.rdb 文件也被称为 redis 数据库的备份文件。可以将一个 .rdb 文件放在redis安装目录下，作为这个  redis 服务器的数据库数据。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">client list             //列出所有的连接</span><br><span class="line"></span><br><span class="line">client <span class="built_in">kill</span> ip:port     //关闭某个连接。</span><br><span class="line">//6379只是redis服务器、客户端程序通信使用的端口号。建立一个redis数据库连接，会单独使用一个端口号，一个redis客户端可以建立多个数据库连接，一个连接对应一个端口号，并不是使用6379。</span><br><span class="line"></span><br><span class="line">shutdown [save/nosave]  //关闭redis服务器。会自动关闭与所有的redis客户端连接、以及与这些客户端建立的数据库连接，并同步数据集到rdb文件中。</span><br><span class="line">//shutdown命令可带一个可选参数：是否将数据集同步到rdb文件中。save——同步，nosave——不同步。</span><br><span class="line"></span><br><span class="line">client <span class="built_in">kill</span> ip:port     //是关闭某个数据库连接，quit是关闭redis客户端（会自动关闭这个客户端建立的所有数据库连接），shutdown save是关闭redis服务器（会自动关闭这个redis服务器的所有数据库连接）。</span><br><span class="line"></span><br><span class="line">slaveof ip port         //原本默认本身是主服务器，此句命令会将当前redis服务器作为某个服务器的从服务器。</span><br><span class="line">//示例： </span><br><span class="line">slaveof 127.23.23.35 6379   //把当前服务器作为127.23.23.35这台服务器的从服务器。</span><br><span class="line">//变成从服务器后，会丢弃原来数据库的数据集，从主服务器复制、同步数据到从服务器。</span><br><span class="line">//slave，意为奴隶、从属。</span><br><span class="line"></span><br><span class="line">sync                        //从主服务器复制、同步数据集</span><br><span class="line"></span><br><span class="line">slave no one                </span><br><span class="line">//这句命令是关闭这个从服务器的从主服务器复制数据的功能，使这个从服务器变成一个主服务器。使用的仍是作为从服务器时的数据集。</span><br><span class="line">//当主服务器出问题、或者需要做其他用途的时候，可以把一台从服务器作为主服务器，再把其它的从服务器作为这个主服务器的从属，这样就不会影响服务器的运转。</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 数据结构</title>
    <url>/2019/09/05/redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="redis-数据结构"><a href="#redis-数据结构" class="headerlink" title="redis 数据结构"></a>redis 数据结构</h1></br>

<p>redis 支持五种数据类型： string（字符串），hash（哈希），list（列表），set（集合）及 zset ( sorted set :有序集合)。</p>
</br>

<h2 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a>string 字符串</h2></br>

<p>示例： <code>set name &quot;zhangsan&quot;</code></p>
<p>key 、 value 都是 string 类型， key 、 value 引不引都行，习惯上 key 不加引号， value 随意。</p>
<p>string 是 redis 的基础数据类型。</p>
</br>

<h2 id="hash-哈希表-字典"><a href="#hash-哈希表-字典" class="headerlink" title="hash 哈希表/字典"></a>hash 哈希表/字典</h2></br>

<p>redis hash 是一个 string 类型的 field 和 value 的映射表，一个 hash 可储存多个键值对。</p>
<p>一个对象往往有多个属性（键值对形式）， hash 特别适合存储对象。</p>
<p>redis 中一个 hash 可以存储 2<sup>32</sup> - 1个 键值对（40多亿）。</p>
</br>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hmset zhangsan name <span class="string">&quot;zhangsan&quot;</span> age 12 gender male score 90</span><br></pre></td></tr></table></figure>

<p><code>hmset</code> : hm 即 hash multiple ，set 这里表示设置，不是集合。</p>
<p><code>zhangsan</code> : 即这张 hash 表的名称。 redis 是 key-value 数据库， zhangsan 就是 key ，后面的一堆属性看做一个整体（value）。</p>
<!---more--->

</br>

<h2 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h2></br>

<p>redis 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素（字符串）到列表的头部（左边）或者尾部（右边）。</p>
<p>一个列表最多可以包含 2<sup>32</sup> - 1 个元素 (40多亿)。</p>
</br>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lpush students <span class="string">&quot;zhangsan&quot;</span> <span class="string">&quot;lisi&quot;</span> <span class="string">&quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>lpush</code> : list push ，往 list 中添加元素。</p>
<p><code>students</code> : 即这个列表的名称（key）。列表中的元素看做一个整体（value）。</p>
</br>

<h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h2></br>

<p>redis set 是 string 类型的无序集合。集合成员是唯一的（不允许重复）。</p>
<p>redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p>集合的最大成员数为 2<sup>32</sup> - 1 (40多亿)。</p>
</br>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sadd mySet <span class="string">&quot;zhangsan&quot;</span> <span class="string">&quot;lisi&quot;</span> <span class="string">&quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>sadd</code> : set add ，往集合中添加元素。</p>
<p><code>mySet</code> : 即集合名称（key）。把集合中的所有元素作为一个整体（value）。</p>
</br>

<h2 id="sorted-set-有序集合"><a href="#sorted-set-有序集合" class="headerlink" title="sorted set 有序集合"></a>sorted set 有序集合</h2></br>

<p>redis 有序集合和集合一样也是 string 类型元素的集合,且不允许出现重复的成员。</p>
<p>但 sorted set 的每个元素都会关联一个 int 型或 double 型的数。 redis 正是通过这个数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员不允许重复，但分数(score)可以重复。</p>
<p>有序集合是通过哈希表实现的，添加，删除，查找的复杂度都是O(1)。</p>
<p>集合的最大成员数为 2<sup>32</sup> - 1 (40多亿)。</p>
</br>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zadd sortedSet 2 <span class="string">&quot;zhangsan&quot;</span> 2.9 <span class="string">&quot;lisi&quot;</span> 1.3 <span class="string">&quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>zadd</code> : z 代表有序集合。</p>
<p><code>sortedSet</code> : 即有序集合的名称（key）。把有序集合中的所有元素（包括分数）看做一个整体（value）。</p>
<p><code>2 &quot;zhangsan&quot;</code> : 2 就是 “zhangsan” 的 score ，顺序就是根据 score 进行升序排列的。 score 可以是 int 、 double 型。</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 简介</title>
    <url>/2019/09/05/redis%20%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="redis-简介"><a href="#redis-简介" class="headerlink" title="redis 简介"></a>redis 简介</h1><p>redis 是一个开源的使用 ANSI C 语言编写、基于内存亦可持久化的日志型、Key-Value 数据库，并提供了对多种编程语言的支持。</p>
</br>

<p>redis 的外围由一个键、值映射的字典构成，redis 五种数据类型：string ，hash ，list ，set 及 zset (sorted set) ，所以 redis 也被称为数据结构服务器。</p>
</br>

<p>redis 是一个 key-value 存储系统。支持存储的 value 类型包括 string (字符串)、list (链表)、set (集合)、zset (sorted set –有序集合)和 hash（哈希）。这些数据类型都支持 push/pop 、 add/remove 及取交集并集和差集等操作，且 redis 支持各种不同方式的排序。为了保证效率，数据都是缓存在内存中。 redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave (主从)同步。</p>
</br>

<p>redis 支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得 redis 可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。</p>
<!---more--->

</br>
</br>

<h2 id="redis的特点"><a href="#redis的特点" class="headerlink" title="redis的特点"></a>redis的特点</h2><ul>
<li>redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>redis 是完全在内存中保存数据的数据库，使用磁盘只是为了持久化。</li>
<li>redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list ，set ，zset ，hash 等数据结构的存储。</li>
<li>redis 支持数据的备份，即 master-slave 模式的数据备份。</li>
</ul>
</br>
</br>

<h2 id="redis-优势"><a href="#redis-优势" class="headerlink" title="redis 优势"></a>redis 优势</h2><ul>
<li><code>性能极高</code> —— redis 是一个高性能的 key-value 数据库，读的速度能达到110000次/s,写的速度能达到81000次/s。</li>
<li><code>丰富的数据类型</code> —— redis 支持 string ， hash ，list ，set 及 zset (sorted set) 等数据类型。</li>
<li><code>原子性</code> —— redis 的所有操作都是原子性的，要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。</li>
<li><code>丰富的特性</code> —— redis 支持 publish / subscribe , 通知, key 过期等特性。</li>
</ul>
</br>
</br>

<blockquote>
<p>redis 使用了两种文件格式：</p>
</blockquote>
<ul>
<li><code>全量数据格式</code>：把内存中的数据写入磁盘，便于下次读取文件进行加载</li>
<li><code>增量请求文件</code>：把内存中的数据序列化为操作请求，用于读取文件进行replay得到数据，序列化的操作包括 SET 、 RPUSH 、 SADD 、 ZADD 。</li>
</ul>
</br>
</br>

<blockquote>
<p>redis 的存储分为内存存储、磁盘存储和 log 文件三部分，配置文件中有三个参数对其进行配置。</p>
</blockquote>
<ul>
<li><p><code>save seconds updates</code>：save配置，指出在多长时间内，有多少次更新操作，就将数据同步到数据文件。</p>
</li>
<li><p><code>appendonly yes/no</code>：appendonly配置，指出是否在每次更新操作后进行日志记录，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面的save条件来同步的，所以有的数据会在一段时间内只存在于内存中。</p>
</li>
<li><p><code>appendfsync no/always/everysec</code>：appendfsync 配置，no 表示等操作系统进行数据缓存同步到磁盘，always 表示每次更新操作后手动调用 fsync() 将数据写到磁盘， everysec 表示每秒同步一次。</p>
</li>
</ul>
</br>
</br>

<p>redis 运行在内存中但可持久化到磁盘，在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。内存数据库的一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，可以做很多内部复杂性很强的事情。</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 配置</title>
    <url>/2019/09/05/redis%20%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="redis-配置"><a href="#redis-配置" class="headerlink" title="redis 配置"></a>redis 配置</h1><h2 id="redis-conf-中的部分参数说明"><a href="#redis-conf-中的部分参数说明" class="headerlink" title="redis.conf 中的部分参数说明"></a>redis.conf 中的部分参数说明</h2><blockquote>
<p>redis.conf 配置的是 redis 服务器。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>      <span class="comment">//设置redis服务器的ip地址</span></span><br><span class="line"></span><br><span class="line">port <span class="number">6379</span>           <span class="comment">//指定端口号</span></span><br><span class="line"></span><br><span class="line">timeout <span class="number">300</span>         <span class="comment">//当客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能。默认为0，需要修改。</span></span><br><span class="line"></span><br><span class="line">loglevel notice     <span class="comment">//指定日志记录级别，redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</span></span><br><span class="line"></span><br><span class="line">logfile <span class="built_in">stdout</span>      <span class="comment">//日志记录方式，需要修改为标准输出。默认为空串&quot;&quot;。</span></span><br><span class="line"></span><br><span class="line">databases <span class="number">16</span>        <span class="comment">//设置数据库的数量</span></span><br><span class="line"></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span>          <span class="comment">//指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合使用，默认是3个。900s=15minutes</span></span><br><span class="line"></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>         <span class="comment">//300s=5minutes</span></span><br><span class="line"></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>       <span class="comment">//60s=1minute</span></span><br><span class="line"></span><br><span class="line">rdbcompression yes  <span class="comment">//指定存储至本地数据库时是否压缩数据，默认为 yes，redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</span></span><br><span class="line"></span><br><span class="line">dbfilename dump.rdb <span class="comment">//指定本地数据库文件名，默认值为 dump.rdb</span></span><br><span class="line"></span><br><span class="line">dir ./              <span class="comment">//指定本地数据库存放目录</span></span><br><span class="line"></span><br><span class="line">requirepass foobared<span class="comment">//设置 redis 连接密码，如果配置了连接密码，客户端在连接 redis 时需要提供密码，默认关闭</span></span><br><span class="line"></span><br><span class="line">maxclients <span class="number">128</span>      <span class="comment">//设置同一时间最大客户端连接数，默认是注释了的</span></span><br><span class="line"></span><br><span class="line">maxmemory <span class="number">536870912</span> <span class="comment">//指定 redis 最大内存限制，512M。默认是注释了的，默认单位字节。</span></span><br><span class="line"></span><br><span class="line">appendonly yes      <span class="comment">//指定是否在每次更新操作后进行日志记录，redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</span></span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment">//指定日志文件名，默认为 appendonly.aof</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定日志更新条件，有3个值：always、everysec、no，默认使用everysec（其余2条是注释了的）</span></span><br><span class="line"><span class="meta"># appendfsync always<span class="comment">//表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）</span></span></span><br><span class="line">appendfsync everysec<span class="comment">//表示每秒同步一次（折中，默认值）</span></span><br><span class="line"><span class="meta"># appendfsync no    <span class="comment">//表示等操作系统进行数据缓存同步到磁盘（快）</span></span></span><br><span class="line"></span><br><span class="line">activerehashing yes <span class="comment">//指定是否激活重置哈希，默认为yes </span></span><br></pre></td></tr></table></figure>

<!---more--->

<p>redis 在启动时会把数据加载到内存中，达到最大内存后，redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区。</p>
<h2 id="命令行设置配置参数"><a href="#命令行设置配置参数" class="headerlink" title="命令行设置配置参数"></a>命令行设置配置参数</h2><p>设置配置参数： <code>CONFIG SET key value</code><br>查看配置参数： <code>CONFIG GET key</code><br>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CONFIG SET timeout 300 //设置timeout为300s</span><br><span class="line"></span><br><span class="line">CONFIG GET timeout     //查看timeout的配置值</span><br><span class="line"></span><br><span class="line">CONFIG GET *           //查看所有的配置参数</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSL</title>
    <url>/2019/09/05/OpenSSL/</url>
    <content><![CDATA[<h1 id="OpenSSL-API"><a href="#OpenSSL-API" class="headerlink" title="OpenSSL API"></a>OpenSSL API</h1><h2 id="什么是-SSL？"><a href="#什么是-SSL？" class="headerlink" title="什么是 SSL？"></a>什么是 SSL？</h2><p>SSL 是一个缩写，代表的是 Secure Sockets Layer（安全套接层）。它是支持在Internet 上进行安全通信的标准，并且将数据密码术集成到了协议之中。数据在离开您的计算机之前就已经被加密，然后只有 到达它预定的目标后才被解密。证书和密码学算法支持了这一切的运转，使用 OpenSSL，您将有机会切身体会它们。</p>
<p>理论上，如果加密的数据在到达目标之前被截取或窃听，那些数据是不可能被破解的。不过，由于计算机的变化一年比一年快，而且密码翻译方法有了新的发展，因此，SSL 中使用的加密协议被破解的可能性也在增大。</p>
<p>可以将 SSL 和安全连接用于 Internet 上任何类型的协议，不管是 HTTP、POP3，还是 FTP。还可以用 SSL 来保护 Telnet 会话。虽然可以用 SSL 保护任何连接，但是不必对每一类连接都使用 SSL。如果连接传输敏感信息，则应使用 SSL。</p>
<h2 id="什么是-OpenSSL？"><a href="#什么是-OpenSSL？" class="headerlink" title="什么是 OpenSSL？"></a>什么是 OpenSSL？</h2><p>OpenSSL 不仅仅是 SSL。它可以实现消息摘要、文件的加密和解密、数字证书、数字签名 和随机数字。关于 OpenSSL 库的内容非常多，远不是一篇文章可以容纳的。</p>
<p>OpenSSL 不只是 API，它还是一个命令行工具。命令行工具可以完成与 API 同样的工作， 而且更进一步，可以测试 SSL 服务器和客户机。它还让开发人员对 OpenSSL 的能力有一个认识。</p>
<a id="more"></a>

<h2 id="您需要什么"><a href="#您需要什么" class="headerlink" title="您需要什么"></a>您需要什么</h2><p>首先需要的是最新版本的 OpenSSL。查阅<a href="https://www.openssl.org/">官网</a>，以确定从哪里可以获得最新的可以自己编译的源代码，或者最新版本的二进制文件（如果您不希望花费时间来编译的话）。不过，为了安全起见，我建议您下载最新的源代码并自己编译它。二进制版本通常是由第三方而不是由 OpenSSL 的开发人员来编译和发行的。</p>
<p>一些 Linux 的发行版本附带了 OpenSSL 的二进制版本，对于学习如何使用 OpenSSL 库来说，这足够了；不过，如果您打算去做一些实际的事情，那么一定要得到最新的版本，并保持该版本一直是最新的。</p>
<p>对于以 RPM 形式安装的 Linux 发行版本（Red Hat、Mandrake 等），建议您通过从发行版本制造商那里获得 RPM 程序包来更新您的 OpenSSL 发行版本。出于安全方面的原因，建议您使用最新版本的发行版本。如果您的发行版本不能使用最新版本的 OpenSSL，那么建议您只覆盖库文件，不要覆盖可执行文件。OpenSSL 附带的 FAQ 文档中包含了有关这方面的细节。</p>
<p>还要注意的是，OpenSSL 并没有在所有的平台上都获得官方支持。虽然制造商已经尽力使其能够跨平台兼容，但仍然存在 OpenSSL 不能用于您的计算机和/或操作系统的可能。请参阅 OpenSSL 的 <a href="https://www.openssl.org/">Web 站点</a>，以获得关于哪些平台可以得到支持的信息。</p>
<p>如果想使用 OpenSSL 来生成证书请求和数字证书，那么必须创建一个配置文件。在OpenSSL 程序包的 apps 文件夹中，有一个名为 openssl.cnf 的 可用模板文件。我不会对该文件进行讨论，因为这不在本文要求范围之内。不过，该模板文件有一些非常好的注释，而且如果在 Internet 上搜索，您可以找到很多讨论修改该文件的教程。</p>
<h2 id="头文件和初始化"><a href="#头文件和初始化" class="headerlink" title="头文件和初始化"></a>头文件和初始化</h2><p>本教程所使用的头文件只有三个：ssl.h、bio.h 和 err.h。它们都位于 openssl 子目录中，而且都是开发您的项目所必需的。要初始化 OpenSSL 库，只需要三个代码行即可。清单 1 中列出了所有内容。其他的头文件 和/或 初始化函数可能是其他一些功能所必需的。</p>
<p>清单 1. 必需的头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* OpenSSL headers */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;openssl/bio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;openssl/ssl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;openssl/err.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initializing OpenSSL */</span></span><br><span class="line"></span><br><span class="line">SSL_load_error_strings();</span><br><span class="line"></span><br><span class="line">ERR_load_BIO_strings();</span><br><span class="line"></span><br><span class="line">OpenSSL_add_all_algorithms();</span><br></pre></td></tr></table></figure>

<h2 id="建立非安全连接"><a href="#建立非安全连接" class="headerlink" title="建立非安全连接"></a>建立非安全连接</h2><p>不管连接是安全的还是不安全的，OpenSSL 都使用了一个名为 BIO 的抽象库来处理包括文件和套接字在内的各种类型的通信。您还可以将 OpenSSL 设置成为一个过滤器，比如用于 UU 或 Base64 编码的过滤器。</p>
<p>在这里对 BIO 库进行全面说明有点麻烦，所以我将根据需要一点一点地介绍它。首先，我将向您展示如何建立一个标准的套接字连接。相对于使用 BSD 套接字库，该操作需要的代码行更少一些。</p>
<p>在建立连接（无论安全与否）之前，要创建一个指向 BIO 对象的指针。这类似于在标准 C 中为文件流创建 FILE 指针。</p>
<p>清单 2. 指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BIO * bio;</span><br></pre></td></tr></table></figure>

<h3 id="打开连接"><a href="#打开连接" class="headerlink" title="打开连接"></a>打开连接</h3><p>创建新的连接需要调用 BIO_new_connect 。您可以在同一个调用中同时 指定主机名和端口号。也可以将其拆分为两个单独的调用：一个是创建连接并设置主机名的BIO_new_connect 调用，另一个是设置端口号的 BIO_set_conn_port （或者 BIO_set_conn_int_port ）调用。</p>
<p>不管怎样，一旦 BIO 的主机名和端口号都已指定，该指针会尝试打开连接。没有什么可以影响它。如果创建 BIO 对象时遇到问题，指针将会是 NULL。为了确保连接成功，必须执行 BIO_do_connect 调用。</p>
<p>清单 3. 创建并打开连接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bio = BIO_new_connect(<span class="string">&quot;hostname:port&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bio == <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle the failure */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BIO_do_connect(bio) &lt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle failed connection */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，第一行代码使用指定的主机名和端口创建了一个新的 BIO 对象，并以所示风格对该对象进行格式化。例如，如果您要连接到 <a href="http://www.ibm.com/">www.ibm.com</a> 的 80 端口，那么该字符串将是 <a href="http://www.ibm.com/">www.ibm.com:80</a> 。调用 BIO_do_connect 检查连接是否成功。如果出错，则返回 0 或 -1。</p>
<h3 id="与服务器进行通信"><a href="#与服务器进行通信" class="headerlink" title="与服务器进行通信"></a>与服务器进行通信</h3><p>不管 BIO 对象是套接字还是文件，对其进行的读和写操作都是通过以下两个函数来完成的： BIO_read 和 BIO_write 。很简单，对吧？精彩之处就在于它始终如此。</p>
<p>BIO_read 将尝试从服务器读取一定数目的字节。它返回读取的字节数、 0 或者 -1。在受阻塞的连接中，该函数返回 0，表示连接已经关闭，而 -1 则表示连接出现错误。在非阻塞连接的情况下，返回 0 表示没有可以获得的数据，返回 -1 表示连接出错。可以调用 BIO_should_retry 来确定是否可能重复出现该错误。</p>
<p>清单 4. 从连接读取</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = BIO_read(bio, buf, len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle closed connection */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(! BIO_should_retry(bio))</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle failed read here */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do something to handle the retry */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BIO_write 会试着将字节写入套接字。它将返回实际写入的字节数、0 或者 -1。同 BIO_read ，0 或 -1 不一定表示错误。BIO_should_retry 是找出问题的途径。如果需要重试写操作，它必须使用和前一次完全相同的参数。</p>
<p>清单 5. 写入到连接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(BIO_write(bio, buf, len) &lt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(! BIO_should_retry(bio))</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle failed write here */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do something to handle the retry */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>关闭连接也很简单。您可以使用以下两种方式之一来关闭连接： BIO_reset 或 BIO_free_all 。如果您还需要重新使用对象，那么请使用第一种方式。 如果您不再重新使用它，则可以使用第二种方式。</p>
<p>BIO_reset 关闭连接并重新设置 BIO 对象的内部状态，以便可以重新使用连接。如果要在整个应用程序中使用同一对象，比如使用一台安全的聊天客户机，那么这样做是有益的。该函数没有返回值。</p>
<p>BIO_free_all 所做正如其所言：它释放内部结构体，并释放所有相关联的内存，其中包括关闭相关联的套接字。如果将 BIO 嵌入于一个类中，那么应该在类的析构函数中使用这个调用。</p>
<p>清单 6. 关闭连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* To reuse the connection, use this line *&#x2F;</span><br><span class="line"></span><br><span class="line">BIO_reset(bio);</span><br><span class="line"></span><br><span class="line">&#x2F;* To free it from memory, use this line *&#x2F;</span><br><span class="line"></span><br><span class="line">BIO_free_all(bio);</span><br></pre></td></tr></table></figure>

<h2 id="建立安全连接"><a href="#建立安全连接" class="headerlink" title="建立安全连接"></a>建立安全连接</h2><p>现在需要给出建立安全连接需要做哪些事情。唯一要改变的地方就是建立并进行连接。其他所有内容都是相同的。</p>
<p>安全连接要求在连接建立后进行握手。在握手过程中，服务器向客户机发送一个证书，然后，客户机根据一组可信任证书来核实该证书。它还将检查证书，以确保它没有过期。要 检验证书是可信任的，需要在连接建立之前提前加载一个可信任证书库。</p>
<p>只有在服务器发出请求时，客户机才会向服务器发送一个证书。该过程叫做客户机认证。使用证书，在客户机和服务器之间传递密码参数，以建立安全连接。尽管握手是在建立连接之后才进行的，但是客户机或服务器可以在任何时刻请求进行一次新的握手。</p>
<p><a href="">参考资料</a>部分中列出的 Netscasp 文章 和 RFC 2246 ，对握手以及建立安全连接的其他方面的知识进行了更详尽的论述。</p>
<h3 id="为安全连接进行设置"><a href="#为安全连接进行设置" class="headerlink" title="为安全连接进行设置"></a>为安全连接进行设置</h3><p>为安全连接进行设置要多几行代码。同时需要有另一个类型为 SSL_CTX 的指针。该结构保存了一些 SSL 信息。您也可以利用它通过 BIO 库建立 SSL 连接。可以通过使用 SSL 方法函数调用 SSL_CTX_new 来创建这个结构，该方法函数通常是 SSLv23_client_method 。</p>
<p>还需要另一个 SSL 类型的指针来保持 SSL 连接结构（这是短时间就能完成的一些连接所必需的）。以后还可以用该 SSL 指针来检查连接信息或设置其他 SSL 参数。</p>
<p>清单 7. 设置 SSL 指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SSL_CTX * ctx = SSL_CTX_new(SSLv23_client_method());</span><br><span class="line"></span><br><span class="line">SSL * ssl;</span><br></pre></td></tr></table></figure>
<h3 id="加载可信任证书库"><a href="#加载可信任证书库" class="headerlink" title="加载可信任证书库"></a>加载可信任证书库</h3><p>在创建上下文结构之后，必须加载一个可信任证书库。这是成功验证每个证书所必需的。如果不能确认证书是可信任的，那么 OpenSSL 会将证书标记为无效（但连接仍可以继续）。</p>
<p>OpenSSL 附带了一组可信任证书。它们位于源文件树的 certs 目录中。 不过，每个证书都是一个独立的文件 —— 也就是说，需要单独加载每一个证书。在 certs 目录下，还有一个存放过期证书的子目录。试图加载这些证书将会出错。</p>
<p>如果您愿意，可以分别加载每一个文件，但为了简便起见，最新的 OpenSSL 发行版本的可信任证书通常存放在源代码档案文件中，这些档案文件位于名为“TrustStore.pem”的单个文件中。如果已经有了一个可信任证书库，并打算将它用于特定的项目中，那么只需使用您的文件替换清单 8 中的“TrustStore.pem”（或者使用单独的函数调用将它们全部加载）即可。</p>
<p>可以调用<code>int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,                                   const char *CApath);</code> 来加载可信任证书库文件。这里要用到三个参数：上下文指针、可信任库文件的路径和文件名，以及证书所在目录的路径。必须指定可信任库文件或证书的目录。如果指定成功，则返回 1，如果遇到问题，则返回 0。</p>
<p>清单 8. 加载信任库</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(! SSL_CTX_load_verify_locations(ctx, <span class="string">&quot;/path/to/TrustStore.pem&quot;</span>, <span class="literal">NULL</span>))</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle failed load here */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果打算使用目录存储可信任库，那么必须要以特定的方式命名文件。OpenSSL 文档清楚 地说明了应该如何去做，不过，OpenSSL 附带了一个名为 c_rehash 的工具， 它可以将文件夹配置为可用于 SSL_CTX_load_verify_locations 的路径参数。</p>
<p>清单 9. 配置证书文件夹并使用它</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Use this at the command line */</span></span><br><span class="line"></span><br><span class="line">c_rehash /path/to/certfolder</span><br><span class="line"></span><br><span class="line"><span class="comment">/* then call this from within the application */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(! SSL_CTX_load_verify_locations(ctx, <span class="literal">NULL</span>, <span class="string">&quot;/path/to/certfolder&quot;</span>))</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle error here */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了指定所有需要的验证证书，您可以根据需要命名任意数量的单独文件或文件夹。您还可以同时指定文件和文件夹。</p>
<h3 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h3><p>将指向 SSL 上下文的指针作为唯一参数，使用 BIO_new_ssl_connect 创建 BIO 对象。还需要获得指向 SSL 结构的指针。在本文中，只将该指针用于 SSL_set_mode 函数。而这个函数是用来设置 SSL_MODE_AUTO_RETRY 标记的。使用这个选项进行设置，如果服务器突然希望进行一次新的握手，那么 OpenSSL 可以在后台处理它。如果没有这个选项，当服务器希望进行一次新的握手时，进行读或写操作都将返回一个错误，同时还会在该过程中设置 retry 标记。</p>
<p>清单 10. 设置 BIO 对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bio = BIO_new_ssl_connect(ctx);</span><br><span class="line"></span><br><span class="line">BIO_get_ssl(bio, &amp; ssl);</span><br><span class="line"></span><br><span class="line">SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);</span><br></pre></td></tr></table></figure>
<p>设置 SSL 上下文结构之后，就可以创建连接了。主机名是使用 BIO_set_conn_hostname 函数设置的。主机名和端口的指定格式与前面的相同。该函数还可以打开到主机的连接。为了确认已经成功打开连接，必须执行对 BIO_do_connect 的调用。该调用还将执行握手来建立安全连接。</p>
<p>清单 11. 打开安全连接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Attempt to connect */</span></span><br><span class="line"></span><br><span class="line">BIO_set_conn_hostname(bio, <span class="string">&quot;hostname:port&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Verify the connection opened and perform the handshake */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BIO_do_connect(bio) &lt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle failed connection */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接建立后，必须检查证书，以确定它是否有效。实际上，OpenSSL 为我们完成了这项任务。如果证书有致命的问题（例如，哈希值无效），那么将无法建立连接。但是，如果证书的问题并不是致命的（当它已经过期或者尚不合法时），那么仍可以继续使用连接。</p>
<p>可以将 SSL 结构作为唯一参数，调用 SSL_get_verify_result 来查明证书是否通过了 OpenSSL 的检验。如果证书通过了包括信任检查在内的 OpenSSL 的内部检查，则返回 X509_V_OK。如果有地方出了问题，则返回一个错误代码，该代码被记录在命令行工具的 verify 选项下。</p>
<p>应该注意的是，验证失败并不意味着连接不能使用。是否应该使用连接取决于验证结果和安全方面的考虑。例如，失败的信任验证可能只是意味着没有可信任的证书。连接仍然可用，只是需要从思想上提高安全意识。</p>
<p>清单 12. 检查证书是否有效</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(SSL_get_verify_result(ssl) != X509_V_OK)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle the failed verification */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是所需要的全部操作。通常，与服务器进行通信都要使用 BIO_read 和 BIO_write 。并且只需调用 BIO_free_all 或 BIO_reset ，就可以关闭连接，具体调用哪一个方法取决于是否重用 BIO。</p>
<p>必须在结束应用程序之前的某个时刻释放 SSL 上下文结构。可以调用 SSL_CTX_free 来释放该结构。</p>
<p>清单 13. 清除 SSL 上下文</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SSL_CTX_free(ctx);</span><br></pre></td></tr></table></figure>

<h2 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h2><p>显然 OpenSSL 抛出了某种类型的错误。这意味着什么？首先，您需要得到错误代码本身； ERR_get_error 可以完成这项任务；然后，需要将错误代码转换为错误字符串，它是一个指向由 SSL_load_error_strings 或 ERR_load_BIO_strings 加载到内存中的永久字符串的指针。可以在一个嵌套调用中完成这项操作。</p>
<p>表 1 略述了从错误栈检索错误的方法。清单 24 展示了如何打印文本字符串中的最后一个 错误信息。</p>
<p>表 1. 从栈中检索错误</p>
<table>
    <tr>
        <th>ERR_reason_error_string</th>
        <th>返回一个静态字符串的指针，然后可以将字符串显示在屏幕上、写入文件，或者以任何您希望的方式进行处理</th>
    </tr>
    <tr>
        <th>ERR_lib_error_string</th>
        <th>指出错误发生在哪个库中</th>
    </tr>
    <tr>
        <th>ERR_func_error_string</th>
        <th>返回导致错误的 OpenSSL 函数</th>
    </tr>
</table>

<p>清单 14. 打印出最后一个错误</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, ERR_reason_error_string(ERR_get_error()));</span><br></pre></td></tr></table></figure>
<p>您还可以让库给出预先格式化了的错误字符串。可以调用 ERR_error_string 来得到该字符串。该函数将错误代码和一个预分配的缓冲区作为参数。而这个缓冲区必须是 256 字节长。如果参数为 NULL，则 OpenSSL 会将字符串写入到一个长度为 256 字节的静态缓冲区中，并返回指向该缓冲区的 指针。否则，它将返回您给出的指针。如果您选择的是静态缓冲区选项，那么在下一次调用 ERR_error_string 时，该缓冲区会被覆盖。</p>
<p>清单 15. 获得预先格式化的错误字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ERR_error_string(ERR_get_error(), <span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>
<p>您还可以将整个错误队列转储到文件或 BIO 中。可以通过 ERR_print_errors 或 ERR_print_errors_fp 来实现这项操作。队列是以可读格式被转储的。第一个函数将队列发送到 BIO ，第二个函数将队列发送到 FILE 。字符串格式如下（引自 OpenSSL 文档）：</p>
<pre><code>[pid]:error:[error code]:[library name]:[function name]:[reason string]:[file name]:[line]:[optional text message]</code></pre>
<p>其中， [pid] 是进程 ID， [error code] 是一个 8 位十六进制代码， [file name] 是 OpenSSL 库中的源代码文件， [line]是源文件中的行号。</p>
<p>清单 16. 转储错误队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ERR_print_errors_fp(FILE *);</span><br><span class="line"></span><br><span class="line">ERR_print_errors(BIO *);</span><br></pre></td></tr></table></figure>
<h2 id="开始做吧"><a href="#开始做吧" class="headerlink" title="开始做吧"></a>开始做吧</h2><p>使用 OpenSSL 创建基本的连接并不困难，但是，当试着确定该如何去做时，文档可能是一个小障碍。本文向您介绍了一些基本概念，但 OpenSSL 还有很多灵活之处有待发掘，而且您还可能需要一些高级设置，以便项目能够充分利用 SSL 的功能。</p>
<p>本文中有两个样例。一个样例展示了到 <a href="http://www.verisign.com/">http://www.verisign.com/</a> 的非安全连接，另一个则展示了到 <a href="http://www.verisign.com/">http://www.verisign.com/</a> 的安全 SSL 连接。两者都是连接到服务器并下载其主页。它们没有进行任何安全检查，而且库中的所有设置都是默认值 —— 作为本文的一部分，应该只将这些用于教学目的。</p>
<p>在任何支持的平台上，源代码的编译都应该是非常容易的，不过我建议您使用最新版本的 OpenSSL。</p>
]]></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>cJson 学习笔记</title>
    <url>/2019/08/02/cJson%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="cJSON-的使用方法"><a href="#cJSON-的使用方法" class="headerlink" title="cJSON 的使用方法"></a>cJSON 的使用方法</h1><h2 id="一-JSON-格式简述"><a href="#一-JSON-格式简述" class="headerlink" title="一.JSON 格式简述"></a>一.JSON 格式简述</h2><blockquote>
<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写，同时也易于机器解析和生成。它基于JavaScript（Standard ECMA-262 3rd Edition - December 1999）的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使JSON成为理想的数据交换语言。（来自“开源中国”资料）。</p>
</blockquote>
<p>cJSON从名字可知，整个项目都是以极标准的C来写的，意思说，可以跨各种平台使用了。cJSON是一个超轻巧，携带方便，单文件，简单的可以作为ANSI-C标准的JSON解析器。</p>
 <a id="more"></a>

<p>cJSON 开源项目位置：<a href="https://github.com/DaveGamble/cJSON">DaveGamble/cJSON</a><br>更加详细的解释和示例请查看<a href="http://www.json.org/">主页</a>。</p>
<p>cJSON，目前来说，就只有两个文件，一个cJSON.c 一个cJSON.h文件。使用的时候，自己创建好一个main.c文件后，将头文件include进去。<br>如果是在linux pc上，请使用以下命令进行编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc  *.c  cJSON.c    -lm</span><br></pre></td></tr></table></figure>
<p>记得编译时末尾链接libm库。<br></br></p>
<h2 id="二-JSON-结构体"><a href="#二-JSON-结构体" class="headerlink" title="二.JSON 结构体"></a>二.JSON 结构体</h2><p>熟悉使用cJSON库函数可从cJSON结构体入手，cJSON结构体如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">cJSON</span> *<span class="title">next</span>,*<span class="title">prev</span>;</span>   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">cJSON</span> *<span class="title">child</span>;</span>   </span><br><span class="line">    <span class="keyword">int</span>     type;   </span><br><span class="line">    <span class="keyword">char</span>    *valuestring;   </span><br><span class="line">    <span class="keyword">int</span>     valueint;  </span><br><span class="line">    <span class="keyword">double</span>  valuedouble;   </span><br><span class="line">    <span class="keyword">char</span>    *<span class="built_in">string</span>;   </span><br><span class="line">&#125; cJSON;</span><br></pre></td></tr></table></figure>


<p><strong>几点说明</strong></p>
<ol>
<li>cJOSN结构体为一个双向列表，并可通过child指针访问下一层。</li>
<li>type变量决定数据项类型（键的类型），数据项可以是字符串可以是整形，也可以是浮点型。如果是整形值的话可从valueint，如果是浮点型的话可从valuedouble取出，以此类推。</li>
<li>string可理解为节点的名称，综合此处的第2点可理解为“键”的名称。</li>
</ol>
<p>cJSON作为Json格式的解析库，其主要功能无非就是构建和解析Json格式了，用途就是一端将要发送的数据已cjson形式封装，然后发送，另一端收到此数据后，还是按cjson形式解析，就得到想要的数据了。<br></br></p>
<h2 id="三-封装成json形式"><a href="#三-封装成json形式" class="headerlink" title="三.封装成json形式"></a>三.封装成json形式</h2><p>接下来直接通过几个例子代码，一一解析。</p>
<p>第一，创建json数据串。这数据串，可能是对象，也可能是数组，也可能是它们的各种组合，其中再加上一些键值对。有一点要先说明：它们的组合，符合父子继承格式－－这也是json数据串的特点。<br></br></p>
<p><strong>&lt;1&gt;</strong> 创建一个对象，并向这个对象里添加字符串和整型键值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cJSON * usr;</span><br><span class="line">        cJSON *arry;</span><br><span class="line"> </span><br><span class="line">        usr=cJSON_CreateObject();   <span class="comment">//创建根数据对象</span></span><br><span class="line">        cJSON_AddStringToObject(usr,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;fengxin&quot;</span>);  <span class="comment">//加入键值，加字符串</span></span><br><span class="line">        cJSON_AddStringToObject(usr,<span class="string">&quot;passwd&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        cJSON_AddNumberToObject(usr,<span class="string">&quot;num&quot;</span>,<span class="number">1</span>);  <span class="comment">//加整数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> *out = cJSON_Print(usr);   <span class="comment">//将json形式打印成正常字符串形式</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,out);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 释放内存  </span></span><br><span class="line">        cJSON_Delete(usr);  </span><br><span class="line">        <span class="built_in">free</span>(out); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;:	&quot;fengxin&quot;,</span><br><span class="line">	&quot;passwd&quot;:	&quot;123&quot;,</span><br><span class="line">	&quot;num&quot;:	1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>若干说明</strong></p>
<ol>
<li>cJSON_CreateObject函数可创建一个根数据项，之后便可向该根数据项中添加string或int等内容,返回的是一个 cJSON的指针，注意，在这个指针用完了以后，需要手工调用 cJSON_Delete(root); 进行内存回收。</li>
<li>cJSON_AddNumberToObject向节点中添加子节点，例如此处添加name节点，节点值为字符串”fengxin”</li>
<li>需要注意的是  json 格式的数据，虽然也是一个字符串的样子，但这个时候还是无法当成普通的字符串进行使用，需要调用 cJSON_PrintUnformatted(root) 或者 cJSON_Print(root);来将json对象转换成普通的字符串，并且都是以该json对象的根为基点。两个API的区别即是：一个是没有格式的：也就是转换出的字符串中间不会有”\n” “\t”之类的东西存在，而cJSON_Print(root);打印出来是人看起来很舒服的格式。</li>
<li>因为函数内部封装有malloc函数，所以使用free函数释放被out占用的内存空间</br>
</br>

</li>
</ol>
<p><strong>&lt;2&gt;</strong> 创建一个数组，并向数组添加一个字符串和一个数字：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_js</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cJSON *root, *js_body;</span><br><span class="line">    root = cJSON_CreateArray();</span><br><span class="line">    cJSON_AddItemToArray(root, cJSON_CreateString(<span class="string">&quot;Hello world&quot;</span>));</span><br><span class="line">    cJSON_AddItemToArray(root, cJSON_CreateNumber(<span class="number">10</span>)); </span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//      char *s = cJSON_Print(root);</span></span><br><span class="line">        <span class="keyword">char</span> *s = cJSON_PrintUnformatted(root);</span><br><span class="line">        <span class="keyword">if</span>(s)&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot; %s \n&quot;</span>,s);</span><br><span class="line">            <span class="built_in">free</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">        cJSON_Delete(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    create_js();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;Hello world&quot;,10]</span><br></pre></td></tr></table></figure>
</br>
</br>

<p>**&lt;3&gt;**对象里面包括一个数组，数组里面包括对象，对象里面再添加一个字符串和一个数字：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_js</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cJSON *root, *js_body, *js_list;</span><br><span class="line">    root = cJSON_CreateObject();</span><br><span class="line">    cJSON_AddItemToObject(root,<span class="string">&quot;body&quot;</span>, js_body = cJSON_CreateArray());</span><br><span class="line">    cJSON_AddItemToArray(js_body, js_list = cJSON_CreateObject());</span><br><span class="line">    cJSON_AddStringToObject(js_list,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;fengxin&quot;</span>);</span><br><span class="line">    cJSON_AddNumberToObject(js_list,<span class="string">&quot;status&quot;</span>,<span class="number">100</span>);</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//        char *s = cJSON_Print(root);</span></span><br><span class="line">        <span class="keyword">char</span> *s = cJSON_PrintUnformatted(root);</span><br><span class="line">        <span class="keyword">if</span>(s)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %s \n&quot;</span>,s);</span><br><span class="line">            <span class="built_in">free</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">        cJSON_Delete(root);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    create_js();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;body&quot;:[&#123;&quot;name&quot;:&quot;fengxin&quot;,&quot;status&quot;:100&#125;]&#125;</span><br></pre></td></tr></table></figure>
</br>
</br>

<p>**&lt;4&gt;**其他组合就依次类推，只要搞清楚父子关系即可。随便嵌套随便玩。不再贴了。<br></br></p>
<h2 id="四-解析-json-得到数据"><a href="#四-解析-json-得到数据" class="headerlink" title="四.解析 json 得到数据"></a>四.解析 json 得到数据</h2><p>解析数据包的过程和组装数据包的过程相反<br><strong>处理流程：</strong></p>
<p><strong>&lt;1&gt;</strong> 先将普通的json串处理成json对象，也就是所谓的创建json root的过程，只有一行代码即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cJSON *root;</span><br><span class="line">root = cJSON_Parse(js_string);</span><br></pre></td></tr></table></figure>

<p><strong>&lt;2&gt;</strong> 开始拿关键字，但如果关键字还有父层或者祖层，那就需要先从父层开拿，所谓剥洋葱是也！先说没有父层的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">out=&#123;\<span class="string">&quot;name\&quot;:\&quot;fengxin\&quot;,\&quot;passwd\&quot;:\&quot;123\&quot;,\&quot;num\&quot;:1&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="string">#include&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="string">#include&lt;string.h&gt;</span></span><br><span class="line"><span class="string">#include&quot;</span>cJSON.h<span class="string">&quot;</span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    cJSON *json,*json_name,*json_passwd,*json_num;</span></span><br><span class="line"><span class="string">    char* out=&quot;</span>&#123;\<span class="string">&quot;name\&quot;:\&quot;fengxin\&quot;,\&quot;passwd\&quot;:\&quot;123\&quot;,\&quot;num\&quot;:1&#125;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    json = cJSON_Parse(out); <span class="comment">//解析成json形式</span></span><br><span class="line">    json_name = cJSON_GetObjectItem( json , <span class="string">&quot;name&quot;</span> );  <span class="comment">//获取键值内容</span></span><br><span class="line">    json_passwd = cJSON_GetObjectItem( json , <span class="string">&quot;passwd&quot;</span> );</span><br><span class="line">    json_num = cJSON_GetObjectItem( json , <span class="string">&quot;num&quot;</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name:%s,passwd:%s,num:%d\n&quot;</span>,json_name-&gt;valuestring,json_passwd-&gt;valuestring,json_num-&gt;valueint);</span><br><span class="line"> </span><br><span class="line">    cJSON_Delete(json);  <span class="comment">//释放内存 </span></span><br><span class="line">    <span class="built_in">free</span>(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>显示结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name:fengxin,passwd:123,num:1</span><br></pre></td></tr></table></figure>
<p>需要注意的是： 上面的type 已经在cJSON.h里面定义好了，有自己的意义。如果是在严格的场所，应该先判定该 item的type，然后再考虑去拿值。而如果有父层的话，无非就是接着向下拿就是了。</p>
</br>
**<3>** 处理这串数据：

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">out=&#123;\<span class="string">&quot;list\&quot;:&#123;\&quot;name\&quot;:\&quot;xiao hong\&quot;,\&quot;age\&quot;:10&#125;,\&quot;other\&quot;:&#123;\&quot;name\&quot;:\&quot;hua hua\&quot;&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">char *s = &quot;</span>&#123;\<span class="string">&quot;list\&quot;:&#123;\&quot;name\&quot;:\&quot;xiao hong\&quot;,\&quot;age\&quot;:10&#125;,\&quot;other\&quot;:&#123;\&quot;name\&quot;:\&quot;hua hua\&quot;&#125;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">cJSON *root = cJSON_Parse(s);</span><br><span class="line"><span class="keyword">if</span>(!root) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get root faild !\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> cJSON *js_list = cJSON_GetObjectItem(root, <span class="string">&quot;list&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!js_list) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no list!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;list type is %d\n&quot;</span>,js_list-&gt;type);</span><br><span class="line"></span><br><span class="line">cJSON *name = cJSON_GetObjectItem(js_list, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!name) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No name !\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name type is %d\n&quot;</span>,name-&gt;type);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name is %s\n&quot;</span>,name-&gt;valuestring);</span><br><span class="line"></span><br><span class="line">cJSON *age = cJSON_GetObjectItem(js_list, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!age) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no age!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;age type is %d\n&quot;</span>, age-&gt;type);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;age is %d\n&quot;</span>,age-&gt;valueint);</span><br><span class="line"></span><br><span class="line">cJSON *js_other = cJSON_GetObjectItem(root, <span class="string">&quot;other&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!js_other) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no list!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;list type is %d\n&quot;</span>,js_other-&gt;type);</span><br><span class="line"></span><br><span class="line">cJSON *js_name = cJSON_GetObjectItem(js_other, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!js_name) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No name !\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name type is %d\n&quot;</span>,js_name-&gt;type);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name is %s\n&quot;</span>,js_name-&gt;valuestring);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(root) &#123;</span><br><span class="line">    cJSON_Delete(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>打印结果:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list type is 6</span><br><span class="line">name type is 4</span><br><span class="line">name is xiao hong</span><br><span class="line">age type is 3</span><br><span class="line">age is 10</span><br><span class="line">list type is 6</span><br><span class="line">name type is 4</span><br><span class="line">name is hua hua</span><br></pre></td></tr></table></figure>
<p>所谓子子孙孙无穷尽也，按照上面那个方法推下去即可。<br></br><br>**&lt;4&gt;** json里数组怎么取？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;\<span class="string">&quot;list\&quot;:[\&quot;name1\&quot;,\&quot;name2\&quot;]&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main(int argc, char **argv)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">char *s = &quot;</span>&#123;\<span class="string">&quot;list\&quot;:[\&quot;name1\&quot;,\&quot;name2\&quot;]&#125;&quot;</span>;</span><br><span class="line">cJSON *root = cJSON_Parse(s);</span><br><span class="line"><span class="keyword">if</span>(!root) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get root faild !\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cJSON *js_list = cJSON_GetObjectItem(root, <span class="string">&quot;list&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!js_list)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no list!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> array_size = cJSON_GetArraySize(js_list);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array size is %d\n&quot;</span>,array_size);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">cJSON *item;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; array_size; i++) &#123;</span><br><span class="line">    item = cJSON_GetArrayItem(js_list, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;item type is %d\n&quot;</span>,item-&gt;type);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,item-&gt;valuestring);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(root)</span><br><span class="line">    cJSON_Delete(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>
**<5>** 如果json数组里面又搞了对象怎么办？ 

<p>不怕搞对象，就怕这样搞对象？ 无他，就是稍微复杂了一点，全是体力活儿：</p>
<ol>
<li>既然是数组里面，那肯定要先测量数组的大小，然后根据大小循环拿；</li>
<li>拿到一个数组项，然后把这个项先转化成普通的json字符串，也就是 char *s 能接受的。</li>
<li>再次将这个json字符串，转化成一个json对象。</li>
<li>按照拿普通对象中的东西那样开干就行了。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;\<span class="string">&quot;list\&quot;:[&#123;\&quot;name\&quot;:\&quot;xiao hong\&quot;,\&quot;age\&quot;:10&#125;,&#123;\&quot;name\&quot;:\&quot;hua hua\&quot;,\&quot;age\&quot;:11&#125;]&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">list 是一个数组，数组里面有两个对象，那么代码如下</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main(int argc, char **argv)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">char *s = &quot;</span>&#123;\<span class="string">&quot;list\&quot;:[&#123;\&quot;name\&quot;:\&quot;xiao hong\&quot;,\&quot;age\&quot;:10&#125;,&#123;\&quot;name\&quot;:\&quot;hua hua\&quot;,\&quot;age\&quot;:11&#125;]&#125;&quot;</span>;</span><br><span class="line">cJSON *root = cJSON_Parse(s);</span><br><span class="line"><span class="keyword">if</span>(!root) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get root faild !\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cJSON *js_list = cJSON_GetObjectItem(root, <span class="string">&quot;list&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!js_list)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no list!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> array_size = cJSON_GetArraySize(js_list);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array size is %d\n&quot;</span>,array_size);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">cJSON *item,*it, *js_name, *js_age;</span><br><span class="line"><span class="keyword">char</span> *p  = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; array_size; i++) &#123;</span><br><span class="line">    item = cJSON_GetArrayItem(js_list, i);</span><br><span class="line">    <span class="keyword">if</span>(!item) &#123;</span><br><span class="line">        <span class="comment">//TODO...</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = cJSON_PrintUnformatted(item);</span><br><span class="line">    it = cJSON_Parse(p);</span><br><span class="line">    <span class="keyword">if</span>(!it)</span><br><span class="line">        <span class="keyword">continue</span> ;</span><br><span class="line">    js_name = cJSON_GetObjectItem(it, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name is %s\n&quot;</span>,js_name-&gt;valuestring);</span><br><span class="line">    js_age = cJSON_GetObjectItem(it, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age is %d\n&quot;</span>,js_age-&gt;valueint);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(root)</span><br><span class="line">    cJSON_Delete(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>人生信条</title>
    <url>/2019/07/18/%E4%BA%BA%E7%94%9F%E4%BF%A1%E6%9D%A1/</url>
    <content><![CDATA[<h1 id="人生信条（持续更新）"><a href="#人生信条（持续更新）" class="headerlink" title="人生信条（持续更新）"></a>人生信条（持续更新）</h1><ul>
<li><p>什么都无法舍弃的人，什么都改变不了。</p>
<div style="text-align: right">——阿尔敏《进击的巨人》</div>
</li>
<li><p>谎言的代价是什么？并非是我们会把谎言误认为真相。真正危险的是，我们听多了谎言，便不再能分辨出真相。那时我们能做什么，除了放弃对真理的信仰，满足于谎言堆砌的故事，我们还剩下什么？ </p>
<div style="text-align: right">——《切尔诺贝利》</div>​​​​
</li>
<li><p>我們知道他們在說謊，他們也知道自己在說謊，他們也知道我們知道他們在說謊，我們也知道他們知道我們知道他們說謊，但是他們依然在說謊。</p>
<div style="text-align: right">——亞歷山大·索爾仁尼琴 ​ </div> 
</li>
<li><p>不自由，毋宁死。</p>
<div style="text-align: right">——帕特里克·亨利(Patrick Henry,1736～1799) ​ </div> 
</li>
<li><p>若批评不自由，则赞美无意义。</p>
<div style="text-align: right">——加隆·德·博马舍（Pierre-Augustin Caron de Beaumarchais，1732.1.24—1799.5.18）《费加罗的婚礼》 ​ </div> </li>
</ul>
]]></content>
      <tags>
        <tag>Personal</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT协议</title>
    <url>/2019/07/12/MQTT%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="MQTT协议"><a href="#MQTT协议" class="headerlink" title="MQTT协议"></a>MQTT协议</h1><h2 id="MQTT协议的概念"><a href="#MQTT协议的概念" class="headerlink" title="MQTT协议的概念"></a>MQTT协议的概念</h2><blockquote>
<p>MQTT协议，全称 <em>Message Queue Telemetry Transport消息队列遥测传输协议</em> ，是一种基于发布/订阅的轻量级通讯协议<br>适用于条件较差的网络环境，如：网络延迟高、带宽低、通信讯号不稳定等情况。</p>
</blockquote>
<h2 id="MQTT协议的特点"><a href="#MQTT协议的特点" class="headerlink" title="MQTT协议的特点"></a>MQTT协议的特点</h2><ul>
<li><p>构建于TCP/IP协议之上</p>
<blockquote>
<p>TCP/IP参考模型可分为四层：应用层、传输层、网络层、链路层。TCP、UDP协议均属于传输层，MQTT运行与TCP之上，属于应用层协议，只要支持TCP/IP协议栈的地方都可应用MQTT。</p>
</blockquote>
<a id="more"></a>
</li>
<li><p>基于C-S架构的消息发布/订阅，提供一对多的消息发布，作为客户端之间的中间介质，解除应用程序的耦合。</p>
</li>
<li><p>对负载内容屏蔽的消息传输</p>
</li>
<li><p>使用TCP连接进行数据推送</p>
</li>
<li><p>三种消息发布QoS</p>
</li>
</ul>
<blockquote>
<p>QoS 0：至多一次。服务器只推送1次，至于客户端是否收到，收到的消息是否正确，数据是否有所丢失，都不管。<br>QoS 1：至少一次。客户端收到服务器的推送后要回复一个PUBACK告诉服务器已收到，否则服务器会认为Client未收到推送，隔一段时间后重新发送，直到对方回复PUBACK。<br>QoS 2：只发一次。保证数据包到达目的地，且不会出现重复。服务器发送数据包，客户端接收后回复PUBREC（收到发布消息）报文，服务器存储PUBREC中的报文标识符，发送PUBREL（释放发布消息）。</p>
</blockquote>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4x7jsup5wj30se13m0vy.jpg"></p>
<h2 id="MQTT协议规范"><a href="#MQTT协议规范" class="headerlink" title="MQTT协议规范"></a>MQTT协议规范</h2><h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p><strong>表1</strong> 报文类型值</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">值</th>
<th align="left">流向</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CONNECT</td>
<td align="left">1</td>
<td align="left">C -&gt; S</td>
<td align="left">客户端连接请求</td>
</tr>
<tr>
<td align="left">CONNACK</td>
<td align="left">2</td>
<td align="left">S -&gt; C</td>
<td align="left">服务端确认连接</td>
</tr>
<tr>
<td align="left">PUBLISH</td>
<td align="left">3</td>
<td align="left">C &lt;-&gt; S</td>
<td align="left">发布消息</td>
</tr>
<tr>
<td align="left">PUBACK</td>
<td align="left">4</td>
<td align="left">C &lt;-&gt; S</td>
<td align="left">QoS1消息确认</td>
</tr>
<tr>
<td align="left">PUBREC</td>
<td align="left">5</td>
<td align="left">C &lt;-&gt; S</td>
<td align="left">QoS2收到消息（保证传输step1）</td>
</tr>
<tr>
<td align="left">PUBREL</td>
<td align="left">6</td>
<td align="left">C &lt;-&gt; S</td>
<td align="left">QoS2释放消息（保证传输step2）</td>
</tr>
<tr>
<td align="left">PUBCOMP</td>
<td align="left">7</td>
<td align="left">C &lt;-&gt; S</td>
<td align="left">QoS2完成消息（保证传输step3）</td>
</tr>
<tr>
<td align="left">SUBSCRIBE</td>
<td align="left">8</td>
<td align="left">C -&gt; S</td>
<td align="left">订阅消息</td>
</tr>
<tr>
<td align="left">SUBACK</td>
<td align="left">9</td>
<td align="left">S -&gt; C</td>
<td align="left">订阅确认</td>
</tr>
<tr>
<td align="left">UNSUBSCRIBE</td>
<td align="left">10</td>
<td align="left">C -&gt; S</td>
<td align="left">取消订阅</td>
</tr>
<tr>
<td align="left">UNSUBACK</td>
<td align="left">11</td>
<td align="left">S -&gt; C</td>
<td align="left">取消订阅确认</td>
</tr>
<tr>
<td align="left">PINGREQ</td>
<td align="left">12</td>
<td align="left">C -&gt; S</td>
<td align="left">连接保活请求</td>
</tr>
<tr>
<td align="left">PINGRESP</td>
<td align="left">13</td>
<td align="left">S -&gt; C</td>
<td align="left">保活回应</td>
</tr>
<tr>
<td align="left">DISCONNECT</td>
<td align="left">14</td>
<td align="left">C -&gt; S</td>
<td align="left">断开连接</td>
</tr>
</tbody></table>
<p><strong>注：</strong> 值为0和15表示保留</p>
<h3 id="MQTT控制报文"><a href="#MQTT控制报文" class="headerlink" title="MQTT控制报文"></a>MQTT控制报文</h3><p>MQ控制报文由三部分组成：固定报头+可变报头+有效载荷</p>
<p><strong>表2：</strong>报文格式</p>
<table>
<thead>
<tr>
<th>↓</th>
<th>↓</th>
</tr>
</thead>
<tbody><tr>
<td>固定报头</td>
<td>所有控制报文都包含</td>
</tr>
<tr>
<td>可变报头</td>
<td>部分报文包含</td>
</tr>
<tr>
<td>有效载荷</td>
<td>部分报文包含</td>
</tr>
</tbody></table>
<h4 id="固定报头"><a href="#固定报头" class="headerlink" title="固定报头"></a>固定报头</h4><p><strong>表3：</strong> 固定报头格式</p>
<table>
    <tr>
        <td>Bit</td> 
        <td>7</td>
        <td>6</td> 
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
   </tr>
    <tr>
        <td>Byte 1</td>
        <td colspan="4">MQTT控制报文类型</td>
        <td colspan="4">控制报文类型的标志位</td>
    </tr>
    <tr>
        <td>Byte 2</td>
        <td colspan="8" align="center">剩余长度</td>
    </tr>
</table>

<p><strong>注：</strong>固定报头Byte1的高四位是表1中消息类型的值，以二进制数表示。低四位是报文类型的标志位。</p>
<h4 id="可变报头"><a href="#可变报头" class="headerlink" title="可变报头"></a>可变报头</h4><p>可变报头在固定报头和负载之间。可变报头的报文标识符字段存在于在多个类型的报文里。</p>
<blockquote>
<p>很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是QoS &gt; 0时的PUBLISH，PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCRIBE，UNSUBACK。SUBSCRIBE，UNSUBSCRIBE和PUBLISH（QoS大于0）控制报文必须包含一个非零的16位报文标识符。客户端每次发送一个新的这些类型的报文时都必须分配一个当前未使用的报文标识符。如果一个客户端要重发这个特殊的控制报文，在随后重发那个报文时，它必须使用相同的标识符。当客户端处理完这个报文对应的确认后，这个报文标识符就释放可重用。发送一个QoS 0的PUBLISH报文时，相同的条件也适用于服务端。</p>
</blockquote>
<p>即uuid，标识会话，当标识符一致时表示在同一会话中。</p>
<h4 id="有效载荷"><a href="#有效载荷" class="headerlink" title="有效载荷"></a>有效载荷</h4><p>-&gt;Body.</p>
<h1 id="Wireshark抓包"><a href="#Wireshark抓包" class="headerlink" title="Wireshark抓包"></a>Wireshark抓包</h1><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4x7qw0kdfj31ht0u0avb.jpg"></p>
<p>从报文可看到，Client与MQ Server首先做三次TCP握手连接，建立连接成功后，Client给MQ服务器发送connect登录请求，服务器回应一个ACK表示登录成功。协议消息中可看出，登录请求报文的QoS=0，即只推送一次消息。</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4x7rqvccfj31hk0u0hbz.jpg"></p>
<p>客户端向MQ服务器发布消息，发送publish报文，可从报文信息中看到，QoS=1，即至少发送1次，服务器收到后回复Publish Ack确认报文，否则一段时间后发布方没收到确认将进行重传。另外，报文中可看出MQTT固定报文头0x32 = 00110010,3表示消息类型为Publish（表1能查到）。此处Publish报文发布新Portal消息，AC程序主动发送的无感知报文。</p>
<hr>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4x7sfyqb9j31fw0u0x07.jpg"><br><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4x7st93sjj31lx0u0tq9.jpg"></p>
<p>订阅请求报文Subscribe Request。上图1报文为客户端向MQ服务器请求订阅YS保活Topic消息。图2为二级AC上线后的订阅请求，可看到MQTT报文有效载荷包含二级AC的MAC地址。收到消息后对端回复Subscribe Ack，QoS=1。</p>
]]></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>2019.05-2019.06 学习总结</title>
    <url>/2019/06/04/2019.05-2019.06%20%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div align='center' ><font size='70'>2019.05-2019.06 学习总结</font></div>

<hr>
<p><span id="toc"></span></p>
<p>[TOC]</p>
<hr>
<h2 id="阶段一：基础知识回顾"><a href="#阶段一：基础知识回顾" class="headerlink" title="阶段一：基础知识回顾"></a>阶段一：基础知识回顾</h2><h3 id="gt-C语言基础语法回顾："><a href="#gt-C语言基础语法回顾：" class="headerlink" title="&gt; C语言基础语法回顾："></a>&gt; C语言基础语法回顾：</h3><blockquote>
<p>变更代码习惯，转语言——“倒时差”</p>
</blockquote>
<h4 id="gt-相关留存资料："><a href="#gt-相关留存资料：" class="headerlink" title="&gt; 相关留存资料："></a>&gt; 相关留存资料：</h4><div class="pdfobject-container" data-target="https://drive.google.com/file/d/1644m_lW65hk8UBkXqBdFv61zy-y17bBq/preview" data-height="500px"></div>

<a id="more"></a>

<h3 id="gt-计算机网络基础知识回顾："><a href="#gt-计算机网络基础知识回顾：" class="headerlink" title="&gt; 计算机网络基础知识回顾："></a>&gt; 计算机网络基础知识回顾：</h3><blockquote>
<p>回顾计算机网络结构，重点回顾计算网络网络层传输层应用层的工作相关知识，并进行总结。</p>
</blockquote>
<h4 id="gt-相关留存资料：-1"><a href="#gt-相关留存资料：-1" class="headerlink" title="&gt; 相关留存资料："></a>&gt; 相关留存资料：</h4><div class="pdfobject-container" data-target="https://drive.google.com/file/d/1MMx2EWgg-tMt0YcJeQkaBbQkAXvVYVJT/preview" data-height="500px"></div>

<h3 id="gt-Unix环境高级编程："><a href="#gt-Unix环境高级编程：" class="headerlink" title="&gt; Unix环境高级编程："></a>&gt; Unix环境高级编程：</h3><blockquote>
<p>学习网络编程，Linux环境下C语言编程，学习Socket编程相关知识。</p>
</blockquote>
<h4 id="gt-相关留存资料：-2"><a href="#gt-相关留存资料：-2" class="headerlink" title="&gt; 相关留存资料："></a>&gt; 相关留存资料：</h4><blockquote>
<p>Github Repository：    <a href="https://github.com/liuxing1Tec/C_Learning/tree/master/SOCKET%E7%BC%96%E7%A8%8B"><strong>C_Learning/SOCKET编程</strong></a></p>
</blockquote>
<h2 id="阶段二：网络编程实战"><a href="#阶段二：网络编程实战" class="headerlink" title="阶段二：网络编程实战"></a>阶段二：网络编程实战</h2><h3 id="gt-网络聊天客户端的开发："><a href="#gt-网络聊天客户端的开发：" class="headerlink" title="&gt; 网络聊天客户端的开发："></a>&gt; 网络聊天客户端的开发：</h3><blockquote>
<p>Socket编程实战。</p>
</blockquote>
<h4 id="gt-相关留存资料：-3"><a href="#gt-相关留存资料：-3" class="headerlink" title="&gt; 相关留存资料："></a>&gt; 相关留存资料：</h4><blockquote>
<p>Github Repository：    <a href="https://github.com/liuxing1Tec/Unix_chatroom"><strong>Unix_chatroom</strong></a></p>
</blockquote>
<h3 id="gt-网络开发复盘："><a href="#gt-网络开发复盘：" class="headerlink" title="&gt; 网络开发复盘："></a>&gt; 网络开发复盘：</h3><blockquote>
<p>开发流程总结。</p>
</blockquote>
<h4 id="gt-相关留存资料：-4"><a href="#gt-相关留存资料：-4" class="headerlink" title="&gt; 相关留存资料："></a>&gt; 相关留存资料：</h4><blockquote>
<p>客户端开发流程以源文件：    <a href="https://github.com/liuxing1Tec/C_Learning/blob/master/SOCKET%E7%BC%96%E7%A8%8B/select_echo/src/echocli.c"><strong>SOCKET编程/select_echo/src/echocli.c</strong></a>，为例<br>服务器端开发流程以源文件：    <a href="https://github.com/liuxing1Tec/C_Learning/blob/master/SOCKET%E7%BC%96%E7%A8%8B/select_echo/src/echosrv.c"><strong>SOCKET编程/select_echo/src/echosrv.c</strong></a>，为例</p>
</blockquote>
<h2 id="阶段三：补充性学习：查漏补缺"><a href="#阶段三：补充性学习：查漏补缺" class="headerlink" title="阶段三：补充性学习：查漏补缺"></a>阶段三：补充性学习：查漏补缺</h2><h3 id="gt-C语言深入学习："><a href="#gt-C语言深入学习：" class="headerlink" title="&gt; C语言深入学习："></a>&gt; C语言深入学习：</h3><blockquote>
<p>C语言底层知识总结（堆栈、结构体、作用域、malloc()以及free()机制等）。</p>
</blockquote>
<h4 id="gt-相关留存资料：-5"><a href="#gt-相关留存资料：-5" class="headerlink" title="&gt; 相关留存资料："></a>&gt; 相关留存资料：</h4><div class="pdfobject-container" data-target="https://drive.google.com/file/d/1hC78fv6IeNWt6U2EEI7muiUL-xUUW58c/preview" data-height="500px"></div>

<h3 id="gt-项目开发流程深入学习："><a href="#gt-项目开发流程深入学习：" class="headerlink" title="&gt; 项目开发流程深入学习："></a>&gt; 项目开发流程深入学习：</h3><blockquote>
<p>项目开发流程总结（C项目管理、GCC、GDB等）。</p>
</blockquote>
<h4 id="gt-相关留存资料：-6"><a href="#gt-相关留存资料：-6" class="headerlink" title="&gt; 相关留存资料："></a>&gt; 相关留存资料：</h4><div class="pdfobject-container" data-target="https://drive.google.com/file/d/1HWIYnT_FpXFvE0wjUFZTvritoOo9IJVY/preview" data-height="500px"></div>

<h3 id="gt-AC-AP网络知识学习："><a href="#gt-AC-AP网络知识学习：" class="headerlink" title="&gt; AC/AP网络知识学习："></a>&gt; AC/AP网络知识学习：</h3><blockquote>
<p>AC/AP相关知识了解。</p>
</blockquote>
<h4 id="gt-相关留存资料：-7"><a href="#gt-相关留存资料：-7" class="headerlink" title="&gt; 相关留存资料："></a>&gt; 相关留存资料：</h4><div class="pdfobject-container" data-target="https://drive.google.com/file/d/1ClhF03htEg2MFs4S_tFv6znQeFdad3fA/preview" data-height="500px"></div>

]]></content>
      <tags>
        <tag>Personal</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 学习笔记</title>
    <url>/2019/05/27/Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&#x27;XXX&#x27;</span></span><br><span class="line">git config --global user.email <span class="string">&#x27;XXX&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="创建本地库"><a href="#创建本地库" class="headerlink" title="创建本地库"></a>创建本地库</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkidir learngit     //自定义文件夹</span><br><span class="line"><span class="built_in">cd</span> learngit</span><br><span class="line">touch test.md       //创建test.md文件</span><br><span class="line"><span class="built_in">pwd</span>                 //显示当前目录</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="常用-CRT"><a href="#常用-CRT" class="headerlink" title="常用 CRT"></a>常用 CRT</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git init                    //初始化代码仓库</span><br><span class="line">git add learngit.txt        //把所有要提交的文件修改放到暂存区</span><br><span class="line">git commit -m <span class="string">&#x27;add a file&#x27;</span>  //把暂存区的所有内容提交到当前分支</span><br><span class="line">git status                  //查看工作区状态</span><br><span class="line">git diff                    //查看文件修改内容</span><br><span class="line">git <span class="built_in">log</span>                     //查看提交历史</span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline    //单行显示</span><br><span class="line">git reset --hard HEAD^      //回退到上一个版本，其中（HEAD^^(上上版本),HEAD~100(往上100个版本)）</span><br><span class="line">commit id                   //(版本号) 可回到指定版本</span><br><span class="line">git reflog                  //查看历史命令</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中说明<br>工作区（Working Directory）<br>版本库（Repository） #.git<br>stage(index) 暂存区<br>master Git自动创建的分支<br>HEAD 指针</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git diff HEAD -- &lt;file&gt;     //查看工作区和版本库里最新版本的区别</span><br><span class="line">git checkout -- &lt;file&gt;      //用版本库的版本替换工作区的版本，无论是工作区的修改还是删除，都可以<span class="string">&#x27;一键还原&#x27;</span></span><br><span class="line">git reset HEAD &lt;file&gt;       //把暂存区的修改撤销掉，重新放回工作区。</span><br><span class="line">git rm &lt;file&gt;               //删除文件，若文件已提交到版本库，不用担心误删，但是只能恢复文件到最新版本</span><br></pre></td></tr></table></figure>

<h1 id="创建-SSH-Key，建立本地-Git-仓库和-GitHub-仓库之间的传输的秘钥"><a href="#创建-SSH-Key，建立本地-Git-仓库和-GitHub-仓库之间的传输的秘钥" class="headerlink" title="创建 SSH Key，建立本地 Git 仓库和 GitHub 仓库之间的传输的秘钥"></a>创建 SSH Key，建立本地 Git 仓库和 GitHub 仓库之间的传输的秘钥</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">//创建SSH Key</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&#x27;your_email&#x27;</span></span><br><span class="line">//关联本地仓库，远程库的名字为origin   </span><br><span class="line">git remote add origin git@github.com:username/repostery.git </span><br><span class="line">//第一次把当前分支master推送到远程</span><br><span class="line">//-u参数不但推送，而且将本地的分支和远程的分支关联起来</span><br><span class="line">git push -u origin master</span><br><span class="line">//把当前分支master推送到远程</span><br><span class="line">git push origin master</span><br><span class="line">//从远程库克隆一个到本地库</span><br><span class="line">git <span class="built_in">clone</span> git@github.com:username/repostery.git</span><br></pre></td></tr></table></figure>

<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b dev         //创建并切换分支</span><br><span class="line"><span class="comment">#相当于git branch dev 和git checkout dev </span></span><br><span class="line">git branch                  //查看当前分支，当前分支前有个*号</span><br><span class="line">git branch &lt;name&gt;           //创建分支</span><br><span class="line">git checkout &lt;name&gt;         //切换分支</span><br><span class="line">git merge &lt;name&gt;            //合并某个分支到当前分支</span><br><span class="line">git branch -d &lt;name&gt;        //删除分支</span><br><span class="line">git <span class="built_in">log</span> --graph             //查看分支合并图</span><br><span class="line">/* 禁用Fast forward合并dev分支*/</span><br><span class="line">git merge --no-ff -m <span class="string">&#x27;message&#x27;</span> dev</span><br><span class="line">git stash                   //隐藏当前工作现场，等恢复后继续工作</span><br><span class="line">git stash list              //查看stash记录</span><br><span class="line">git stash apply             //仅恢复现场，不删除stash内容</span><br><span class="line">git stash drop              //删除stash内容</span><br><span class="line">git stash pop               //恢复现场的同时删除stash内容</span><br><span class="line">git branch -D &lt;name&gt;        //强行删除某个未合并的分支</span><br><span class="line"><span class="comment">#开发新feature最好新建一个分支</span></span><br><span class="line">git remote                  //查看远程仓库</span><br><span class="line">git remote -v               //查看远程库详细信息</span><br><span class="line">git pull                    //抓取远程提交</span><br><span class="line">/* 在本地创建和远程分支对应的分支*/</span><br><span class="line">git checkout -b branch-name origin/branch-name</span><br><span class="line">/* 建立本地分支和远程分支的关联*/</span><br><span class="line">git branch --set-upstream branch-name origin/branch-name</span><br></pre></td></tr></table></figure>

<h1 id="其他—标签"><a href="#其他—标签" class="headerlink" title="其他—标签"></a>其他—标签</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag v1.0                    //给当前分支最新的commit打标签sh</span><br><span class="line">/* -a指定标签名，-m指定说明文字*/</span><br><span class="line">git tag -a v0.1 -m <span class="string">&#x27;version 0.1 released&#x27;</span> 3628164</span><br><span class="line">git tag -s &lt;tagname&gt; -m <span class="string">&#x27;blabla&#x27;</span>//可以用PGP签名标签</span><br><span class="line">git tag                         //查看所有标签</span><br><span class="line">git show v1.0                   //查看标签信息</span><br><span class="line">git tag -d v0.1                 //删除标签</span><br><span class="line">git push origin &lt;tagname&gt;       //推送某个标签到远程</span><br><span class="line">git push origin --tags          //推送所有尚未推送的本地标签</span><br></pre></td></tr></table></figure>

<h1 id="其他—出错解决方案"><a href="#其他—出错解决方案" class="headerlink" title="其他—出错解决方案"></a>其他—出错解决方案</h1><h2 id="1-git报错：’fatal-remote-origin-already-exists’怎么解决？"><a href="#1-git报错：’fatal-remote-origin-already-exists’怎么解决？" class="headerlink" title="1. git报错：’fatal:remote origin already exists’怎么解决？"></a>1. git报错：’fatal:remote origin already exists’怎么解决？</h2><p>只要两步：</p>
<p>1、先删除</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure>

<p>2、再次执行添加就可以了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote add origin XXX</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="2-如何删除GIT远程仓库项目的所有内容，重新提交所有内容"><a href="#2-如何删除GIT远程仓库项目的所有内容，重新提交所有内容" class="headerlink" title="2. 如何删除GIT远程仓库项目的所有内容，重新提交所有内容"></a>2. 如何删除GIT远程仓库项目的所有内容，重新提交所有内容</h2><blockquote>
<p>如果我们上传了一个项目到 <strong>git</strong> 并已经 <strong>commit</strong> 和 <strong>push</strong> 了所有内容，但是忘记搞 <strong>gitignore</strong> 文件，导致一些不想加入版本控制的文件，如IDE配置文件，编译文件，部署文件等，现在不知道怎么办了？<br>试一试如下命令：<br>首先配置好你的 <strong>.gitignore</strong> 文件，然后</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git rm -r --cache .</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;gitignore working&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-git取消本地修改"><a href="#3-git取消本地修改" class="headerlink" title="3. git取消本地修改"></a>3. git取消本地修改</h2><blockquote>
<p>如果在修改时发现修改错误，而要放弃本地修改时</p>
</blockquote>
<h3 id="1-gt-当未使用-git-add-缓存代码时。"><a href="#1-gt-当未使用-git-add-缓存代码时。" class="headerlink" title="1-&gt;当未使用 git add 缓存代码时。"></a>1-&gt;当未使用 <strong>git add</strong> 缓存代码时。</h3><p>可以使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -- filepathname //比如: git checkout -- readme.md</span><br></pre></td></tr></table></figure>

<p>不要忘记中间的 “–” ，不写就成了新增分支了！！<br>放弃所有的文件修改可以使用 </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout .  </span><br></pre></td></tr></table></figure>

<p>此命令用来放弃掉所有还没有加入到缓存区（就是 <strong>git add</strong> 命令）的修改：内容修改与整个文件删除。但是此命令不会删除掉刚新建的文件。因为刚新建的文件还没已有加入到 <strong>git</strong> 的管理系统中。所以对于 <strong>git</strong> 是未知的。自己手动删除就好了。</p>
<h3 id="2-gt-已经使用了-git-add-缓存了代码"><a href="#2-gt-已经使用了-git-add-缓存了代码" class="headerlink" title="2-&gt;已经使用了 git add 缓存了代码"></a>2-&gt;已经使用了 <strong>git add</strong> 缓存了代码</h3><p>可以使用  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset HEAD filepathname //比如: git reset HEAD readme.md</span><br></pre></td></tr></table></figure>

<p>来放弃指定文件的缓存，放弃所有的缓存可以使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset HEAD .</span><br></pre></td></tr></table></figure>

<p>此命令用来清除 <strong>git</strong> 对于文件修改的缓存。相当于撤销 <strong>git add</strong> 命令所在的工作。在使用本命令后，本地的修改并不会消失，而是回到了1的状态。继续用1中的操作，就可以放弃本地的修改。</p>
<h3 id="3-gt-已经用-git-commit-提交了代码。"><a href="#3-gt-已经用-git-commit-提交了代码。" class="headerlink" title="3-&gt;已经用 git commit 提交了代码。"></a>3-&gt;已经用 <strong>git commit</strong> 提交了代码。</h3><p>可以使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^ </span><br></pre></td></tr></table></figure>

<p>来回退到上一次commit的状态。此命令可以用来回退到任意版本：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --hard  commitid</span><br></pre></td></tr></table></figure>

<p>你可以使用 <strong>git log</strong> 命令来查看git的提交历史。<strong>git log</strong> 的输出如下,之一这里可以看到第一行就是 <strong>commitid</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit cf0d692e982d8e372a07aaa6901c395eec73e356 (HEAD -&gt; master)</span><br><span class="line">Author: toyflivver &lt;2440659688@qq.com&gt;</span><br><span class="line">Date: Thu Sep 28 14:07:14 2017 +0800</span><br><span class="line">多余的空行</span><br><span class="line">commit 14aa4d7ad4ac6fba59b4b8261d32e478e8cc99ff</span><br><span class="line">Author: toyflivver &lt;2440659688@qq.com&gt;</span><br><span class="line">Date: Thu Sep 28 14:06:44 2017 +0800</span><br><span class="line">正常的代码</span><br><span class="line">commit da3a95c84b6a92934ee30b6728e258bcda75f276</span><br><span class="line">Author: toyflivver &lt;2440659688@qq.com&gt;</span><br><span class="line">Date: Thu Sep 28 13:58:12 2017 +0800</span><br><span class="line">qbf</span><br><span class="line">commit 267466352079296520320991a75321485224d6c6</span><br><span class="line">Author: toyflivver &lt;2440659688@qq.com&gt;</span><br><span class="line">Date: Thu Sep 28 13:40:09 2017 +0800</span><br><span class="line">qbf</span><br></pre></td></tr></table></figure>

<p>可以看出现在的状态在 <strong>commitid</strong> 为 cf0d692e982d8e372a07aaa6901c395eec73e356 的提交上（有 HEAD -&gt; master 标记）。</p>
<h2 id="4-删除文件夹下的-所有-svn或者-git文件夹信息"><a href="#4-删除文件夹下的-所有-svn或者-git文件夹信息" class="headerlink" title="4. 删除文件夹下的 所有.svn或者.git文件夹信息"></a>4. 删除文件夹下的 所有.svn或者.git文件夹信息</h2><p>两步：</p>
<ol>
<li>cd到该文件夹</li>
<li>删除管理文件</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">//删除文件夹下的所有 .svn 文件</span><br><span class="line">find . -name <span class="string">&quot;.svn&quot;</span> | xargs rm -Rf</span><br><span class="line">//删除文件夹下的所有 .git 文件</span><br><span class="line">find . -name <span class="string">&quot;.git&quot;</span> | xargs rm -Rf</span><br></pre></td></tr></table></figure>

<h2 id="5-git-clone-反复需要输入用户名密码"><a href="#5-git-clone-反复需要输入用户名密码" class="headerlink" title="5. git clone 反复需要输入用户名密码"></a>5. git clone 反复需要输入用户名密码</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake 学习笔记</title>
    <url>/2019/05/24/cmake%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<ul>
<li>最大的Qt4程序群(KDE4)采用cmake作为构建系统</li>
<li>Qt4的python绑定(pyside)采用了cmake作为构建系统</li>
<li>开源的图像处理库 opencv 采用cmake 作为构建系统</li>
<li>…</li>
</ul>
<p>看来不学习一下cmake是不行了，一点一点来吧，找个最简单的C程序，慢慢复杂化，试试看：</p>
<table>
<thead>
<tr>
<th align="center">example</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">例子1</td>
<td align="left">单个源文件 main.c</td>
</tr>
<tr>
<td align="center">例子2</td>
<td align="left">==&gt;分解成多个 main.c hello.h hello.c</td>
</tr>
<tr>
<td align="center">例子3</td>
<td align="left">==&gt;先生成一个静态库，链接该库</td>
</tr>
<tr>
<td align="center">例子4</td>
<td align="left">==&gt;将源文件放置到不同的目录</td>
</tr>
<tr>
<td align="center">例子5</td>
<td align="left">==&gt;控制生成的程序和库所在的目录</td>
</tr>
<tr>
<td align="center">例子6</td>
<td align="left">==&gt;使用动态库而不是静态库</td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h1><p>一个经典的C程序，如何用cmake来进行构建程序呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!/n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写一个 CMakeList.txt 文件(可看做cmake的工程文件)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line">set(SRC_LIST main.c)</span><br><span class="line">add_executable(hello $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>

<p>然后，建立一个任意目录（比如本目录下创建一个build子目录），在该build目录下调用cmake</p>
<blockquote>
<p>注意：为了简单起见，我们从一开始就采用cmake的 out-of-source 方式来构建（即生成中间产物与源代码分离），并始终坚持这种方法，这也就是此处为什么单独创建一个目录，然后在该目录下执行 cmake 的原因</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmake .. -G<span class="string">&quot;NMake Makefiles&quot;</span></span><br><span class="line">nmake</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake .. -G<span class="string">&quot;MinGW Makefiles&quot;</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>即可生成可执行程序 hello(.exe)</p>
<p>目录结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+</span><br><span class="line">| </span><br><span class="line">+--- main.c</span><br><span class="line">+--- CMakeList.txt</span><br><span class="line">|</span><br><span class="line">&#x2F;--+ build&#x2F;</span><br><span class="line">   |</span><br><span class="line">   +--- hello.exe</span><br></pre></td></tr></table></figure>

<p>cmake 真的不太好用哈，使用cmake的过程，本身也就是一个编程的过程，只有多练才行。</p>
<p>我们先看看：前面提到的这些都是什么呢？</p>
<h2 id="CMakeList-txt"><a href="#CMakeList-txt" class="headerlink" title="CMakeList.txt"></a>CMakeList.txt</h2><p>第一行<strong>project</strong>不是强制性的，但最好始终都加上。这一行会引入两个变量</p>
<ul>
<li>HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR</li>
</ul>
<p>同时，cmake自动定义了两个等价的变量</p>
<ul>
<li>PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR</li>
</ul>
<p>因为是out-of-source方式构建，所以我们要时刻区分这两个变量对应的目录<br>可以通过<strong>message</strong>来输出变量的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">message(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>set</strong> 命令用来设置变量<br><strong>add_exectuable</strong> 告诉工程生成一个可执行文件。<br><strong>add_library</strong> 则告诉生成一个库文件。</p>
<ul>
<li>注意：CMakeList.txt 文件中，命令名字是不区分大小写的，而参数和变量是大小写相关的。</li>
</ul>
<h2 id="cmake命令"><a href="#cmake命令" class="headerlink" title="cmake命令"></a>cmake命令</h2><p>cmake 命令后跟一个路径(..)，用来指出 CMakeList.txt 所在的位置。</p>
<p>由于系统中可能有多套构建环境，我们可以通过-G来制定生成哪种工程文件，通过 cmake -h 可得到详细信息。</p>
<p>要显示执行构建过程中详细的信息(比如为了得到更详细的出错信息)，可以在CMakeList.txt内加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET( CMAKE_VERBOSE_MAKEFILE on )</span><br></pre></td></tr></table></figure>

<p>或者执行make时</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ make VERBOSE=1</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> VERBOSE=1</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>

<h1 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h1><p>一个源文件的例子一似乎没什么意思，拆成3个文件再试试看：</p>
<ul>
<li>hello.h 头文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DBZHANG_HELLO_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBZHANG_HELLO_</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//DBZHANG_HELLO_</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>hello.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Hello %s!/n&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>main.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hello(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后准备好CMakeList.txt 文件
 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line">set(SRC_LIST main.c hello.c)</span><br><span class="line">add_executable(hello $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>

<p>执行cmake的过程同上，目录结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+</span><br><span class="line">| </span><br><span class="line">+--- main.c</span><br><span class="line">+--- hello.h</span><br><span class="line">+--- hello.c</span><br><span class="line">+--- CMakeList.txt</span><br><span class="line">|</span><br><span class="line">&#x2F;--+ build&#x2F;</span><br><span class="line">   |</span><br><span class="line">   +--- hello.exe</span><br></pre></td></tr></table></figure>

<p>例子很简单，没什么可说的。</p>
<h1 id="例子三"><a href="#例子三" class="headerlink" title="例子三"></a>例子三</h1><p>接前面的例子，我们将 hello.c 生成一个库，然后再使用会怎么样？<br>改写一下前面的CMakeList.txt文件试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line">set(LIB_SRC hello.c)</span><br><span class="line">set(APP_SRC main.c)</span><br><span class="line">add_library(libhello $&#123;LIB_SRC&#125;)</span><br><span class="line">add_executable(hello $&#123;APP_SRC&#125;)</span><br><span class="line">target_link_libraries(hello libhello)</span><br></pre></td></tr></table></figure>
<p>和前面相比，我们添加了一个新的目标 libhello，并将其链接进hello程序<br>然后想前面一样，运行cmake，得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+</span><br><span class="line">| </span><br><span class="line">+--- main.c</span><br><span class="line">+--- hello.h</span><br><span class="line">+--- hello.c</span><br><span class="line">+--- CMakeList.txt</span><br><span class="line">|</span><br><span class="line">&#x2F;--+ build&#x2F;</span><br><span class="line">   |</span><br><span class="line">   +--- hello.exe</span><br><span class="line">   +--- libhello.lib</span><br></pre></td></tr></table></figure>

<p>里面有一点不爽，对不？</p>
<ul>
<li>因为我的可执行程序(add_executable)占据了 hello 这个名字，所以 add_library 就不能使用这个名字了</li>
<li>然后，我们去了个libhello 的名字，这将导致生成的库为 libhello.lib(或 liblibhello.a)，很不爽</li>
<li>想生成 hello.lib(或libhello.a) 怎么办?</li>
</ul>
<p>添加一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set_target_properties(libhello PROPERTIES OUTPUT_NAME &quot;hello&quot;)</span><br></pre></td></tr></table></figure>
<p>就可以了</p>
<h1 id="例子四"><a href="#例子四" class="headerlink" title="例子四"></a>例子四</h1><p>在前面，我们成功地使用了库，可是源代码放在同一个路径下，还是不太正规，怎么办呢？分开放呗<br>我们期待是这样一种结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+</span><br><span class="line">|</span><br><span class="line">+--- CMakeList.txt</span><br><span class="line">+--+ src&#x2F;</span><br><span class="line">|  |</span><br><span class="line">|  +--- main.c</span><br><span class="line">|  &#x2F;--- CMakeList.txt</span><br><span class="line">|</span><br><span class="line">+--+ libhello&#x2F;</span><br><span class="line">|  |</span><br><span class="line">|  +--- hello.h</span><br><span class="line">|  +--- hello.c</span><br><span class="line">|  &#x2F;--- CMakeList.txt</span><br><span class="line">|</span><br><span class="line">&#x2F;--+ build&#x2F;</span><br></pre></td></tr></table></figure>

<p>哇，现在需要3个CMakeList.txt 文件了，每个源文件目录都需要一个，还好,每一个都不是太复杂</p>
<ul>
<li>顶层的CMakeList.txt 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line">add_subdirectory(src)</span><br><span class="line">add_subdirectory(libhello)</span><br></pre></td></tr></table></figure>

<ul>
<li>src 中的 CMakeList.txt 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;libhello)</span><br><span class="line">set(APP_SRC main.c)</span><br><span class="line">add_executable(hello $&#123;APP_SRC&#125;)</span><br><span class="line">target_link_libraries(hello libhello)</span><br></pre></td></tr></table></figure>

<ul>
<li>libhello 中的 CMakeList.txt 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set(LIB_SRC hello.c)</span><br><span class="line">add_library(libhello $&#123;LIB_SRC&#125;)</span><br><span class="line">set_target_properties(libhello PROPERTIES OUTPUT_NAME &quot;hello&quot;)</span><br></pre></td></tr></table></figure>

<p>恩，和前面一样，建立一个build目录，在其内运行cmake，然后可以得到</p>
<ul>
<li>build/src/hello.exe</li>
<li>build/libhello/hello.lib</li>
</ul>
<p>回头看看，这次多了点什么，顶层的 CMakeList.txt 文件中使用 add_subdirectory 告诉cmake去子目录寻找新的CMakeList.txt 子文件<br>在 src 的 CMakeList.txt 文件中，新增加了include_directories，用来指明头文件所在的路径。</p>
<h1 id="例子五"><a href="#例子五" class="headerlink" title="例子五"></a>例子五</h1><p>前面还是有一点不爽：如果想让可执行文件在 bin 目录，库文件在 lib 目录怎么办？</p>
<p>就像下面显示的一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ build&#x2F;</span><br><span class="line">|</span><br><span class="line">+--+ bin&#x2F;</span><br><span class="line">|  |</span><br><span class="line">|  &#x2F;--- hello.exe</span><br><span class="line">|</span><br><span class="line">&#x2F;--+ lib&#x2F;</span><br><span class="line">   |</span><br><span class="line">   &#x2F;--- hello.lib</span><br></pre></td></tr></table></figure>

<ul>
<li>一种办法：修改顶级的 CMakeList.txt 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line">add_subdirectory(src bin)</span><br><span class="line">add_subdirectory(libhello lib)</span><br></pre></td></tr></table></figure>

<p>不是build中的目录默认和源代码中结构一样么，我们可以指定其对应的目录在build中的名字。<br>这样一来：build/src 就成了 build/bin 了，可是除了 hello.exe，中间产物也进来了。还不是我们最想要的。<br>另一种方法：不修改顶级的文件，修改其他两个文件</p>
<ul>
<li>src/CMakeList.txt 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;libhello)</span><br><span class="line">#link_directories($&#123;PROJECT_BINARY_DIR&#125;&#x2F;lib)</span><br><span class="line">set(APP_SRC main.c)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;&#x2F;bin)</span><br><span class="line">add_executable(hello $&#123;APP_SRC&#125;)</span><br><span class="line">target_link_libraries(hello libhello)</span><br></pre></td></tr></table></figure>

<ul>
<li>libhello/CMakeList.txt 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set(LIB_SRC hello.c)</span><br><span class="line">add_library(libhello $&#123;LIB_SRC&#125;)</span><br><span class="line">set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;&#x2F;lib)</span><br><span class="line">set_target_properties(libhello PROPERTIES OUTPUT_NAME &quot;hello&quot;)</span><br></pre></td></tr></table></figure>

<h1 id="例子六"><a href="#例子六" class="headerlink" title="例子六"></a>例子六</h1><p>在例子三至五中，我们始终用的静态库，那么用动态库应该更酷一点吧。 试着写一下<br>如果不考虑windows下，这个例子应该是很简单的，只需要在上个例子的 libhello/CMakeList.txt 文件中的add_library命令中加入一个SHARED参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_library(libhello SHARED $&#123;LIB_SRC&#125;)</span><br></pre></td></tr></table></figure>

<p>可是，我们既然用cmake了，还是兼顾不同的平台吧，于是，事情有点复杂：</p>
<ul>
<li>修改 hello.h 文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DBZHANG_HELLO_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBZHANG_HELLO_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _WIN32</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> LIBHELLO_BUILD</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> LIBHELLO_API __declspec(dllexport)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> LIBHELLO_API __declspec(dllimport)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> LIBHELLO_API</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function">LIBHELLO_API <span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//DBZHANG_HELLO_</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改 libhello/CMakeList.txt 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set(LIB_SRC hello.c)</span><br><span class="line">add_definitions(&quot;-DLIBHELLO_BUILD&quot;)</span><br><span class="line">add_library(libhello SHARED $&#123;LIB_SRC&#125;)</span><br><span class="line">set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;&#x2F;lib)</span><br><span class="line">set_target_properties(libhello PROPERTIES OUTPUT_NAME &quot;hello&quot;)</span><br></pre></td></tr></table></figure>
<p>恩，剩下来的工作就和原来一样了。</p>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法合集</title>
    <url>/2019/05/10/C:C++%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h1 id="数据结构算法合集"><a href="#数据结构算法合集" class="headerlink" title="数据结构算法合集"></a>数据结构算法合集</h1><h2 id="第一部分：链表"><a href="#第一部分：链表" class="headerlink" title="第一部分：链表"></a>第一部分：链表</h2><h3 id="1-从一给定的顺序表L中删除下标i-j（i-lt-j-包括i-j）的所有元素，假定i-j合法。"><a href="#1-从一给定的顺序表L中删除下标i-j（i-lt-j-包括i-j）的所有元素，假定i-j合法。" class="headerlink" title="1. 从一给定的顺序表L中删除下标i-j（i&lt;=j,包括i,j）的所有元素，假定i,j合法。"></a>1. 从一给定的顺序表L中删除下标i-j（i&lt;=j,包括i,j）的所有元素，假定i,j合法。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中，以数组的形式保存的线性表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, delta;</span><br><span class="line">    delta = j - i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(k = j + <span class="number">1</span>; k &lt; L.length; ++k)&#123;</span><br><span class="line">        L.data[k - delta]=L.data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length -= delta;<span class="comment">//最后要更新顺序表的表长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!---more--->

<h3 id="2-有一顺序表L，其元素为整型数据，设计一个算法，将L中所有小于表头元素的数据放在前半部分，大于表头元素的数据放在后半部分。"><a href="#2-有一顺序表L，其元素为整型数据，设计一个算法，将L中所有小于表头元素的数据放在前半部分，大于表头元素的数据放在后半部分。" class="headerlink" title="2. 有一顺序表L，其元素为整型数据，设计一个算法，将L中所有小于表头元素的数据放在前半部分，大于表头元素的数据放在后半部分。"></a>2. 有一顺序表L，其元素为整型数据，设计一个算法，将L中所有小于表头元素的数据放在前半部分，大于表头元素的数据放在后半部分。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span>  i = <span class="number">0</span>, j = L.length - <span class="number">1</span>;</span><br><span class="line">    temp = L.data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j&amp;&amp; L.data[j] &gt; temp) --j;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            L.data[i] = L.data[j];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j&amp;&amp; L.data[i] &lt; temp) ++i;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            L.data[j] = L.data[i];</span><br><span class="line">            --j; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-递增非空单链表，设计一个算法删除值域重复的结点。"><a href="#3-递增非空单链表，设计一个算法删除值域重复的结点。" class="headerlink" title="3. 递增非空单链表，设计一个算法删除值域重复的结点。"></a>3. 递增非空单链表，设计一个算法删除值域重复的结点。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">viod <span class="title">dels</span><span class="params">(LNode *L)</span></span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next, *q;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == p-&gt;next-&gt;data)&#123;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-带头结点的单链表L，在不建立新结点，只能通过已有结点的条件下将其逆置。"><a href="#4-带头结点的单链表L，在不建立新结点，只能通过已有结点的条件下将其逆置。" class="headerlink" title="4. 带头结点的单链表L，在不建立新结点，只能通过已有结点的条件下将其逆置。"></a>4. 带头结点的单链表L，在不建立新结点，只能通过已有结点的条件下将其逆置。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseList</span><span class="params">(LNode *L)</span></span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next, *q;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-设计一个算法，删除带头结点的单链表L中最小值结点。"><a href="#5-设计一个算法，删除带头结点的单链表L中最小值结点。" class="headerlink" title="5. 设计一个算法，删除带头结点的单链表L中最小值结点。"></a>5. 设计一个算法，删除带头结点的单链表L中最小值结点。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delminNode</span><span class="params">(LNode *L)</span></span>&#123;</span><br><span class="line">    LNode *pre = L, *p = L-&gt;next, *minpre = pre, *minp = p;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data &lt; minp-&gt;data)&#123;</span><br><span class="line">            minp = p;</span><br><span class="line">            minpre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    minpre-&gt;next = minp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(minp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-设计一个算法，将一个头结点为A的单链表（其数据域为整型），分解成两个单链表A和B，使保持相对顺序的情况下，A中只有奇数结点，B中只有偶数结点。"><a href="#6-设计一个算法，将一个头结点为A的单链表（其数据域为整型），分解成两个单链表A和B，使保持相对顺序的情况下，A中只有奇数结点，B中只有偶数结点。" class="headerlink" title="6. 设计一个算法，将一个头结点为A的单链表（其数据域为整型），分解成两个单链表A和B，使保持相对顺序的情况下，A中只有奇数结点，B中只有偶数结点。"></a>6. 设计一个算法，将一个头结点为A的单链表（其数据域为整型），分解成两个单链表A和B，使保持相对顺序的情况下，A中只有奇数结点，B中只有偶数结点。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spList</span><span class="params">(LNode *A, LNode *&amp;B)</span></span>&#123;</span><br><span class="line">    LNode *p, *q, *r;</span><br><span class="line">    B = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    B-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    r = B;</span><br><span class="line">    p = A;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next-&gt;data%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            r-&gt;next = q;</span><br><span class="line">            r = q;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-有N个个位正整数存放在int型数组A-0-1-…-N-1-中，N为已定义的常量且N-lt-9，数组A-的长度为N，另给一个int型变量i，要求只要上述变量（A-0-A-N-1-与i这N-1个整型变量）写一个算法，找出这N个整数中的最小值，并且要求不能破坏数组A-中的数据。"><a href="#7-有N个个位正整数存放在int型数组A-0-1-…-N-1-中，N为已定义的常量且N-lt-9，数组A-的长度为N，另给一个int型变量i，要求只要上述变量（A-0-A-N-1-与i这N-1个整型变量）写一个算法，找出这N个整数中的最小值，并且要求不能破坏数组A-中的数据。" class="headerlink" title="7. 有N个个位正整数存放在int型数组A[0,1,…,N-1]中，N为已定义的常量且N&lt;=9，数组A[]的长度为N，另给一个int型变量i，要求只要上述变量（A[0]~A[N-1]与i这N+1个整型变量）写一个算法，找出这N个整数中的最小值，并且要求不能破坏数组A[]中的数据。"></a>7. 有N个个位正整数存放在int型数组A[0,1,…,N-1]中，N为已定义的常量且N&lt;=9，数组A[]的长度为N，另给一个int型变量i，要求只要上述变量（A[0]~A[N-1]与i这N+1个整型变量）写一个算法，找出这N个整数中的最小值，并且要求不能破坏数组A[]中的数据。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 难点： int i 这一个变量来实现通航数组下标 i 和 min 两个变量所实现的功能</span></span><br><span class="line"><span class="comment">// 实现方法： 可以让 i 的十位上的数字作为循环变量，将 i 的个位上的数字用来存储 min </span></span><br><span class="line"><span class="comment">// i % 10 即取 i 个位上的数字，i / 10 即取 i 十位上的数字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> &amp;i)</span></span>&#123;</span><br><span class="line">    i = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(i/<span class="number">10</span> &lt;= N<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">10</span> &gt; A[i/<span class="number">10</span>])&#123;</span><br><span class="line">            i = i - i%<span class="number">10</span>;</span><br><span class="line">            i = i + A[i/<span class="number">10</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        i = i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = i % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-写一个函数，逆序打印单链表中的数据，假设指针L指向了单链表的开始结点。"><a href="#8-写一个函数，逆序打印单链表中的数据，假设指针L指向了单链表的开始结点。" class="headerlink" title="8. 写一个函数，逆序打印单链表中的数据，假设指针L指向了单链表的开始结点。"></a>8. 写一个函数，逆序打印单链表中的数据，假设指针L指向了单链表的开始结点。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归思想：在表不空的情况下，递归地逆序打印表中第一个数据之后的数据，然后打印第一个数据。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reprint</span><span class="params">(LNode *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        reprint(L-&gt;next);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, L-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-试编写一个函数，以不多于3n-2的平均比较次数，在一个有n个整型的顺序表A中找出最大最小值。"><a href="#9-试编写一个函数，以不多于3n-2的平均比较次数，在一个有n个整型的顺序表A中找出最大最小值。" class="headerlink" title="9. 试编写一个函数，以不多于3n/2的平均比较次数，在一个有n个整型的顺序表A中找出最大最小值。"></a>9. 试编写一个函数，以不多于3n/2的平均比较次数，在一个有n个整型的顺序表A中找出最大最小值。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindMaxMin</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> &amp;max, <span class="keyword">int</span> &amp;min)</span></span>&#123;</span><br><span class="line">    max = min = A[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt; max)</span><br><span class="line">            max = A[i];</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt; min)</span><br><span class="line">            min = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最坏情况：当表中 n 个整数按从大到小非递增排列时，数据比较次数为 2(n-1) 次</span></span><br><span class="line"><span class="comment">//最好情况：当表中 n 个整数按从小到大非递减排列时，数据比较次数为 n-1 次</span></span><br><span class="line"><span class="comment">//A 中数据的有序性可以认为是等可能的，故，最好最坏情况概率相同</span></span><br><span class="line"><span class="comment">//综上所述，数据平均比较次数为 (2*(n-1)+(n-1))/2 = 3n/2 - 3/2 &lt; 3n/2</span></span><br></pre></td></tr></table></figure>

<h3 id="10-设A-（a1-a2-…-an）和B-（b1-b2-bn）均为顺序表，A’和B’分别是除去最大公共前缀后的子表。若A-（b-e-i-j-i-n-g）-B-（b-e-i-f-a-n-g），则A’-（j-i-n-g），B’-（f-a-n-g），若A’-B’-∅，则A-B，若A’-∅且B≠∅，或两者均不为空且A’的第一个元素值小于B’的第一个元素值，则A-lt-B，否则A-gt-B-试写出一个函数，根据上述方法比较A-B大小。"><a href="#10-设A-（a1-a2-…-an）和B-（b1-b2-bn）均为顺序表，A’和B’分别是除去最大公共前缀后的子表。若A-（b-e-i-j-i-n-g）-B-（b-e-i-f-a-n-g），则A’-（j-i-n-g），B’-（f-a-n-g），若A’-B’-∅，则A-B，若A’-∅且B≠∅，或两者均不为空且A’的第一个元素值小于B’的第一个元素值，则A-lt-B，否则A-gt-B-试写出一个函数，根据上述方法比较A-B大小。" class="headerlink" title="10. 设A=（a1,a2,…,an）和B=（b1,b2,..,bn）均为顺序表，A’和B’分别是除去最大公共前缀后的子表。若A=（b,e,i,j,i,n,g）,B=（b,e,i,f,a,n,g），则A’=（j,i,n,g），B’=（f,a,n,g），若A’=B’=∅，则A=B，若A’=∅且B≠∅，或两者均不为空且A’的第一个元素值小于B’的第一个元素值，则A&lt;B，否则A&gt;B.试写出一个函数，根据上述方法比较A,B大小。"></a>10. 设A=（a1,a2,…,an）和B=（b1,b2,..,bn）均为顺序表，A’和B’分别是除去最大公共前缀后的子表。若A=（b,e,i,j,i,n,g）,B=（b,e,i,f,a,n,g），则A’=（j,i,n,g），B’=（f,a,n,g），若A’=B’=∅，则A=B，若A’=∅且B≠∅，或两者均不为空且A’的第一个元素值小于B’的第一个元素值，则A&lt;B，否则A&gt;B.试写出一个函数，根据上述方法比较A,B大小。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只需先进行一趟循环，过滤掉最大公共前缀，再判断剩余部分，A = B 返回0， A &lt; B 返回-1，否则返回1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">float</span> A[], <span class="keyword">int</span> An, <span class="keyword">float</span> B[], <span class="keyword">int</span> Bn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 过滤公共前缀*/</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; An &amp;&amp; i &lt; Bn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(A[i] - B[i]) &lt; min)</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* A&#x27;,B&#x27;均为空*/</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= An &amp;&amp; i &gt;= Bn)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* A&#x27; ≠ ∅且B&#x27; ≠ ∅，或A&#x27;第一个元素值小于B&#x27;*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((i &gt;= An &amp;&amp; i &lt; Bn)||A[i] &lt; B[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11-键盘输入n个英文字母，输入格式为n-C1-C2-…-Cn，其中n表示字母个数，请编程以这些输入数据建立一个单链表，并要求将字母不重复的存入链表。"><a href="#11-键盘输入n个英文字母，输入格式为n-C1-C2-…-Cn，其中n表示字母个数，请编程以这些输入数据建立一个单链表，并要求将字母不重复的存入链表。" class="headerlink" title="11. 键盘输入n个英文字母，输入格式为n,C1,C2,…,Cn，其中n表示字母个数，请编程以这些输入数据建立一个单链表，并要求将字母不重复的存入链表。"></a>11. 键盘输入n个英文字母，输入格式为n,C1,C2,…,Cn，其中n表示字母个数，请编程以这些输入数据建立一个单链表，并要求将字母不重复的存入链表。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每输入一个数据，扫描其在链表中是否出现，如果出现，就什么都不做，否则构造结点，插入表中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createLinkNoSameElem</span><span class="params">(LNode *&amp;head)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化链表*/</span></span><br><span class="line">    head = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);<span class="comment">//输入字母个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">/* 若出现过该数据，则退出循环，且此时 p != NULL*/</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data == ch)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 若未出现过该数据，则 p 此时遍历到了表尾结点，进行插入操作，让 p 重新指向新结点*/</span></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">            p-&gt;data = ch;</span><br><span class="line">            <span class="comment">/* 头插法，插入结点*/</span></span><br><span class="line">            p-&gt;next = head-&gt;next;</span><br><span class="line">            head-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-将一长度为n的数组的前段k-k-lt-n-个元素逆序后移动到数组后端，要求数组中的数据不丢失。"><a href="#12-将一长度为n的数组的前段k-k-lt-n-个元素逆序后移动到数组后端，要求数组中的数据不丢失。" class="headerlink" title="12. 将一长度为n的数组的前段k(k&lt;n)个元素逆序后移动到数组后端，要求数组中的数据不丢失。"></a>12. 将一长度为n的数组的前段k(k&lt;n)个元素逆序后移动到数组后端，要求数组中的数据不丢失。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路：可直接将第一个元素与最后一个元素交换，第二个与倒数第二个元素交换，以此类推，依次执行 k 次，利用顺序表逆置算法将前 k 个按逆序的方式移动到了数组后端</span></span><br><span class="line"><span class="comment">/* a[]:逆置数组，left~right:逆置范围，k:逆置次数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = left, j = right; i &lt; j &amp;&amp; i &lt; left + k ; ++i, --j)&#123;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当 k 大于逆序数组元素个数的一半时，只需要逆序到 i &lt; j 时即可，因为此时整个数组已经完全逆置</span></span><br></pre></td></tr></table></figure>

<h3 id="13-将一长度为n的数组的前段k-k-lt-n-个元素保持原序移动到数组后端，要求数组中的数据不丢失。"><a href="#13-将一长度为n的数组的前段k-k-lt-n-个元素保持原序移动到数组后端，要求数组中的数据不丢失。" class="headerlink" title="13. 将一长度为n的数组的前段k(k&lt;n)个元素保持原序移动到数组后端，要求数组中的数据不丢失。"></a>13. 将一长度为n的数组的前段k(k&lt;n)个元素保持原序移动到数组后端，要求数组中的数据不丢失。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路：代码间尽量提高已有代码的复用性，12为本题前一问，则本题思路为，通过将前 k 个元素先进行一次逆序，再将 k 个元素进行一个整体逆序，则前 k 个元素经过两次逆序保持了原来的顺序，而一次交换到了数组最后端。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToEND</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    reverse(a, <span class="number">0</span>, k<span class="number">-1</span>, k);</span><br><span class="line">    reverse(a, <span class="number">0</span>, n<span class="number">-1</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-将n-n-gt-1-个数组存放在一维数组R中，设计一个算法，将R中的序列循环左移p-0-lt-p-lt-n-个位置，即将R中的数据由-X0-X1-…-Xn-1-变换为-Xp-Xp-1-…-Xn-1-X0-X1-…-Xp-1-。"><a href="#14-将n-n-gt-1-个数组存放在一维数组R中，设计一个算法，将R中的序列循环左移p-0-lt-p-lt-n-个位置，即将R中的数据由-X0-X1-…-Xn-1-变换为-Xp-Xp-1-…-Xn-1-X0-X1-…-Xp-1-。" class="headerlink" title="14. 将n(n&gt;1)个数组存放在一维数组R中，设计一个算法，将R中的序列循环左移p(0&lt;p&lt;n)个位置，即将R中的数据由{X0,X1,…,Xn-1}变换为{Xp,Xp+1,…,Xn-1,X0,X1,…,Xp-1}。"></a>14. 将n(n&gt;1)个数组存放在一维数组R中，设计一个算法，将R中的序列循环左移p(0&lt;p&lt;n)个位置，即将R中的数据由{X0,X1,…,Xn-1}变换为{Xp,Xp+1,…,Xn-1,X0,X1,…,Xp-1}。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路：需实现 R 中序列循环左移 p 个位置，只需将 R 中前 p 个元素逆置，再将剩余元素逆置，最后进行一次整体逆置即可</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveP</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    reverse(a, <span class="number">0</span>, p<span class="number">-1</span>, p);</span><br><span class="line">    reverse(a, p, n<span class="number">-1</span>, n-p);</span><br><span class="line">    reverse(a, <span class="number">0</span>, n-i, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-一由Head指针指出的非空双链表中，结点结构为-lLink-data-rLink-请设计一个算法，将结点数据data值最大的那个结点（最大的结点唯一），移动到链表最前边，要求不得申请新结点空间。"><a href="#15-一由Head指针指出的非空双链表中，结点结构为-lLink-data-rLink-请设计一个算法，将结点数据data值最大的那个结点（最大的结点唯一），移动到链表最前边，要求不得申请新结点空间。" class="headerlink" title="15. 一由Head指针指出的非空双链表中，结点结构为{lLink,data,rLink},请设计一个算法，将结点数据data值最大的那个结点（最大的结点唯一），移动到链表最前边，要求不得申请新结点空间。"></a>15. 一由Head指针指出的非空双链表中，结点结构为{lLink,data,rLink},请设计一个算法，将结点数据data值最大的那个结点（最大的结点唯一），移动到链表最前边，要求不得申请新结点空间。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路：①找出最大值结点；②“删除”结点；③插入最大值结点</span></span><br><span class="line"><span class="comment">//&#123;llink,data,rlink&#125;是伪代码表示法，仅只改了名字，llink对应于prior指针，rlink对应于next指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxFirst</span><span class="params">(DLNode *head)</span></span>&#123;</span><br><span class="line">    DLNode *p = head-&gt;rlink, *q = p;</span><br><span class="line">    <span class="keyword">int</span> max = p-&gt;data;</span><br><span class="line">    <span class="comment">/* 查找*/</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max &lt; p_.data)&#123;</span><br><span class="line">            max = p-&gt;data;</span><br><span class="line">            q = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;rlink;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 删除*/</span></span><br><span class="line">    DLNode *l = q-&gt;llink, *r = q-&gt;rlink;</span><br><span class="line">    l-&gt;rlink = r;</span><br><span class="line">    <span class="keyword">if</span>(r != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        r-&gt;llink = l;</span><br><span class="line">    <span class="comment">/* 插入*/</span></span><br><span class="line">    q-&gt;llink = head;</span><br><span class="line">    q-&gt;rlink = head-&gt;rlink;</span><br><span class="line">    head-&gt;rlink = q;</span><br><span class="line">    q-&gt;rlink-&gt;llink = q;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h2 id="第二部分：二叉树"><a href="#第二部分：二叉树" class="headerlink" title="第二部分：二叉树"></a>第二部分：二叉树</h2><h3 id="1-表达式-a-b-c-d-e-存储在如图所示的一颗以二叉链表为存储结构的二叉树中，（二叉树结点的data域为字符型），编写程序求出该表达式的值（操作数均为一位整数）。"><a href="#1-表达式-a-b-c-d-e-存储在如图所示的一颗以二叉链表为存储结构的二叉树中，（二叉树结点的data域为字符型），编写程序求出该表达式的值（操作数均为一位整数）。" class="headerlink" title="1.表达式 (a-(b+c))*(d/e) 存储在如图所示的一颗以二叉链表为存储结构的二叉树中，（二叉树结点的data域为字符型），编写程序求出该表达式的值（操作数均为一位整数）。"></a>1.表达式 (a-(b+c))*(d/e) 存储在如图所示的一颗以二叉链表为存储结构的二叉树中，（二叉树结点的data域为字符型），编写程序求出该表达式的值（操作数均为一位整数）。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">           /  \</span></span><br><span class="line"><span class="comment">          -    /</span></span><br><span class="line"><span class="comment">        /  \  /  \</span></span><br><span class="line"><span class="comment">        a  +  d  e</span></span><br><span class="line"><span class="comment">          / \</span></span><br><span class="line"><span class="comment">          b c </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//分析：递归求值时，首先要知道，左子树的值，右子树的值，再根据根节点的运算符才可以进行下一步运算，故应采用后序遍历来解决此题</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(BTNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A, B;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>&amp;&amp; p-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">/* 此二叉树为正则二叉树，若度为2，则子树为子表达式*/</span></span><br><span class="line">            A = comp(p-&gt;lchild);</span><br><span class="line">            B = comp(p-&gt;rchild);</span><br><span class="line">            <span class="keyword">return</span> op(A, B, p-&gt;data);<span class="comment">//度为2的结点上，子树根节点为运算操作符</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p-&gt;data - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//度为0的结点上，子树为操作数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-写一个算法求一棵二叉树的深度，二叉树以二叉链表为存储方式。"><a href="#2-写一个算法求一棵二叉树的深度，二叉树以二叉链表为存储方式。" class="headerlink" title="2.写一个算法求一棵二叉树的深度，二叉树以二叉链表为存储方式。"></a>2.写一个算法求一棵二叉树的深度，二叉树以二叉链表为存储方式。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分析：已知一颗左子树的深度，和右子树的深度，如何算出整棵树的深度呢？（递归思想）</span></span><br><span class="line"><span class="comment">//左子树的深度为LD，右子树的深度为RD，则整棵树的深度就是max&#123;LD,RD&#125;+1</span></span><br><span class="line"><span class="comment">//需要得到左右子树的信息后再进行操作，故为后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> LD, RD;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        LD = getDepth(p-&gt;lchild);</span><br><span class="line">        RD = getDepth(p-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> (LD &gt; RD ? LD : RD) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-在一棵以二叉链表为存储结构的二叉树中，查找data域值等于key的结点，存在则用-q-指向该结点（找到任何一个即可），否则赋值为NULL，假设data域为int型。"><a href="#3-在一棵以二叉链表为存储结构的二叉树中，查找data域值等于key的结点，存在则用-q-指向该结点（找到任何一个即可），否则赋值为NULL，假设data域为int型。" class="headerlink" title="3.在一棵以二叉链表为存储结构的二叉树中，查找data域值等于key的结点，存在则用 q 指向该结点（找到任何一个即可），否则赋值为NULL，假设data域为int型。"></a>3.在一棵以二叉链表为存储结构的二叉树中，查找data域值等于key的结点，存在则用 q 指向该结点（找到任何一个即可），否则赋值为NULL，假设data域为int型。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//剪枝操作：当在左子树中找到满足的结点后，无需继续查找右子树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span> <span class="params">(BTNode *p, BTNode *&amp;q, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == key)</span><br><span class="line">            q = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            search(p-&gt;lchild, q, key);</span><br><span class="line">            <span class="keyword">if</span> (q == <span class="literal">NULL</span>)</span><br><span class="line">                search(p-&gt;rchild, q, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-假设二叉树采用二叉链表存储结构存储，设计一个算法，求出二叉树的深度。"><a href="#4-假设二叉树采用二叉链表存储结构存储，设计一个算法，求出二叉树的深度。" class="headerlink" title="4.假设二叉树采用二叉链表存储结构存储，设计一个算法，求出二叉树的深度。"></a>4.假设二叉树采用二叉链表存储结构存储，设计一个算法，求出二叉树的深度。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面定义的这个结构体为顺序非循环队列的队列元素，可以存储结点指针以及结点所在的层次号</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    BTNode  *p;     <span class="comment">//结点指针</span></span><br><span class="line">    <span class="keyword">int</span>     lno;    <span class="comment">//结点所在层次号</span></span><br><span class="line">&#125; St;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxNode</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">    St que[maxSize];</span><br><span class="line">    <span class="keyword">int</span> front, rear;</span><br><span class="line">    <span class="keyword">int</span> Lno, i, j, n, max;</span><br><span class="line">    front = rear = <span class="number">0</span>;</span><br><span class="line">    BTNode *q;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ++rear;</span><br><span class="line">        que[rear].p = b;</span><br><span class="line">        que[rear].lno = <span class="number">1</span>;          <span class="comment">//树根层次号设为1</span></span><br><span class="line">        <span class="keyword">while</span> (front != rear) &#123;</span><br><span class="line">            ++front;</span><br><span class="line">            q = que[front].p;</span><br><span class="line">            Lno = que[front].lno;   <span class="comment">//Lno用来存储当前结点层号</span></span><br><span class="line">            <span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ++rear;</span><br><span class="line">                que[rear].p = q-&gt;lchild;</span><br><span class="line">                <span class="comment">//根据当前结点的层号推知其孩子结点的层号</span></span><br><span class="line">                que[rear].lno = Lno + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                 ++rear;</span><br><span class="line">                que[rear].p = q-&gt;rchild;</span><br><span class="line">                <span class="comment">//根据当前结点的层号推知其孩子结点的层号</span></span><br><span class="line">                que[rear].lno = Lno + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意：此时退出循环，Lno保存了结点的最大层数</span></span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= Lno; ++i) &#123;</span><br><span class="line">            n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= rear; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (que[j].lno == i)</span><br><span class="line">                    ++n;</span><br><span class="line">                <span class="keyword">if</span>(max &lt; n)</span><br><span class="line">                    max = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;               </span><br></pre></td></tr></table></figure>

<h3 id="5-假设二叉树采用二叉链表存储结构，设计一个算法，利用结点的右孩子指针-rchild，将一颗二叉树的叶子节点按照从左往右的顺序串成一个单链表，（在题目中定义两个指针-head-与-tail，head-初值为-NULL-head-指向第一个结点，tail-指向最后一个结点。"><a href="#5-假设二叉树采用二叉链表存储结构，设计一个算法，利用结点的右孩子指针-rchild，将一颗二叉树的叶子节点按照从左往右的顺序串成一个单链表，（在题目中定义两个指针-head-与-tail，head-初值为-NULL-head-指向第一个结点，tail-指向最后一个结点。" class="headerlink" title="5.假设二叉树采用二叉链表存储结构，设计一个算法，利用结点的右孩子指针 rchild，将一颗二叉树的叶子节点按照从左往右的顺序串成一个单链表，（在题目中定义两个指针 head 与 tail，head 初值为 NULL, head 指向第一个结点，tail 指向最后一个结点。"></a>5.假设二叉树采用二叉链表存储结构，设计一个算法，利用结点的右孩子指针 rchild，将一颗二叉树的叶子节点按照从左往右的顺序串成一个单链表，（在题目中定义两个指针 head 与 tail，head 初值为 NULL, head 指向第一个结点，tail 指向最后一个结点。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span> <span class="params">(BTNode *p, BTNode *&amp;head, BTNode *&amp;tail)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">                head = p;</span><br><span class="line">                tail = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;rchild = p;</span><br><span class="line">                tail = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        link(p-&gt;lchild, head, tail);</span><br><span class="line">        link(p-&gt;rchild, head, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="6-在二叉树的二叉链式存储结构中，增加一个指向双亲结点的-parent-指针，设计一个算法，给这个指针赋值，并输出所有结点到根节点的路径。"><a href="#6-在二叉树的二叉链式存储结构中，增加一个指向双亲结点的-parent-指针，设计一个算法，给这个指针赋值，并输出所有结点到根节点的路径。" class="headerlink" title="6.在二叉树的二叉链式存储结构中，增加一个指向双亲结点的 parent 指针，设计一个算法，给这个指针赋值，并输出所有结点到根节点的路径。"></a>6.在二叉树的二叉链式存储结构中，增加一个指向双亲结点的 parent 指针，设计一个算法，给这个指针赋值，并输出所有结点到根节点的路径。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给各个结点的 parent 指针赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triBtree</span> <span class="params">(BTNode *p, BTNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p-&gt;parent = q;  <span class="comment">//q初值为NULL</span></span><br><span class="line">        q = p;          <span class="comment">//让q一直为p的双亲</span></span><br><span class="line">        triBtree(p-&gt;lchild, q);</span><br><span class="line">        triBtree(p-&gt;rchild, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印路径</span></span><br><span class="line"><span class="comment">//1.单个路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPath</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.所有结点路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAllPath</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printPath(p);</span><br><span class="line">        printAllPath(p-&gt;lchild);</span><br><span class="line">        printAllPath(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>

<p>###　７.假设满二叉树ｂ的先序遍历序列已经存在于数组中（名称自定义，长度为ｎ），设计一个算法将其转换为后序遍历序列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span> <span class="params">(<span class="keyword">char</span> pre[], <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">char</span> post[], <span class="keyword">int</span> L2, <span class="keyword">int</span> R2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L1 &lt;= R2) &#123;</span><br><span class="line">        post[R2] = pre[L1];</span><br><span class="line">        change(pre, L1+<span class="number">1</span>, (L1+R1+<span class="number">1</span>)/<span class="number">2</span>, post, L2, (L2+R2<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">        change(pre, (L1+R1+<span class="number">1</span>)/<span class="number">2</span>, R1, post, (L2+R2<span class="number">-1</span>)/<span class="number">2</span>, R2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h3 id="8-假设二叉树采用二叉链式存储结构，设计一个算法，求二叉树中，值为-x-的结点的层号。"><a href="#8-假设二叉树采用二叉链式存储结构，设计一个算法，求二叉树中，值为-x-的结点的层号。" class="headerlink" title="8.假设二叉树采用二叉链式存储结构，设计一个算法，求二叉树中，值为 x 的结点的层号。"></a>8.假设二叉树采用二叉链式存储结构，设计一个算法，求二叉树中，值为 x 的结点的层号。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> L;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findElemNo</span><span class="params">(BTNode *p, <span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == x)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, L);</span><br><span class="line">        ++L;    <span class="comment">//打印完后，p指针要进入下一层结点，故L要自增1</span></span><br><span class="line">        findElemNo(p-&gt;lchild, x);</span><br><span class="line">        findElemNo(p-&gt;rchild, x);</span><br><span class="line">        --L;    <span class="comment">//p指针将要由下一层返回到上一层，故L要自减1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-设中序线索二叉树的类型为TBTNode-InThTree-lt-1-gt-设计算法，在一棵中序线索二叉树中寻找结点t的子树上中序下的最后一个结点；-lt-2-gt-设计算法，在一棵中序线索二叉树中寻找结点t中序下的前驱；-lt-3-gt-设计算法，在一棵中序线索二叉树中寻找结点t前序下的后继。"><a href="#9-设中序线索二叉树的类型为TBTNode-InThTree-lt-1-gt-设计算法，在一棵中序线索二叉树中寻找结点t的子树上中序下的最后一个结点；-lt-2-gt-设计算法，在一棵中序线索二叉树中寻找结点t中序下的前驱；-lt-3-gt-设计算法，在一棵中序线索二叉树中寻找结点t前序下的后继。" class="headerlink" title="9.设中序线索二叉树的类型为TBTNode* InThTree:&lt;1&gt;设计算法，在一棵中序线索二叉树中寻找结点t的子树上中序下的最后一个结点；&lt;2&gt;设计算法，在一棵中序线索二叉树中寻找结点t中序下的前驱；&lt;3&gt;设计算法，在一棵中序线索二叉树中寻找结点t前序下的后继。"></a>9.设中序线索二叉树的类型为TBTNode* InThTree:&lt;1&gt;设计算法，在一棵中序线索二叉树中寻找结点t的子树上中序下的最后一个结点；&lt;2&gt;设计算法，在一棵中序线索二叉树中寻找结点t中序下的前驱；&lt;3&gt;设计算法，在一棵中序线索二叉树中寻找结点t前序下的后继。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1&gt;</span></span><br><span class="line"><span class="function">TBTNode* <span class="title">inLast</span> <span class="params">(TBTNode *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TBTNode *p = t;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; !p-&gt;rtag)<span class="comment">//p非空且p不为线索（rtag == 0）时</span></span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2&gt;</span></span><br><span class="line"><span class="function">TBTNode* <span class="title">inPrior</span> <span class="params">(TBTNode *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TBTNode *p = t-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; !p-&gt;ltag)</span><br><span class="line">        p = inLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3&gt;</span></span><br><span class="line"><span class="function">TBTNode* <span class="title">treNext</span><span class="params">(TBTNode *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TBTNode *p;</span><br><span class="line">    <span class="keyword">if</span>(!t-&gt;ltag)</span><br><span class="line">        p = t-&gt;lchild;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!t-&gt;rtag)</span><br><span class="line">        p = t-&gt;rchild;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//左右都为线索，则到了叶子结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = t;</span><br><span class="line">        <span class="keyword">while</span>(p &amp;&amp; !p-&gt;rtag)</span><br><span class="line">        <span class="comment">/* 沿着线索一直找到第一个有右子树的祖先结点</span></span><br><span class="line"><span class="comment">         * 其第一个右孩子即为前序下的后继结点      */</span></span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-假设二叉树采用二叉链式存储结构，设计一个算法，输出根节点到每个叶子结点的路径。"><a href="#10-假设二叉树采用二叉链式存储结构，设计一个算法，输出根节点到每个叶子结点的路径。" class="headerlink" title="10.假设二叉树采用二叉链式存储结构，设计一个算法，输出根节点到每个叶子结点的路径。"></a>10.假设二叉树采用二叉链式存储结构，设计一个算法，输出根节点到每个叶子结点的路径。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 先全局定义一个用来存储路径的栈，由于采用先入栈根结点，故栈顶top值初值为0 */</span></span><br><span class="line"><span class="keyword">char</span> pathStack[maxSize];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allPath</span><span class="params">(BTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pathStack[top] = p-&gt;data;</span><br><span class="line">        ++top;  <span class="comment">//p自上往下走时，结点入栈</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;       <span class="comment">//p指向叶子结点时，打印路径</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, pathStack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        allPath(p-&gt;lchild);</span><br><span class="line">        allPath(p-&gt;rchild);</span><br><span class="line">        --top;  <span class="comment">//p自下往上走时，结点出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode精选算法合集(C)</title>
    <url>/2019/04/08/LeetCode%E7%B2%BE%E9%80%89%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86(C)/</url>
    <content><![CDATA[<h1 id="算法全集"><a href="#算法全集" class="headerlink" title="算法全集"></a>算法全集</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p><strong>注意</strong>:/<br><code>示例</code>:</p>
<blockquote>
<p><code>输入</code>:nums = [2, 7, 11, 15]<br><code>输出</code>:target = 9<br><code>解释</code>:因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">int</span> *result;</span><br><span class="line"></span><br><span class="line">    result = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = target - nums[i];</span><br><span class="line">        <span class="keyword">for</span> (j = numsSize<span class="number">-1</span>; j &gt; i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == temp)</span><br><span class="line">            &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">free</span>(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Koala 结构的入门</title>
    <url>/2018/12/11/Koala%20%E7%BB%93%E6%9E%84%E7%9A%84%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="koala框架的使用"><a href="#koala框架的使用" class="headerlink" title="koala框架的使用"></a>koala框架的使用</h1><h2 id="编写IDL"><a href="#编写IDL" class="headerlink" title="编写IDL"></a>编写IDL</h2><p>在业务项目目录下创建helloworld目录，进入该目录，然后创建编辑hello.thrift，该文件用来生成基本框架。输入以下内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Result &#123;      <span class="comment">//定义了一个Result结构体，为接口返回的结构体数据</span></span><br><span class="line">    <span class="number">1</span>: <span class="keyword">string</span> response,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service HelloService &#123;    <span class="comment">//定义了一个服务，只有一个接口↓</span></span><br><span class="line">    Result HelloWorld(<span class="number">1</span>:<span class="keyword">string</span> name);  <span class="comment">//HelloWorld,该接口接收一个string参数，返回一个Result结构体，见上。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <a id="more"></a>

<h2 id="生成框架代码"><a href="#生成框架代码" class="headerlink" title="生成框架代码"></a>生成框架代码</h2><p>键入如下命令生成框架代码，请下载最新版本的<a href="http://micode.be.xiaomi.com/soa/soa_tools">thrift工具</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/path/to/soa_tools/thrift --gen go --packagePath micode.be.xiaomi.com/systech/helloworld hello.thrift</span><br></pre></td></tr></table></figure>

<h2 id="编译执行"><a href="#编译执行" class="headerlink" title="编译执行"></a>编译执行</h2><p>执行 ./build.sh 进行编译，编译成功后，生成的程序在bin目录下。</p>
<h2 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h2><p>启动自动构建程序(auto_build.sh)，自动构建程序会实时检测项目目录下源码的是否变更，如果有变更将自动进行编译、重启程序。</p>
<h2 id="了解框架代码结构"><a href="#了解框架代码结构" class="headerlink" title="了解框架代码结构"></a>了解框架代码结构</h2><p>生成的框架代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── auto_build.sh                           &#x2F;&#x2F;自动构建脚本</span><br><span class="line">├── bin</span><br><span class="line">│   └── HelloService</span><br><span class="line">├── build.sh                                &#x2F;&#x2F;编译脚本</span><br><span class="line">├── config</span><br><span class="line">│   ├── scm_config.ini                      </span><br><span class="line">│   ├── scm_config.ini.online.env           &#x2F;&#x2F;线上配置</span><br><span class="line">│   └── scm_config.ini.test.env             &#x2F;&#x2F;测试环境配置</span><br><span class="line">├── hello.thrift                            &#x2F;&#x2F;接口描述文件</span><br><span class="line">├── package.sh                              &#x2F;&#x2F;编译打包脚本，使用请参考：http:&#x2F;&#x2F;mis.n.mi.com&#x2F;koala&#x2F;publish&#x2F;package.html</span><br><span class="line">├── README</span><br><span class="line">├── run                                     &#x2F;&#x2F;启动脚本</span><br><span class="line">├── run.sh                                  &#x2F;&#x2F;带supervise的启动脚本</span><br><span class="line">├── framework                               &#x2F;&#x2F;框架基础代码（无需更改）</span><br><span class="line">│   └── app</span><br><span class="line">│       ├── app.go</span><br><span class="line">│       ├── config.go</span><br><span class="line">│       ├── generate.go</span><br><span class="line">│       ├── global.go</span><br><span class="line">│       ├── initDb.go</span><br><span class="line">│       ├── initRabbitmq.go</span><br><span class="line">│       ├── initRedis.go</span><br><span class="line">│       ├── initRedisMock.go</span><br><span class="line">│       ├── initSqlMock.go</span><br><span class="line">│       ├── manager.go</span><br><span class="line">│       ├── plugin.go</span><br><span class="line">│       ├── register.go</span><br><span class="line">│       ├── rpc.go</span><br><span class="line">│       └── user_config.go</span><br><span class="line">├── hello                                   &#x2F;&#x2F;网络相关基础代码，无需更改</span><br><span class="line">│   ├── constants.go</span><br><span class="line">│   ├── helloservice.go</span><br><span class="line">│   ├── helloservice_host_wrapper.go</span><br><span class="line">│   ├── hello_service-remote</span><br><span class="line">│   │   └── hello_service-remote.go</span><br><span class="line">│   ├── helloservice_wrapper.go</span><br><span class="line">│   └── ttypes.go</span><br><span class="line">├── main</span><br><span class="line">│   ├── HelloService.go</span><br><span class="line">│   ├── HelloWorld_handler.go               &#x2F;&#x2F;HelloWorld的入口文件，需要业务实现</span><br><span class="line">│   ├── hook.go                             &#x2F;&#x2F;框架各个阶段的回调接口，可以实现自定义功能</span><br><span class="line">│   └── main.go</span><br><span class="line">└── model                                   &#x2F;&#x2F;业务model层</span><br><span class="line">└── supervise</span><br><span class="line">    └── supervise</span><br><span class="line">└── glide.yaml                              &#x2F;&#x2F; 依赖说明文件</span><br><span class="line">└── glide.lock                              &#x2F;&#x2F; 依赖版本锁文件</span><br></pre></td></tr></table></figure>

<p>对于 thrift IDL 中定义的每一个接口，会在 main 目录单独一个代码文件，并在接口名后面加上_handler后缀。 例如，对于 hello.thrift 定义的 HelloWorld 接口，生成的实现文件为 main/HelloWorld_handler.go。</p>
<h2 id="实现HelloWorld接口"><a href="#实现HelloWorld接口" class="headerlink" title="实现HelloWorld接口"></a>实现HelloWorld接口</h2><p>打开 main/HelloWorld_handler.go文件，框架生成的源代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;micode.be.xiaomi.com/systech/helloworld/hello&quot;</span></span><br><span class="line">    <span class="string">&quot;micode.be.xiaomi.com/systech/soa/context&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//ctx 用来记录请求在框架运行中当中的上下文，比如traceid以及appid等公共信息</span></span><br><span class="line"><span class="comment">//name 也就是我们IDL中定义的参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloServiceHandler)</span> <span class="title">HelloWorld</span><span class="params">(ctx *context.XContext, name <span class="keyword">string</span>)</span> <span class="params">(r *hello.Result_, errRet error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口返回一个hello.Result结构，以及若有错误产生，返回一个errRet。<br>我们记得，hello.Result_结构体的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Result_ <span class="keyword">struct</span> &#123;</span><br><span class="line">    Response <span class="keyword">string</span> <span class="string">`thrift:&quot;response,1&quot; json:&quot;response&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当处理正常时，返回一个Response字符串。因此，我们的HelloWorld接口非常简单，实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;micode.be.xiaomi.com/systech/helloworld/hello&quot;</span></span><br><span class="line">    <span class="string">&quot;micode.be.xiaomi.com/systech/soa/context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloServiceHandler)</span> <span class="title">HelloWorld</span><span class="params">(context *context.XContext, name <span class="keyword">string</span>)</span> <span class="params">(r *hello.Result_, err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    r = &amp;hello.Result_&#123;&#125;</span><br><span class="line">    r.Response = fmt.Sprintf(<span class="string">&quot;hello world,%s&quot;</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="配置组名和服务名"><a href="#配置组名和服务名" class="headerlink" title="配置组名和服务名"></a>配置组名和服务名</h2><p>启动服务之前必须先在config/scm_config.ini中配置组名和服务名。<br>打开config/scm_config.ini，在group和service两个字段，填入相应的信息。如下所示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">;基础配置</span><br><span class="line">[xbase]</span><br><span class="line">config_type=<span class="built_in">local</span> <span class="comment">#local or etcd</span></span><br><span class="line">config_addr=http://etcd.test.mi.com <span class="comment">#配置中心地址</span></span><br><span class="line">;项目所在的小组名,一定要配置，不配置将会panic，详情请参见mis.n.mi.com</span><br><span class="line">group=systech</span><br><span class="line">;项目的服务名，一定要配置，不配置将会panic，详情请参见mis.n.mi.com </span><br><span class="line">service=hello</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>(注)服务名：服务开发完了之后，通过SOA平台进行注册，注册服务的时候会分配一个唯一的服务名。</p>
<h2 id="启动服务HelloService"><a href="#启动服务HelloService" class="headerlink" title="启动服务HelloService"></a>启动服务HelloService</h2><p>使用如下命令进行启动：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./bin/HelloService</span><br></pre></td></tr></table></figure>

<h1 id="调用和测试"><a href="#调用和测试" class="headerlink" title="调用和测试"></a>调用和测试</h1><h2 id="生成SDK"><a href="#生成SDK" class="headerlink" title="生成SDK"></a>生成SDK</h2><p>通过以下命令，生成Golang的SDK：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/path/to/soa_tools/thrift --gen go --packagePath micode.be.xiaomi.com/your/project ./hello.thrift</span><br></pre></td></tr></table></figure>

<p>生成的SDK在当前目录sdk/v3/目录下。</p>
<p><strong>如果基于 koala v3 开发的项目需要生成 sdk 给 koala v1 或 v2 的项目使用，请使用命令：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/path/to/soa_tools/thrift --gen go --v1 ./hello.thrift</span><br><span class="line">/path/to/soa_tools/thrift --gen go --v2 ./hello.thrift</span><br></pre></td></tr></table></figure>

<p><strong>生成的 SDK 在 sdk/v1/ sdk/v2 目录下。</strong></p>
<h2 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h2><p>golang版rpc包括两种调用方式：</p>
<h3 id="通过IP调用"><a href="#通过IP调用" class="headerlink" title="通过IP调用"></a>通过IP调用</h3><p>一般在开发过程，为了简化调用流程，我们可以直接指定后端服务ip和port进行调用。 在项目目录下(位置任意，只要import了…/helloworld/sdk/v3/hello包即可)新建main.go文件，编辑以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;micode.be.xiaomi.com/systech/helloworld/sdk/v3/hello&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	client:=hello.NewHelloServiceClientHostWrapper(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">12508</span>,<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">	fmt.Println(client.HelloWorld(<span class="string">&quot;xiaoming&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们代码依赖koala基础库，为了简化编译步骤，我们采用脚本进行编译运行，在当前目录下 打开run.sh，输入以下内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">curdir=`<span class="built_in">pwd</span>`</span><br><span class="line">glide init &amp;&amp; glide up</span><br><span class="line">go run <span class="variable">$curdir</span>/main.go</span><br></pre></td></tr></table></figure>
<p>运行run.sh，即可看到程序运行结果。</p>
<h3 id="通过服务名调用"><a href="#通过服务名调用" class="headerlink" title="通过服务名调用"></a>通过服务名调用</h3><p>在测试或线上环境中，我们需要在SOA平台上进行订阅xm_ip_service，然后通过服务名进行调用。 调用代码如下，保存为main.go：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;micode.be.xiaomi.com/your/project/sdk/v3/ip&quot;</span></span><br><span class="line">    <span class="string">&quot;micode.be.xiaomi.com/systech/soa/xrpc&quot;</span></span><br><span class="line">    <span class="string">&quot;micode.be.xiaomi.com/systech/soa/thrift&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化rpc组件,必须要到平台上订阅xm_ip_service服务</span></span><br><span class="line">    <span class="comment">//在本例中，xm_ip_service_client已经订阅了xm_ip_service服务，所以能够调用成功</span></span><br><span class="line">    <span class="comment">//参数1：group 订阅者所在的组名</span></span><br><span class="line">    <span class="comment">//参数2：service 订阅者所在的服务名（项目名）</span></span><br><span class="line">    <span class="comment">//参数3：etcd_host etcd地址，</span></span><br><span class="line">             <span class="number">1.</span> 测试环境为http:<span class="comment">//etcd.test.mi.com </span></span><br><span class="line">             <span class="number">1.</span> 线上环境为http:<span class="comment">//soa01.etcd.b2c.srv:4001</span></span><br><span class="line">    _, err := xrpc.NewXRpcDefault(<span class="string">&quot;misite&quot;</span>, <span class="string">&quot;xm_ip_service_client&quot;</span>, <span class="string">&quot;http://etcd.test.mi.com&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">nil</span>) &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数1：serviceName 调用方的服务名</span></span><br><span class="line">    <span class="comment">//参数2：logid 用来标识一次请求，一般从上游获取，没有可以自己随机生成</span></span><br><span class="line">    <span class="comment">//参数3：rpcId 填0即可</span></span><br><span class="line">    context := thrift.NewXContext(<span class="string">&quot;xm_ip_service_client&quot;</span>, <span class="number">1000</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 参数1：serviceName 服务提供方的服务名</span></span><br><span class="line">    <span class="comment">//2. 参数2：ctx 调用上下文</span></span><br><span class="line">    client := ip.NewIPServiceClientWrapper2(<span class="string">&quot;xm_ip_service&quot;</span>, context)</span><br><span class="line"></span><br><span class="line">    ipList := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">    ipList = <span class="built_in">append</span>(ipList, <span class="string">&quot;100.200.39.4&quot;</span>)</span><br><span class="line">    fmt.Println(client.QueryGeoInfoByIP(ipList))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行测试程序"><a href="#运行测试程序" class="headerlink" title="运行测试程序"></a>运行测试程序</h2><p>正常情况下，将会返回类似如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Result_(&#123;Response:hello world,liuxing1&#125;) &lt;nil&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基本规范</title>
    <url>/2018/12/11/MySQL%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="一、基础规范"><a href="#一、基础规范" class="headerlink" title="一、基础规范"></a>一、基础规范</h1><ol>
<li><strong>使用 INNODB 存储引擎</strong></li>
<li><strong>表字符集使用 UTF8,如遇到EMOJ等表情符号的存储需求，可申请使用UTF8MB4字符集</strong></li>
<li><strong>所有表都需要添加注释</strong></li>
<li>单表数据量建字符类型居多的表建议控制在3000W以内，整型居多的表建议控制在5000W以内</li>
<li><strong>不在数据库中存储图⽚、文件等大数据</strong></li>
<li>禁止在线上做数据库压力测试</li>
<li>禁⽌从测试、开发环境直连数据库</li>
</ol>
<h1 id="二、命名规范"><a href="#二、命名规范" class="headerlink" title="二、命名规范"></a>二、命名规范</h1><ol>
<li><strong>库名表名字段名必须有固定的命名长度，12个字符以内</strong></li>
<li>库名、表名、字段名禁⽌止使⽤用MySQL保留字,比如订单表不要直接叫做order</li>
<li><strong>临时库、表名必须以tmp为前缀，并以⽇日期为后缀</strong></li>
<li><strong>备份库、表必须以bak为前缀，并以日期为后缀</strong></li>
</ol>
<a id="more"></a>

<h1 id="三、库、表、字段开发设计规范"><a href="#三、库、表、字段开发设计规范" class="headerlink" title="三、库、表、字段开发设计规范"></a>三、库、表、字段开发设计规范</h1><ol>
<li><strong>建表默认5字段，主键、创建时间、修改时间。id、create_time、update_time</strong></li>
<li>禁⽌使用分区表</li>
<li>拆分大字段和访问频率低的字段，分离冷热数据</li>
<li><strong>按日期时间分表需符合例如table_201401、table_20140422格式</strong></li>
<li>采用合适的分库分表策略</li>
<li><strong>用 DECIMAL 代替 FLOAT 和 DOUBLE 存储精确浮点数</strong></li>
<li>越简单越好：将字符转化为数字、使用 TINYINT 来代替 ENUM 类型</li>
<li>若使用ENUM类型，不允许修改默认值，只允许顺序添加</li>
<li><strong>所有字段均定义为 NOT NULL</strong></li>
<li><strong>INT类型固定占用 4 字节存储</strong></li>
<li><strong>使用 timestamp 存储时间</strong></li>
<li><strong>使用 VARBINARY 存储大小写敏感的变长字符串</strong></li>
<li><strong>禁止在数据库中存储明文密码，把密码加密后存储</strong></li>
<li>用好数值类型字段</li>
<li><strong>存储ip最好用 int 存储而非 char(15)</strong></li>
<li><strong>避免使用 NULL 字段</strong>， NULL 字段很难查询优化，NULL字段的索引需要额外空间，NULL字段的复合索引无效</li>
<li><strong>少用 text/blob ， varchar 的性能会比 text 高很多，实在避免不了blob，请拆表</strong></li>
<li><strong>数据库中不允许存储大文件，或者照片，可以将大对象放到磁盘上，数据库中存储它的路径</strong></li>
</ol>
<h1 id="四、索引规范"><a href="#四、索引规范" class="headerlink" title="四、索引规范"></a>四、索引规范</h1><p>1、索引的数量要控制：</p>
<ul>
<li><strong>单张表中索引数量不超过5个</strong></li>
<li>单个索引中的字段数不超过5个</li>
<li>对字符串使⽤用前缀索引，前缀索引长度不超过8个字符</li>
<li>建议优先考虑前缀索引，必要时可添加伪列并建立索引</li>
</ul>
<p>2、<strong>主键准则</strong></p>
<ul>
<li><strong>表必须有主键</strong></li>
<li><strong>不使用更新频繁的列作为主键</strong></li>
<li><strong>尽量不选择字符串列作为主键</strong></li>
<li>不使用 UUID MD5 HASH 这些作为主键(数值太离散了)</li>
<li><strong>默认使⽤非空的唯一键作为主键</strong></li>
<li><strong>建议选择自增或发号器</strong></li>
</ul>
<p>3、<strong>重要的SQL必须被索引</strong></p>
<ul>
<li>比如：UPDATE 、 DELETE 语句的 WHERE 条件列,ORDER BY 、 GROUPBY 、 DISTINCT 的字段</li>
</ul>
<p>4、多表JOIN的字段注意以下</p>
<ul>
<li>区分度最大的字段放在前面</li>
<li>核⼼SQL优先考虑覆盖索引</li>
<li>避免冗余和重复索引</li>
<li>索引要综合评估数据密度和分布以及考虑查询和更新比例</li>
</ul>
<p>5、<strong>索引禁忌</strong></p>
<ul>
<li><strong>不在低基数列上建立索引，例如“性别”</strong></li>
<li><strong>不在索引列进行数学运算和函数运算</strong></li>
</ul>
<p>6、<strong>尽量不使用外键</strong></p>
<ul>
<li>外键用来保护参照完整性，可在业务端实现</li>
<li>对父表和子表的操作会相互影响，降低可用性</li>
</ul>
<p>7、索引命名：</p>
<ul>
<li><strong>非唯一索引必须以idx字段1字段2命名，唯一所以必须以 uniq 字段 1 字段 2 命名，索引名称必须全部小写</strong></li>
</ul>
<p>8、<strong>新建的唯一索引必须不能和主键重复</strong></p>
<p>9、<strong>索引字段的默认值不能为 NULL ，要改为其他的 default 或者空。 NULL 非常影响索引的查询效率</strong></p>
<p>10、反复查看与表相关的SQL</p>
<ul>
<li>符合最左前缀的特点建立索引。多条字段重复的语句，要修改语句条件字段的顺序，为其建立一条联合索引，减少索引数量</li>
</ul>
<p>11、<strong>能使用唯一索引就要使用唯一索引，提高查询效率</strong></p>
<p>12、研发要经常使用 explain ，如果发现索引选择性差，必须让他们学会使用hint</p>
<p>13、合理创建联合索引，(a，b，c) 相当于 (a) 、(a，b) 、(a，b，c)</p>
<p>14、不对过长的VARCHAR字段建立索引。建议优先考虑添加CRC32或MD5伪列，并对伪列建立索引，减少索引长度，提高效率。</p>
<h1 id="五、SQL规范"><a href="#五、SQL规范" class="headerlink" title="五、SQL规范"></a>五、SQL规范</h1><ol>
<li>使用prepared statement，可以提升性能并避免SQL注入。</li>
<li>减少与数据库交互次数，尽量采用批量提交SQL语句（INSERT INTO table （column1、column2、column3） VALUES(),(),()），不宜过多看字符个数500-1000即可。</li>
<li>SQL语句尽可能简单，大的SQL想办法拆成小的SQL语句(充分利用QUERYCACHE和充分利用多核CPU)</li>
<li>事务要简单，整个事务的时间长度不要太长</li>
<li>避免使用触发器、函数、存储过程</li>
<li>降低业务耦合度，为sacle out 、 sharding 留有余地</li>
<li><strong>避免在数据库中进⾏数学运算(MySQL不擅长数学运算和逻辑判断)</strong></li>
<li><strong>不要用 SELECT * ，查询哪几个字段就SELECT这几个字段</strong></li>
<li><strong>SQL中使用到OR的改写为用IN()(OR的效率没有IN的效率高)</strong></li>
<li>用in代替or,里面数字的个数建议控制在 1000 以内</li>
<li><strong>LIMIT分页注意效率。</strong></li>
<li><strong>使用 UNION ALL 替代 UNION</strong></li>
<li>避免使用大表的 JOIN</li>
<li><strong>使用 GROUP BY 分组、自动排序</strong></li>
<li><strong>对数据的更新要打散后批量更新，不要一次更新太多数据</strong></li>
<li><strong>减少与数据库的交互次数</strong></li>
<li>注意使用性能分析工具</li>
<li>SQL explain / showprofile / mySQLsla，尽量避免extra列出现：Using File Sort、Using Temporary。</li>
<li><strong>SQL语句要求所有研发，SQL关键字全部是大写，每个词只允许有一个空格</strong></li>
<li><strong>SQL语句不可以出现隐式转换，比如 SELECT id FROM TABLE WHERE id=’1’</strong></li>
<li>IN条件里面的数据数量要少，我记得应该是500个以内，要学会使用EXIST代替IN，EXIST在一些场景查询会比IN快</li>
<li><strong>能不用 NOT IN 就不用 NOTIN ，坑太多了。。会把空和NULL给查出来</strong></li>
<li><strong>在SQL语句中，禁止使用前缀是%的LIKE</strong></li>
<li><strong>不使用负向查询，如 NOT IN / LIKE</strong></li>
<li><strong>关于分页查询：程序里建议合理使用分页来提高效率LIMIT，OFFSET较大要配合子查询使用</strong></li>
<li><strong>禁止在数据库中跑大查询</strong></li>
<li>使⽤预编译语句，只传参数，比传递SQL语句更高效；一次解析，多次使用；降低SQL注入概率</li>
<li><strong>禁止使 ORDER BY RAND()</strong></li>
<li>禁⽌单条SQL语句同时更新多个表</li>
<li><strong>禁止使用%前导查询，例如：like “%abc”，无法利用到索引。</strong></li>
<li><strong>禁止使用负向查询，例如 not in、!=、not like、&lt;&gt;。</strong></li>
</ol>
<h1 id="六、常见类型建议"><a href="#六、常见类型建议" class="headerlink" title="六、常见类型建议"></a>六、常见类型建议</h1><ul>
<li><strong>小米帐号(user_id/mi_id):bigint</strong></li>
<li><strong>订单号(order_id):bigint</strong></li>
<li><strong>钱相关(price/money):bigint(看需求按分或者厘做单位)</strong></li>
<li>sku()</li>
<li>商品id</li>
<li>货品id</li>
<li><strong>微信open_id</strong></li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 教程</title>
    <url>/2018/12/11/redis%20%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="redis-教程"><a href="#redis-教程" class="headerlink" title="redis 教程"></a><a href="http://www.runoob.com/redis/redis-tutorial.html">redis 教程</a></h1><p>redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy2x4m6m1mj30ki0d8di9.jpg"></p>
<p>redis是一个字典结构的存储服务器，而实际上一个redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。这与我们熟知的在一个关系数据库实例中可以创建多个数据库类似，所以可以将其中的每个字典都理解成一个独立的数据库。</p>
<a id="more"></a>

<h1 id="redis的安装和启动："><a href="#redis的安装和启动：" class="headerlink" title="redis的安装和启动："></a>redis的安装和启动：</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure>

<p>启动redis服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew services start redis</span><br></pre></td></tr></table></figure>

<p>启动redis客户端</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure>

<p>如果出现中文乱码，则要在 redis-cli 后面加上 –raw</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli /--raw</span><br></pre></td></tr></table></figure>

<p>远程服务上执行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli -h host -p port -a password</span><br></pre></td></tr></table></figure>

<p>检查连接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PING//PONG显示连接成功</span><br></pre></td></tr></table></figure>

<h1 id="redis-常用命令"><a href="#redis-常用命令" class="headerlink" title="redis  常用命令"></a>redis  常用命令</h1><h2 id="redis-数据操作命令"><a href="#redis-数据操作命令" class="headerlink" title="redis 数据操作命令"></a>redis 数据操作命令</h2><p>redis 数据操作命令的基本语法如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; COMMAND KEY_NAME</span><br></pre></td></tr></table></figure>

<p><a href="http://www.runoob.com/redis/redis-keys.html">redis 键(key)</a><br><a href="http://www.runoob.com/redis/redis-strings.html">redis 字符串(String)</a><br><a href="http://www.runoob.com/redis/redis-hashes.html">redis 哈希(Hash)</a><br><a href="http://www.runoob.com/redis/redis-lists.html">redis 列表(List)</a><br><a href="http://www.runoob.com/redis/redis-sets.html">redis 集合(Set)</a><br><a href="http://www.runoob.com/redis/redis-sorted-sets.html">redis 有序集合(sorted set)</a><br><a href="http://www.runoob.com/redis/redis-hyperloglog.html">redis HyperLogLog</a></p>
<h2 id="redis-发布订阅"><a href="#redis-发布订阅" class="headerlink" title="redis 发布订阅"></a>redis 发布订阅</h2><p>redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。<br>redis 客户端可以订阅任意数量的频道。</p>
<p><a href="http://www.runoob.com/redis/redis-pub-sub.html">redis 发布订阅</a></p>
<p>实例<br>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;redisChat&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PUBLISH redisChat <span class="string">&quot;redis is a great caching technique&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; PUBLISH redisChat <span class="string">&quot;Learn redis by runoob.com&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 订阅者的客户端会显示如下消息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;redisChat&quot;</span></span><br><span class="line">3) <span class="string">&quot;redis is a great caching technique&quot;</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;redisChat&quot;</span></span><br><span class="line">3) <span class="string">&quot;Learn redis by runoob.com&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="redis-事务"><a href="#redis-事务" class="headerlink" title="redis 事务"></a>redis 事务</h2><p>redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。<br>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。一个事务从开始到执行会经历以下三个阶段：</li>
</ul>
<ol>
<li>开始事务。</li>
<li>命令入队。</li>
<li>执行事务。</li>
</ol>
<hr>
<p>实例<br>以下是一个事务的例子， 它先以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <strong>EXEC</strong> 命令触发事务， 一并执行事务中的所有命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET book-name <span class="string">&quot;Mastering C++ in 21 days&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; GET book-name</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SADD tag <span class="string">&quot;C++&quot;</span> <span class="string">&quot;Programming&quot;</span> <span class="string">&quot;Mastering Series&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS tag</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;Mastering C++ in 21 days&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 3</span><br><span class="line">4) 1) <span class="string">&quot;Mastering Series&quot;</span></span><br><span class="line">   2) <span class="string">&quot;C++&quot;</span></span><br><span class="line">   3) <span class="string">&quot;Programming&quot;</span></span><br></pre></td></tr></table></figure>

<p>单个 redis 命令的执行是原子性的，但 redis 没有在事务上增加任何维持原子性的机制，所以 redis 事务的执行并不是原子性的。<br>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p>
<blockquote>
<p>这是官网上的说明 From redis docs on transactions:  </p>
<p>It’s important to note that even when a command fails, all the other commands in the queue are processed – redis will not stop the processing of commands.  </p>
</blockquote>
<p>实例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:7000&gt; multi</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7000&gt; <span class="built_in">set</span> a aaa</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7000&gt; <span class="built_in">set</span> b bbb</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7000&gt; <span class="built_in">set</span> c ccc</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7000&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br></pre></td></tr></table></figure>

<p>如果在 set b bbb 处失败，set a 已成功不会回滚，set c 还会继续执行。</p>
<hr>
<p>redis 事务命令<br>下表列出了 redis 事务的相关命令：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fy2x4mq7ycj30n509zq3s.jpg"></p>
<h2 id="redis-脚本"><a href="#redis-脚本" class="headerlink" title="redis 脚本"></a>redis 脚本</h2><p>redis 脚本使用 Lua 解释器来执行脚本。 redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 <strong>EVAL</strong></p>
<p><a href="http://www.runoob.com/redis/redis-scripting.html">redis 脚本</a></p>
<h2 id="redis-连接"><a href="#redis-连接" class="headerlink" title="redis 连接"></a>redis 连接</h2><p>redis 连接命令主要是用于连接 redis 服务。<br>实例<br>以下实例演示了客户端如何通过密码验证连接到 redis 服务，并检测服务是否在运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; AUTH <span class="string">&quot;password&quot;</span> //验证密码是否正确</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; PING            //查看服务是否运行</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>

<ul>
<li>ECHO message   :  打印字符串</li>
<li>QUIT  : 关闭当前连接</li>
<li>SELECT index  : 切换到指定的数据库</li>
</ul>
<h2 id="redis-服务器"><a href="#redis-服务器" class="headerlink" title="redis 服务器"></a>redis 服务器</h2><p>redis 服务器命令主要是用于管理 redis 服务。</p>
<p><a href="http://www.runoob.com/redis/redis-server.html">redis 服务器</a></p>
<h1 id="redis-高级使用教程"><a href="#redis-高级使用教程" class="headerlink" title="redis 高级使用教程"></a>redis 高级使用教程</h1><h2 id="redis数据备份与恢复"><a href="#redis数据备份与恢复" class="headerlink" title="redis数据备份与恢复"></a>redis数据备份与恢复</h2><h3 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h3><p>redis <strong>SAVE</strong> 命令用于创建当前数据库的备份。<br>语法<br>redis <strong>Save</strong> 命令基本语法如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SAVE </span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SAVE </span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>该命令将在 redis 安装目录中创建dump.rdb文件。</p>
<h3 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h3><p>如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 <strong>CONFIG</strong> 命令，如下所示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET dir</span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/usr/local/redis/bin&quot;</span></span><br></pre></td></tr></table></figure>

<p>以上命令 <strong>CONFIG GET dir</strong> 输出的 redis 安装目录为<code>\_usr\_local\_redis\_bin</code>。</p>
<h3 id="BGSAVE"><a href="#BGSAVE" class="headerlink" title="BGSAVE"></a><strong>BGSAVE</strong></h3><p>创建 redis 备份文件也可以使用命令 <strong>BGSAVE</strong>，该命令在后台执行。<br>实例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BGSAVE</span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure>

<h2 id="redis-安全"><a href="#redis-安全" class="headerlink" title="redis 安全"></a>redis 安全</h2><p>我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。<br>实例<br>我们可以通过以下命令查看是否设置了密码验证：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。<br>你可以通过以下命令来修改该参数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG <span class="built_in">set</span> requirepass <span class="string">&quot;runoob&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; CONFIG get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;runoob&quot;</span></span><br></pre></td></tr></table></figure>

<p>设置密码后，客户端连接 redis 服务就需要密码验证，否则无法执行命令。<br>语法<br>AUTH 命令基本语法格式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; AUTH password</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; AUTH <span class="string">&quot;runoob&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SET mykey <span class="string">&quot;Test value&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GET mykey</span><br><span class="line"><span class="string">&quot;Test value&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="redis-性能测试"><a href="#redis-性能测试" class="headerlink" title="redis 性能测试"></a>redis 性能测试</h2><p>redis 性能测试是通过同时执行多个命令实现的。<br>语法<br>redis 性能测试的基本命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-benchmark [option] [option value]</span><br></pre></td></tr></table></figure>

<p>实例<br>以下实例同时执行 10000 个请求来检测性能：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ redis-benchmark -n 10000  -q</span><br><span class="line">PING_INLINE: 141043.72 requests per second</span><br><span class="line">PING_BULK: 142857.14 requests per second</span><br><span class="line">SET: 141442.72 requests per second</span><br><span class="line">GET: 145348.83 requests per second</span><br><span class="line">INCR: 137362.64 requests per second</span><br><span class="line">LPUSH: 145348.83 requests per second</span><br><span class="line">LPOP: 146198.83 requests per second</span><br><span class="line">SADD: 146198.83 requests per second</span><br><span class="line">SPOP: 149253.73 requests per second</span><br><span class="line">LPUSH (needed to benchmark LRANGE): 148588.42 requests per second</span><br><span class="line">LRANGE_100 (first 100 elements): 58411.21 requests per second</span><br><span class="line">LRANGE_300 (first 300 elements): 21195.42 requests per second</span><br><span class="line">LRANGE_500 (first 450 elements): 14539.11 requests per second</span><br><span class="line">LRANGE_600 (first 600 elements): 10504.20 requests per second</span><br><span class="line">MSET (10 keys): 93283.58 requests per second</span><br></pre></td></tr></table></figure>

<p>redis 性能测试工具可选参数如下所示：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">选项</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">-h</td>
<td align="left">指定服务器主机名</td>
<td align="left">127.0.0.1</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">-p</td>
<td align="left">指定服务器端口</td>
<td align="left">6379</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">-s</td>
<td align="left">指定服务器</td>
<td align="left">socket</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">-c</td>
<td align="left">指定并发连接数</td>
<td align="left">50</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">-n</td>
<td align="left">指定请求数</td>
<td align="left">10000</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">-d</td>
<td align="left">以字节的形式指定SET/GET值的数据大小</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">-k</td>
<td align="left">1=keepalive0=reconnect</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">-r</td>
<td align="left">SET_GET_INCR使用随机key,SADD</td>
<td align="left">使用随机值</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">-P</td>
<td align="left">通过管道传输<numreq>请求</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">-q</td>
<td align="left">强制退出redis</td>
<td align="left">仅显示query/sec值</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">–csv</td>
<td align="left">以CSV格式输出</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">-l</td>
<td align="left">生成循环，永久执行测试</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">-t</td>
<td align="left">仅运行以逗号分隔的测试命令列表</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">-I</td>
<td align="left">Idle模式，仅打开N个idle连接并等待</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>实例<br>以下实例我们使用了多个参数来测试 redis 性能：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ redis-benchmark -h 127.0.0.1 -p 6379 -t <span class="built_in">set</span>,lpush -n 10000 -q</span><br><span class="line">SET: 146198.83 requests per second</span><br><span class="line">LPUSH: 145560.41 requests per second</span><br></pre></td></tr></table></figure>

<p>以上实例中主机为 127.0.0.1，端口号为 6379，执行的命令为 <strong>SET,LPUSH</strong>，请求数为 10000，通过 -q 参数让结果只显示每秒执行的请求数。</p>
<h2 id="redis-客户端连接"><a href="#redis-客户端连接" class="headerlink" title="redis 客户端连接"></a>redis 客户端连接</h2><p>redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，redis 内部会进行以下一些操作：</p>
<ul>
<li>首先，客户端 socket 会被设置为非阻塞模式，因为 redis 在网络事件处理上采用的是非阻塞多路复用模型。</li>
<li>然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法</li>
<li>然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送</li>
</ul>
<hr>
<h3 id="最大连接数"><a href="#最大连接数" class="headerlink" title="最大连接数"></a>最大连接数</h3><p>在 redis2.4 中，最大连接数是被直接硬编码在代码里面的，而在2.6版本中这个值变成可配置的。<br>maxclients 的默认值是 10000，你也可以在 redis.conf 中对这个值进行修改。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">config get maxclients</span><br><span class="line">1) <span class="string">&quot;maxclients&quot;</span></span><br><span class="line">2) <span class="string">&quot;10000&quot;</span></span><br></pre></td></tr></table></figure>

<p>实例<br>以下实例我们在服务启动时设置最大连接数为 100000：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server --maxclients 100000</span><br></pre></td></tr></table></figure>

<h3 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h3><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy2x4mgzc9j30n40a7aat.jpg"></p>
<h2 id="redis-管道技术"><a href="#redis-管道技术" class="headerlink" title="redis 管道技术"></a>redis 管道技术</h2><p>redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：</p>
<ul>
<li>客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。</li>
<li>服务端处理命令，并将结果返回给客户端。</li>
</ul>
<hr>
<p>redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。<br>实例<br>查看 redis 管道，只需要启动 redis 实例并输入以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">echo</span> -en <span class="string">&quot;PING\r\n SET runoobkey redis\r\nGET runoobkey\r\nINCR visitor\r\nINCR visitor\r\nINCR visitor\r\n&quot;</span>; sleep 10) | nc localhost 6379</span><br><span class="line">+PONG</span><br><span class="line">+OK</span><br><span class="line">redis</span><br><span class="line">:1</span><br><span class="line">:2</span><br><span class="line">:3</span><br></pre></td></tr></table></figure>

<p>以上实例中我们通过使用 PING 命令查看redis服务是否可用， 之后我们设置了 runoobkey 的值为 redis，然后我们获取 runoobkey 的值并使得 visitor 自增 3 次。在返回的结果中我们可以看到这些命令一次性向 redis 服务提交，并最终一次性读取所有服务端的响应</p>
<hr>
<blockquote>
<p>管道技术的优势:<br>管道技术最显著的优势是提高了 <strong>redis</strong> 服务的性能。</p>
</blockquote>
<hr>
<p><strong>一些测试数据</strong><br>在下面的测试中，我们将使用redis的Ruby客户端，支持管道技术特性，测试管道技术对速度的提升效果。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">require <span class="string">&#x27;rubygems&#x27;</span> </span><br><span class="line">require <span class="string">&#x27;redis&#x27;</span></span><br><span class="line">def bench(descr) </span><br><span class="line">start = Time.now </span><br><span class="line">yield </span><br><span class="line">puts <span class="string">&quot;#&#123;descr&#125; #&#123;Time.now-start&#125; seconds&quot;</span> </span><br><span class="line">end</span><br><span class="line">def without_pipelining </span><br><span class="line">r = redis.new </span><br><span class="line">10000.times &#123; </span><br><span class="line">    r.ping </span><br><span class="line">&#125; </span><br><span class="line">end</span><br><span class="line">def with_pipelining </span><br><span class="line">r = redis.new </span><br><span class="line">r.pipelined &#123; </span><br><span class="line">    10000.times &#123; </span><br><span class="line">        r.ping </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">end</span><br><span class="line">bench(<span class="string">&quot;without pipelining&quot;</span>) &#123; </span><br><span class="line">    without_pipelining </span><br><span class="line">&#125; </span><br><span class="line">bench(<span class="string">&quot;with pipelining&quot;</span>) &#123; </span><br><span class="line">    with_pipelining </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从处于局域网中的Mac OS X系统上执行上面这个简单脚本的数据表明，开启了管道操作后，往返延时已经被改善得相当低了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">without pipelining 1.185238 seconds </span><br><span class="line">with pipelining 0.250783 seconds</span><br></pre></td></tr></table></figure>

<p>如你所见，开启管道后，我们的速度效率提升了5倍。</p>
<h2 id="redis-分区"><a href="#redis-分区" class="headerlink" title="redis 分区"></a>redis 分区</h2><p>分区是分割数据到多个redis实例的处理过程，因此每个实例只保存key的一个子集。</p>
<h3 id="分区的优势"><a href="#分区的优势" class="headerlink" title="分区的优势"></a>分区的优势</h3><ul>
<li>通过利用多台计算机内存的和值，允许我们构造更大的数据库。</li>
<li>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。</li>
</ul>
<h3 id="分区的不足"><a href="#分区的不足" class="headerlink" title="分区的不足"></a>分区的不足</h3><p>redis的一些特性在分区方面表现的不是很好：</p>
<ul>
<li>涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。</li>
<li>涉及多个key的redis事务不能使用。</li>
<li>当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。</li>
<li>增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。</li>
</ul>
<hr>
<h3 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h3><p>redis 有两种类型分区。 假设有4个redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个redis服务。</p>
<h4 id="范围分区"><a href="#范围分区" class="headerlink" title="范围分区"></a>范围分区</h4><p>最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的redis实例。<br>比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。<br>这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各 种对象的映射表，通常对redis来说并非是好的方法。</p>
<h4 id="哈希分区"><a href="#哈希分区" class="headerlink" title="哈希分区"></a>哈希分区</h4><p>另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单：</p>
<ul>
<li>用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。</li>
<li>对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个redis实例中的一个了。93024922 % 4 = 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Moments 朋友圈应用设计</title>
    <url>/2018/12/11/Moments%20%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="需求↓"><a href="#需求↓" class="headerlink" title="需求↓"></a>需求↓</h1><p>做一个看板任务(照着微信朋友圈来,不过所有用户全部看成朋友即可)</p>
<blockquote>
<ol>
<li>用户可以登录,可以保持登录状态</li>
<li>用户可以发布一个想法,包含一段文字,0-4张图片(保存图片链接即可)</li>
<li>用户可以查看大家发布的说说,按时间顺序从新展示,需分页,一页20个</li>
<li>用户可以评论想法,也可以删除自己的评论</li>
<li>用户可以点赞/取消点赞想法</li>
<li>消息通知,点赞回复要通知所有和说说相关的人</li>
</ol>
</blockquote>
<blockquote>
<p>不做界面,规划好接口,数据库,且完成即可<br>数据库尽可能满足 一对一  一对多  多对多 关系,不要求字段冗余<br>使用HTTP协议,框架自选(iris,beego等都行)  </p>
</blockquote>
<p>进度安排:</p>
<ol>
<li>设计好数据库</li>
<li>规划好接口</li>
<li>做好登录认证</li>
<li>完成接口</li>
</ol>
<a id="more"></a>

<h1 id="数据库实现"><a href="#数据库实现" class="headerlink" title="数据库实现"></a>数据库实现</h1><p><a href="https://jingyan.baidu.com/article/624e745961c6a134e9ba5a40.html">数据库E-R图怎么画？</a></p>
<blockquote>
<p>实体，属性，关系；实体就是一个个对象，比如猫；属性就是实体所有的某个属性，比如猫的性别；关系就是实体和实体之间或者实体内部之间的关系。<br>在ER图中，<strong>矩形代表实体，椭圆代表属性，菱形代表关系</strong>，各个形状之间用线段连接。  </p>
</blockquote>
<p>在本项目中，实体有</p>
<ol>
<li>内容发布者</li>
<li>朋友圈发布项</li>
<li>朋友圈的评论项</li>
</ol>
<p>内容发布者对应属性：</p>
<ul>
<li>用户ID（系统内部）（主键）</li>
<li>用户姓名（界面展示）</li>
<li>用户密码</li>
</ul>
<p>朋友圈标志属性：</p>
<ul>
<li>发布ID(每个发布者发布朋友圈时调用，自增1，本身具有时间顺序特性)（主键）</li>
<li>发布者用户ID（外键）</li>
<li>创建时间（显示在朋友圈下方）</li>
<li>照片列：照片url;照片url;照片url;照片url</li>
<li>配文字符串</li>
</ul>
<p>评论属性：（评论归属于单个用户，并且此用户为接收者，而不是发布者）</p>
<ul>
<li>用户ID（评论创建者，用来检索对应的用户名，以展示用户评论）（外键）</li>
<li>所属朋友圈，即发布ID（和用户ID组合作为主键）（外键）</li>
<li>评论创建时间（按时间顺序显示评论）</li>
<li>评论内容字符串</li>
<li>点赞与否</li>
</ul>
<h2 id="数据库设计思路"><a href="#数据库设计思路" class="headerlink" title="数据库设计思路"></a>数据库设计思路</h2><blockquote>
<p>做一个看板任务(照着微信朋友圈来,不过所有用户全部看成朋友即可)</p>
<ol>
<li>用户可以登录,可以保持登录状态  </li>
<li>用户可以发布一个想法,包含一段文字,0-4张图片(保存图片链接即可)</li>
<li>用户可以查看大家发布的说说,按时间顺序从新展示,需分页,一页20个</li>
<li>用户可以评论想法,也可以删除自己的评论</li>
<li>用户可以点赞/取消点赞想法</li>
<li>消息通知,点赞回复要通知所有和说说相关的人</li>
</ol>
</blockquote>
<p>不做界面,规划好接口,数据库,且完成即可<br>数据库尽可能满足 一对一 一对多 多对多 关系,不要求字段冗余<br>使用HTTP协议,框架自选(iris,beego等都行)</p>
<p><strong>微信朋友圈设计架构</strong></p>
<p>微信朋友圈的数据有四个核心的表：</p>
<ol>
<li>发布表，发布表记录了来自所有用户的所有<a href="http://www.woshipm.com/marketing/1023818.html">Feed</a>，比如一个用户发布了几张图片，每张图片的URL，图片在<a href="https://www.cnblogs.com/tinywan/p/6067126.html">CDN</a>里的URL，它有哪些元属性，谁可以看，谁不可以看等等。</li>
<li>相册，相册是每个用户独立的，记录了该用户所发布的所有内容，包括了与图片相关的文字，和无配图文字。</li>
<li>评论， 评论就是针对某个具体发布的朋友评论和点赞操作。</li>
<li>时间线，所谓“刷朋友圈”，就是刷时间线，就是一个用户所有的朋友的发布内容。</li>
</ol>
<p><strong>微信朋友圈的工作流程概述</strong></p>
<ol>
<li><p>比如有两个用户A和B， A和B各自都有各自的相册（可以理解为A和B各自的朋友圈内容），可能在同一台服务器上，也可能在不同服务器上。现在A上传了一张图片到自己的朋友圈。上传图片不经过微信服务器，而是直接上传到最近的CDN节点去，所以非常快。图片上传到CDN后，小王的微信客户端会通知，这里有一个新的发布（比如叫K2），这个发布的图片CDN URL是什么，谁能看这张图片等等此类的元数据。来把这些数据写入发布表中。</p>
</li>
<li><p>在发布表写完之后，会把K2的发布索引到A的相册表中，所以相册表记录得就是每个内容索引指针，相册表写好后会触发一个批处理动作，这个动作就是去跟A的每个好友说，A有一个新的发布，请把这个发布插入到每个好友的时间线里去。</p>
</li>
<li><p>现在B上朋友圈了，而B是A的一个好友，B拉自己的时间线的时候，时间线会获得K2的新发布通知，然后B的微信客户端就会取根据K2的元数据去获取发布表中的一些信息比如：CDN URL，把图片拉到本地。</p>
</li>
</ol>
<blockquote>
<p>在这个过程中，发布是很重要的，因为一方面要写一个自己的数据副本，并写入自己的时间线，还要把这个副本的指针插到所有好友的时间线里面去，如果一个用户有几百个好友的话，这个过程会比较慢一些。这是一个单数据副本写扩散的过程。但是相对应的，读取就很简单。每个用户只需要读取自己的时间线这一个动作就行，不需要去遍历所有的好友相册表。这个是否有一定得数据冗余？？</p>
</blockquote>
<p>参考文献：</p>
<ol>
<li><a href="https://blog.csdn.net/u011035407/article/details/78592787">朋友圈的设计及实现</a></li>
<li><a href="https://blog.csdn.net/u012244016/article/details/70664959">微信与朋友圈后台架构</a></li>
<li><a href="https://www.zhihu.com/question/21909660">微信朋友圈数据库模式如何设计的？</a></li>
<li><a href="https://www.2cto.com/kf/201603/496529.html">微信与朋友圈后台架构的讲解</a></li>
<li><a href="https://blog.csdn.net/sinat_27564919/article/details/70946319">控制朋友圈好友状态可见性的数据表设计</a></li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy2x4kvuemj30m108ydhk.jpg" alt="idea"></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy2x4lt2r6j30m70jjwjr.jpg" alt="er"></p>
<h2 id="数据交互逻辑"><a href="#数据交互逻辑" class="headerlink" title="数据交互逻辑"></a>数据交互逻辑</h2><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><blockquote>
<p>匹配password字段—&gt;若成功，登录操作（http协议）进入看板界面，推送Feed流信息，若失败，拒绝访问，“密码错误，请重新输入密码”，超时锁定。  </p>
</blockquote>
<h3 id="刷朋友圈"><a href="#刷朋友圈" class="headerlink" title="刷朋友圈"></a>刷朋友圈</h3><p>登录成功—&gt;推送publish，按publish_id从大到小排列，展示publish_id最大的20个publish。<br>刷朋友圈的行为即为刷取多个朋友圈信息（publish）对于单个publish:</p>
<ul>
<li>获取创建时间—&gt;拉取create_time在左下方显示；  </li>
<li>获取照片—&gt;拉取picture表中，publish_id对应的pic_url；</li>
<li>获取朋友圈文字—&gt;拉取caption；</li>
<li>获取评论—&gt;拉取comment表中，publish_id对应的comment，根据comment_id进行从大到小排序，根据usr_id，检索出usr_name(即评论人)，拉取comments,和comment create_time（整体显示情况即为：评论人，评论，评论创建的时间)；</li>
<li>获取点赞信息—&gt;拉取like表中，publish_id对应的like项，并根据like_id,从大到小排序（整体显示情况即为：点赞人A，点赞人B，点赞人C…）</li>
</ul>
<h3 id="发布朋友圈"><a href="#发布朋友圈" class="headerlink" title="发布朋友圈"></a>发布朋友圈</h3><p>创建一个新的publish表项，publish_id自增1，根据当前用户，填入当前usr_id,录入当前时间到create_time，将朋友圈文字信息，录入到caption字段中；  </p>
<p>若有照片，每个照片创建一个picture表项，录入pic_url和当前publish_id，pic_id自增1  </p>
<h3 id="评论朋友圈"><a href="#评论朋友圈" class="headerlink" title="评论朋友圈"></a>评论朋友圈</h3><p>创建一个新的comment表项，comment_id自增1，根据当前用户，填入当前usr_id,录入当前时间到create_time，将评论文字信息，录入到comments字段中，并录入当前评论的publish_id；</p>
<p>创建Notice，根据当前评论的publish_id，检索，当前Notice表中，具有同样publish_id的Notice，查看其中的from_id和to_id，即为所有相关的用户，创建对应的Notice，notice_id自增1，publish_id即为当前评论的publish_id，type为0（0为评论，1为点赞），from_id为当前评论的用户，to_id依次为检索到的所有用户ID，status为0（0未读，1已读）；  </p>
<h3 id="点赞朋友圈"><a href="#点赞朋友圈" class="headerlink" title="点赞朋友圈"></a>点赞朋友圈</h3><p>创建一个新的like表项，like_id自增1，根据当前用户，填入当前usr_id，填入当前点赞的publish_id；<br>创建Notice，根据当前评论的publish_id，检索，当前Notice表中，具有同样publish_id的Notice，查看其中的from_id和to_id，即为所有相关的用户，创建对应的Notice，notice_id自增1，publish_id即为当前评论的publish_id，type为1（0为评论，1为点赞），from_id为当前评论的用户，to_id依次为检索到的所有用户ID，status为0（0未读，1已读）；  </p>
<h3 id="推送评论通知基本逻辑"><a href="#推送评论通知基本逻辑" class="headerlink" title="推送评论通知基本逻辑"></a>推送评论通知基本逻辑</h3><ul>
<li><em>接收通知的用户，通知详情需要主动获取</em></li>
<li><em>通知的主动推送，本质为当前用户定时，每秒查看，有多少条未读通知</em> (*)</li>
<li>根据Notice表，主动获取通知，定时获取to_id与当前用户usr_id相符，且status字段为0（未读）的Notice。通知格式为“您有N条消息未读”。并同时存储这些Notice的notice_id</li>
<li>当用户点击通知，读取通知时，检索存储的notice_id，将这些Notice的status字段置为1，并根据type获知通知类型，若type=0为评论，则查找comment表项，查找对应publish_id中<code>usr_id=from_id</code>的comments字段，获取评论详情(from_id+comments)，上方要同时拉取对应publish_id的朋友圈详情(usr_id+pic+caption+create_time)；若type=1为点赞，则拉取对应publish_id的朋友圈详情，并显示，”(from_id) like this”，上方要同时拉取对应publish_id的朋友圈详情(usr_id+pic+caption+create_time)</li>
</ul>
<h3 id="通知的几种特殊情况的考虑"><a href="#通知的几种特殊情况的考虑" class="headerlink" title="通知的几种特殊情况的考虑"></a>通知的几种特殊情况的考虑</h3><ul>
<li>(未评论用户)取消点赞后，需要去掉该用户的Notice</li>
<li>(未点赞用户)删除评论后，需要去掉该用户的Notice</li>
<li>阅读过通知后，通知需要保留，将状态置为已读，当后续还有人评论时，可以根据Notice表自动维护之后的通知。</li>
<li>每一次的通知都可以直接通过上一次通知进行维护更新。第一步，找到对应的publish_id中notice_id的最大的一项，找出对应的from_id，即找出了，本朋友圈上一次的通知，是从from_id，通知到了此用户的所有to_id。即所有最新的相关用户群，则更新的Notice为，from_id=当前usr_id，to_id=上一次的from_id+上一次的所有的to_id。</li>
<li><em>初次生成的通知会被立刻调用，所以也可以直接在生成的时候，直接推送。</em> （*）</li>
</ul>
<h2 id="MySQL设计规范"><a href="#MySQL设计规范" class="headerlink" title="MySQL设计规范"></a><a href="/2018/12/11/MySQL%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83/">MySQL设计规范</a></h2><blockquote>
<p>详情，点击标题跳转页面↑</p>
</blockquote>
<hr>
<h1 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h1><h2 id="接口基础函数"><a href="#接口基础函数" class="headerlink" title="接口基础函数"></a>接口基础函数</h2><h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><blockquote>
<p>Beego框架中，Controller的Prepare函数都会自动在调用其之前先被调用。<br>所以Prepare函数，被我用来写验证相关的代码。</p>
</blockquote>
<p>①假如当前是在进行非登录操作，则需要验证，session_id，若为空，则未登录，跳转到登录操作页面<br>②若不为空，则在redis中进行比对，看是否存在当前用户的session_id，K-VOUSMEVOYEZ结构为“K:session_id,VOUSMEVOYEZ:usr_name”，若查找当前session_id，得到的用户为空，则未登录，跳转到登录操作页面；得到的用户名非空，还需要验证一下用户表中是否存在该用户，不存在则显示为仿冒用户<br>③若不存在session_id的问题，执行完Prepare函数仍未被跳转到登录页面，则继续执行Controller</p>
<h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><p>一个跳转函数，用来控制，当出现错误或者验证安全的问题时，及时做出反馈，当出现系统性错误时，停止系统的运行，当出现验证问题时，及时跳转到所需页面，如登录页面等。<br><strong>msg</strong>：用来描述当前问题，并写入到跳转页面<br><strong>url</strong>：用来描述跳转链接，当为空时，停止运行当前controller</p>
<h3 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h3><blockquote>
<p>Beego框架中，任何Controller的Finish函数都会自动在调用后，最后时刻被调用，所以Finish函数，被我用来写Session的控制。</p>
</blockquote>
<p>①假如当前是在进行非登录登出操作，需要验证后，为当前Session_id，续期30分钟<br>②假如是登录操作，需要为当前用户创建一个session_id,存到redis中，并发送给客户端</p>
<hr>
<h2 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h2><h3 id="Login"><a href="#Login" class="headerlink" title="Login"></a>Login</h3><p><strong>路由</strong>：”/admin/login”<br>用户登录输入用户名密码，以Json格式发送至客户端，若存在Session，且和服务器内Session_id相符，则直接验证通过</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UsrInfo 用户评价时提交的表单</span></span><br><span class="line"><span class="keyword">type</span> UsrInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	UsrName  <span class="keyword">string</span> <span class="string">`form:&quot;usr_name&quot;`</span></span><br><span class="line">	Password <span class="keyword">string</span> <span class="string">`form:&quot;password&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输入</strong>：Body包含用户名密码的Json格式文档，或其他包含Session_id的Json格式文档<br>通过解析Json，解析出用户名，密码，和Session_id：<br>①假如Session_id非空，且在Redis中存在，则更新Redis，直接进入下一步；<br>②假如Session_id非空，但在Redis中不存在，则登录超时，要求重新登录，进入登录界面<br>③假如Session_id为空，则进入登录界面，解析客户端发送过来的用户名密码，若用户名密码匹配，则登录成功，并生成一个Session记录，保存在Redis，同时将Session_id作为输出发送给客户端。否则直接返回“用户名或密码错误”，要求重新登录</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LoginResult 传递登录结果</span></span><br><span class="line"><span class="keyword">type</span> LoginResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	Result    <span class="keyword">bool</span>   <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">	UsrID     <span class="keyword">int</span>    <span class="string">`json:&quot;usr_id&quot;`</span></span><br><span class="line">	SessionID <span class="keyword">string</span> <span class="string">`json:&quot;session_id&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：验证结果（true/false）+ session_id + usr_id(给客户端保存)</p>
<h3 id="Logout"><a href="#Logout" class="headerlink" title="Logout"></a>Logout</h3><p><strong>路由</strong>：”/admin/login”<br>用户退出登录的时候，需要清除掉当前用户的Session_id。然后跳转到登录页面。</p>
<p><strong>输入</strong>：session_id</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LogoutFeedback 退出登录反馈信息</span></span><br><span class="line"><span class="keyword">type</span> LogoutFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	Result <span class="keyword">bool</span>   <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">	Info   <span class="keyword">string</span> <span class="string">`json:&quot;info&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：返回到登录界面</p>
<hr>
<h2 id="朋友圈接口"><a href="#朋友圈接口" class="headerlink" title="朋友圈接口"></a>朋友圈接口</h2><h3 id="PostMoment-发布朋友圈"><a href="#PostMoment-发布朋友圈" class="headerlink" title="PostMoment(发布朋友圈)"></a>PostMoment(发布朋友圈)</h3><blockquote>
<p>分析：客户端发布朋友圈，通过表单发送给后台，返回一个publish_id,和发布结果；发布朋友圈时，所需要的信息是，用户名，文字信息，和图片，由此构建表单结构体</p>
</blockquote>
<p><strong>路由</strong>：”/feed/post”</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PushMoment is 发送朋友圈时提交的表单</span></span><br><span class="line"><span class="keyword">type</span> PushMoment <span class="keyword">struct</span> &#123;</span><br><span class="line">	UserName <span class="keyword">string</span>   <span class="string">`form:&quot;usr_name&quot;`</span></span><br><span class="line">	Caption  <span class="keyword">string</span>   <span class="string">`form:&quot;caption&quot;`</span></span><br><span class="line">	PicList  []<span class="keyword">string</span> <span class="string">`form:&quot;pic_list&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输入</strong>：朋友圈所需信息的表单。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PostResult 发布朋友圈后的反馈结果</span></span><br><span class="line"><span class="keyword">type</span> PostResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	Result    <span class="keyword">bool</span>  <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">	PublishID <span class="keyword">int64</span> <span class="string">`json:&quot;publish_id&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：true or false 若为true 还需要返回一个当前创建成功后，数据库中publish表的publish_id,方便后期加评价和删除朋友圈。</p>
<h3 id="ReadMoment-刷朋友圈"><a href="#ReadMoment-刷朋友圈" class="headerlink" title="ReadMoment(刷朋友圈)"></a>ReadMoment(刷朋友圈)</h3><blockquote>
<p>分析：由于本需求中，所有人都为朋友，所以所有人的展示结果只跟发送展示请求的时间有关（当做一个锚点），读取朋友圈时，不要读取最新的朋友圈信息，即只刷取，锚点以前，请求时的当前数据库数据。如若不然，会导致分页重复，刷新朋友圈为动态操作（和刷朋友圈区分开，刷朋友圈是静态操作）。最新的朋友圈和评论产生时，只轮询读取到通知，而不拉取最新的朋友圈信息。当用户主动刷新的时候，再读取最新的信息。</p>
</blockquote>
<p><strong>路由</strong>：”/feed/circle”<br>用户登录成功跳转至朋友圈界面，查询当前publish列表，记录此时最新的publish（即为Publish_id最大值），记录为publishAnchor，通过锚点进行分页展示。<br>通过publish_id排列，查找20个最新的朋友圈，将所有的数据打包发送出去。</p>
<p><strong>输入</strong>：publish_index（数据类型int，读取朋友圈信息时publish_id的开始处）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MomentFeed 朋友圈数据流</span></span><br><span class="line"><span class="keyword">type</span> MomentFeed <span class="keyword">struct</span> &#123;</span><br><span class="line">	Moments   []models.OneMoment <span class="string">`json:&quot;Moments&quot;`</span></span><br><span class="line">	PublishID <span class="keyword">int</span>                <span class="string">`json:&quot;publish_id&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OneMoment is 单个朋友圈的Json格式</span></span><br><span class="line"><span class="keyword">type</span> OneMoment <span class="keyword">struct</span> &#123;</span><br><span class="line">	PublishID  <span class="keyword">int</span>         <span class="string">`json:&quot;publish_id&quot;`</span></span><br><span class="line">	UserName   <span class="keyword">string</span>      <span class="string">`json:&quot;usr_name&quot;`</span></span><br><span class="line">	Caption    <span class="keyword">string</span>      <span class="string">`json:&quot;caption&quot;`</span></span><br><span class="line">	PicList    []<span class="keyword">string</span>    <span class="string">`json:&quot;pic_list&quot;`</span></span><br><span class="line">	CreateTime <span class="keyword">string</span>      <span class="string">`json:&quot;create_time&quot;`</span></span><br><span class="line">	LikeList   []<span class="keyword">string</span>    <span class="string">`json:&quot;like_list&quot;`</span></span><br><span class="line">	Comments   CommentList <span class="string">`json:&quot;comments&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OneComment is 单个评论传输时的Json格式</span></span><br><span class="line"><span class="keyword">type</span> OneComment <span class="keyword">struct</span> &#123;</span><br><span class="line">	CommentID      <span class="keyword">int</span>    <span class="string">`json:&quot;comment_id&quot;`</span></span><br><span class="line">	UsrName        <span class="keyword">string</span> <span class="string">`json:&quot;usr_name&quot;`</span></span><br><span class="line">	CommentCaption <span class="keyword">string</span> <span class="string">`json:&quot;comment_caption&quot;`</span></span><br><span class="line">	CreateTime     <span class="keyword">string</span> <span class="string">`json:&quot;create_time&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CommentList is 评论列表，Json格式</span></span><br><span class="line"><span class="keyword">type</span> CommentList []OneComment</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：锚点后的20条朋友圈信息（JSON）。创建一个朋友圈整体信息的结构体。</p>
<p><strong>结构体整体要满足</strong>：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fy6f2yb0clj30s90w2dgr.jpg"></p>
<h3 id="DelMoment-删除朋友圈"><a href="#DelMoment-删除朋友圈" class="headerlink" title="DelMoment(删除朋友圈)"></a>DelMoment(删除朋友圈)</h3><p>根据前端发送来的pubish_id，进行对当前朋友圈的一系列删除，包括，相册表，评论表，点赞表和通知表。<br><strong>路由</strong>：”/feed/del”</p>
<p><strong>输入</strong>：publish_id</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DelFeedInfo 删除朋友圈后的反馈信息</span></span><br><span class="line"><span class="keyword">type</span> DelFeedInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	Result <span class="keyword">bool</span>   <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">	Info   <span class="keyword">string</span> <span class="string">`json:&quot;info&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：反馈信息，true or false</p>
<hr>
<h2 id="评论接口"><a href="#评论接口" class="headerlink" title="评论接口"></a>评论接口</h2><h3 id="CreateComment-发布评论接口"><a href="#CreateComment-发布评论接口" class="headerlink" title="CreateComment(发布评论接口)"></a>CreateComment(发布评论接口)</h3><p>根据前端发送来的评论信息，建立数据库信息，因为前段发来的评论信息，要有，评论相关文字，评论所属对象，和评论所属朋友圈，故建立表单信息进行接收。</p>
<p><strong>路由</strong>：”/feed/comment/create”</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OneComment 用户评价时提交的表单</span></span><br><span class="line"><span class="keyword">type</span> OneComment <span class="keyword">struct</span> &#123;</span><br><span class="line">	UsrID          <span class="keyword">int</span>    <span class="string">`form:&quot;usr_id&quot;`</span></span><br><span class="line">	UsrName        <span class="keyword">string</span> <span class="string">`form:&quot;usr_name&quot;`</span></span><br><span class="line">	CommentCaption <span class="keyword">string</span> <span class="string">`form:&quot;comment_caption&quot;`</span></span><br><span class="line">	PublishID      <span class="keyword">int</span>    <span class="string">`form:&quot;publish_id&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输入</strong>：form</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CreateCommentFeedback 评论创建反馈</span></span><br><span class="line"><span class="keyword">type</span> CreateCommentFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	CommentID    <span class="keyword">int64</span> <span class="string">`json:&quot;comment_id&quot;`</span></span><br><span class="line">	CreateResult <span class="keyword">bool</span>  <span class="string">`json:&quot;create_result&quot;`</span></span><br><span class="line">	NoticeStatus <span class="keyword">bool</span>  <span class="string">`json:&quot;notice_status&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：反馈信息，返回告诉客户端，该评论的comment_id，以及评论成功与否，通知是否已经建立等确认信息。</p>
<h3 id="DelComment-删除评论接口"><a href="#DelComment-删除评论接口" class="headerlink" title="DelComment(删除评论接口)"></a>DelComment(删除评论接口)</h3><p>给出对应的comment_id，删除所有的相关信息。改动涉及：comment表和notice表</p>
<p><strong>路由</strong>：”/feed/comment/del”</p>
<p><strong>输入</strong>：comment_id</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DelCommentFeedback 评论创建反馈</span></span><br><span class="line"><span class="keyword">type</span> DelCommentFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	DelResult       <span class="keyword">bool</span>   <span class="string">`json:&quot;del_result&quot;`</span></span><br><span class="line">	DelNoticeResult <span class="keyword">bool</span>   <span class="string">`json:&quot;del_notice_status&quot;`</span></span><br><span class="line">	Info            <span class="keyword">string</span> <span class="string">`json:&quot;info&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：反馈信息，返回告诉客户端，评论删除与否，评论涉及的通知信息删除与否。</p>
<hr>
<h2 id="点赞接口"><a href="#点赞接口" class="headerlink" title="点赞接口"></a>点赞接口</h2><h3 id="LIke（点赞）"><a href="#LIke（点赞）" class="headerlink" title="LIke（点赞）"></a>LIke（点赞）</h3><p>点赞过程中，需要在点赞表中建立一条新信息，相应的，点赞通知的建立，需要通过CreateNotice遍历的在Notice表中建立多条信息。所以需要usr_id ,usr_name ，publish_id 三个信息，以上信息以表单形式传递。</p>
<p><strong>路由</strong>：”/feed/like/create</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Like is 前端大赞操作发送来的表单</span></span><br><span class="line"><span class="keyword">type</span> Like <span class="keyword">struct</span> &#123;</span><br><span class="line">	UsrID     <span class="keyword">int</span>    <span class="string">`form:&quot;usr_id&quot;`</span></span><br><span class="line">	UsrName   <span class="keyword">string</span> <span class="string">`form:&quot;usr_name&quot;`</span></span><br><span class="line">	PublishID <span class="keyword">int</span>    <span class="string">`form:&quot;publish_id&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输入</strong>：点赞表单：Like结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CreateLikeFeedback 创建点赞后给出的反馈信息</span></span><br><span class="line"><span class="keyword">type</span> CreateLikeFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	LikeID       <span class="keyword">int</span>  <span class="string">`json:&quot;like_id&quot;`</span></span><br><span class="line">	CreateResult <span class="keyword">bool</span> <span class="string">`json:&quot;create_result&quot;`</span></span><br><span class="line">	NoticeStatus <span class="keyword">bool</span> <span class="string">`json:&quot;notice_status&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：反馈信息，返回告诉客户端，创建的点赞的ID是多少，创建结果如何，通知是否创建成果的信息。</p>
<h3 id="CancelLike-取消点赞"><a href="#CancelLike-取消点赞" class="headerlink" title="CancelLike(取消点赞)"></a>CancelLike(取消点赞)</h3><p>取消点赞，得到取消点赞的对应like_id即可，删除like表中对应的信息，并同时删除对应的通知信息。</p>
<p><strong>路由</strong>：”/feed/like/cancel</p>
<p><strong>输入</strong>：like_id</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CancelLikeFeedback 取消点赞反馈</span></span><br><span class="line"><span class="keyword">type</span> CancelLikeFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	CancelResult    <span class="keyword">bool</span>   <span class="string">`json:&quot;cancel_result&quot;`</span></span><br><span class="line">	DelNoticeResult <span class="keyword">bool</span>   <span class="string">`json:&quot;del_notice_result&quot;`</span></span><br><span class="line">	Info            <span class="keyword">string</span> <span class="string">`json:&quot;info&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：取消的结果，删除通知的结果，以及相关的反馈信息。以便后期对应做出维护。</p>
<hr>
<h2 id="通知接口"><a href="#通知接口" class="headerlink" title="通知接口"></a>通知接口</h2><blockquote>
<p>通知被设计成，创建通知，删除通知为基本函数，穿插在点赞和评论的基本操作当中，并非一个单独的接口，而获取通知被设计成一个接口，目的就是能够随时获得最新的通知，能随时调用这个接口，读取操作可以作为常用接口，而增删通知则不开放为一个接口来调用。</p>
</blockquote>
<h3 id="GetNotice（获得通知）"><a href="#GetNotice（获得通知）" class="headerlink" title="GetNotice（获得通知）"></a>GetNotice（获得通知）</h3><p>获得通知时无需发送多余的信息，直接通过Session即可<br><strong>路由</strong>：feed/notice<br><strong>输入</strong>：session_id （从redis中获得usr_name）<br><strong>输出</strong>：通知信息。通知信息所需要的基本信息可以分析，通知信息的前端展示：<br>①朋友圈有更新的通知：如果有新的朋友圈，一个红点，如果没有，则没有红点；<br>②自己的朋友圈被评论的通知：XX(usr_name)评价了您的“XXX”(某条朋友圈的部分文字信息)；<br>③自己参与的别人的朋友圈被其他人评论的通知：XX(usr_name)评价了“XXX”(某条朋友圈的部分文字信息)；<br>④自己的朋友圈被点赞的通知：XX(usr_name)点赞了您的“XXX”(某条朋友圈的部分文字信息)；<br>⑤自己参与的别人的朋友圈被其他人点赞的通知：XX(usr_name)点赞了“XXX”(某条朋友圈的部分文字信息)；<br>前端展示如上五种通知，则需要知道的信息有：</p>
<ol>
<li>该条通知，是通知有新的朋友圈还是新的评论还是有新的点赞？</li>
<li>publish表单是否有新的内容</li>
<li>评论时，是谁评论了哪条朋友圈</li>
<li>点赞时，是谁点赞了哪条朋友圈</li>
</ol>
<p>即为，publish_id,from_id,notice_type至于这条朋友圈的所属者是不是通知对象本身，可以由客户端自行判断。<br>因为通知的结构体如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OneNotice 单个通知信息</span></span><br><span class="line"><span class="keyword">type</span> OneNotice <span class="keyword">struct</span> &#123;</span><br><span class="line">	NoticeID     <span class="keyword">int</span>    <span class="string">`json:&quot;notice_id&quot;`</span></span><br><span class="line">	PublishID    <span class="keyword">int</span>    <span class="string">`json:&quot;publish_id&quot;`</span><span class="comment">//指向对应的朋友圈</span></span><br><span class="line">	NoticeType   <span class="keyword">int</span>    <span class="string">`json:&quot;notice_type&quot;`</span><span class="comment">//0为评论，1为点赞</span></span><br><span class="line">	CommentID    <span class="keyword">int</span>    <span class="string">`json:&quot;comment_id&quot;`</span></span><br><span class="line">	LikeID       <span class="keyword">int</span>    <span class="string">`json:&quot;like_id&quot;`</span></span><br><span class="line">	FromUserName <span class="keyword">string</span> <span class="string">`json:&quot;from_user_name&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当客户端接收到的publish_id为0时，该条Notice意思是：有新的朋友圈信息。<br>当客户端接收到的publish_id不为0时，(如23)，from_user_name:liuxing1，notice_type:1，该条信息的意思是：23号朋友圈有来自liuxing1的点赞<br>当客户端接收到的publish_id不为0时，(如23)，from_user_name:liuxing1，notice_type:0，该条信息的意思是：23号朋友圈有来自liuxing1的评论</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NoticeList 发送给用户的通知信息</span></span><br><span class="line"><span class="keyword">type</span> NoticeList <span class="keyword">struct</span> &#123;</span><br><span class="line">	Notices []OneNotice <span class="string">`json:&quot;notices&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>故，以上通知列，可以告知用户一切相关的通知信息，点击这些信息的时候，再调取具体的通知信息给用户呈现。</p>
<h3 id="GetInfo-根据通知，来获取相关信息的更新"><a href="#GetInfo-根据通知，来获取相关信息的更新" class="headerlink" title="GetInfo(根据通知，来获取相关信息的更新)"></a>GetInfo(根据通知，来获取相关信息的更新)</h3><p><strong>路由</strong>：feed/getinfo<br>以上五种通知，通知1不会单独呈现，只需要用小红点告知用户有最新动态，刷新朋友圈即可。通知2，3，4，5则会单独呈现，2，3点选的时候，会在上方展示相关朋友圈，下方会显示所有的点赞评论信息，即，将当前发生最新动态的朋友圈的最新状态整个从服务端拉取过来。点赞信息的更新类似。</p>
<p><strong>输入</strong>：通过“session_id”可以得知usr_id,usr_name。只需要publish_id即可进行信息的更新。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NewMoment 回传的最新单条朋友圈详情</span></span><br><span class="line"><span class="keyword">type</span> NewMoment OneMoment</span><br><span class="line"></span><br><span class="line"><span class="comment">//OneMoment is 单个朋友圈的Json格式</span></span><br><span class="line"><span class="keyword">type</span> OneMoment <span class="keyword">struct</span> &#123;</span><br><span class="line">	PublishID  <span class="keyword">int</span>         <span class="string">`json:&quot;publish_id&quot;`</span></span><br><span class="line">	UserName   <span class="keyword">string</span>      <span class="string">`json:&quot;usr_name&quot;`</span></span><br><span class="line">	Caption    <span class="keyword">string</span>      <span class="string">`json:&quot;caption&quot;`</span></span><br><span class="line">	PicList    []<span class="keyword">string</span>    <span class="string">`json:&quot;pic_list&quot;`</span></span><br><span class="line">	CreateTime <span class="keyword">string</span>      <span class="string">`json:&quot;create_time&quot;`</span></span><br><span class="line">	LikeList   []<span class="keyword">string</span>    <span class="string">`json:&quot;like_list&quot;`</span></span><br><span class="line">	Comments   CommentList <span class="string">`json:&quot;comments&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CommentList is 评论列表，Json格式</span></span><br><span class="line"><span class="keyword">type</span> CommentList []OneComment</span><br><span class="line"></span><br><span class="line"><span class="comment">//OneComment 用户评价时提交的表单</span></span><br><span class="line"><span class="keyword">type</span> OneComment <span class="keyword">struct</span> &#123;</span><br><span class="line">	UsrName        <span class="keyword">string</span> <span class="string">`json:&quot;usr_name&quot;`</span></span><br><span class="line">	CommentCaption <span class="keyword">string</span> <span class="string">`form:&quot;comment_caption&quot; json:&quot;comment_caption&quot;`</span></span><br><span class="line">	PublishID      <span class="keyword">int</span>    <span class="string">`form:&quot;publish_id&quot; json:&quot;-&quot;`</span></span><br><span class="line">	CommentID      <span class="keyword">int</span>    <span class="string">`json:&quot;comment_id&quot;`</span></span><br><span class="line">	CreateTime     <span class="keyword">string</span> <span class="string">`json:&quot;create_time&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：单条朋友圈的最新状态。</p>
<h1 id="实现所需知识树"><a href="#实现所需知识树" class="headerlink" title="实现所需知识树"></a>实现所需知识树</h1><h2 id="Beego框架的使用"><a href="#Beego框架的使用" class="headerlink" title="Beego框架的使用"></a><a href="https://beego.me/docs/quickstart/">Beego框架的使用</a></h2><p><strong>实例</strong><br><a href="https://github.com/beego/samples/tree/master/WebIM">samples/WebIM at master · beego/samples · GitHub</a></p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>由于需要保持登录状态，所以这里需要用到Session控制<br><a href="https://studygolang.com/articles/15822?fr=sidebar">Go基础学习记录之如何在Golang中使用Session  - Go语言中文网 - Golang中文社区</a><br><a href="https://beego.me/docs/mvc/controller/session.md">Session control - beego: simple &amp; powerful Go app framework</a></p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><a href="https://redis.io/">Redis</a></h2><p><a href="/2018/12/11/Redis%E6%95%99%E7%A8%8B/">Redis 教程</a></p>
<h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><p>Json解析首字母一定要大写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CreateCommentFeedback 评论创建反馈</span></span><br><span class="line"><span class="keyword">type</span> CreateCommentFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	CommentID    <span class="keyword">int64</span> <span class="string">`json:&quot;comment_id&quot;`</span></span><br><span class="line">	CreateResult <span class="keyword">bool</span>  <span class="string">`json:&quot;create_result&quot;`</span></span><br><span class="line">	NoticeStatus <span class="keyword">bool</span>  <span class="string">`json:&quot;notice_status&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码JSON的时候，json:”-“可以让其不参与编码，不然还是会编码，不过不会更名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">PublishID      <span class="keyword">int</span>    <span class="string">`form:&quot;publish_id&quot; json:&quot;-&quot;`</span></span><br></pre></td></tr></table></figure>

<p>若为</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">PublishID      <span class="keyword">int</span>    <span class="string">`form:&quot;publish_id&quot;`</span></span><br></pre></td></tr></table></figure>

<p>编码的时候，还是会有这个字段，并且，显示的是，PublishID:XXX</p>
<p>redis的操作问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Cli.Set(<span class="string">&quot;liuxing1&quot;</span>, <span class="string">&quot;aaaaa&quot;</span>, <span class="number">30</span>*time.Minute)</span><br><span class="line">	a := Cli.Get(<span class="string">&quot;liuxing1&quot;</span>)</span><br><span class="line">	fmt.Println(a.Val())</span><br><span class="line">	fmt.Println(a.String())</span><br><span class="line">	b := Cli.Del(<span class="string">&quot;liuxing&quot;</span>)</span><br><span class="line">	fmt.Println(b.Val())</span><br><span class="line">	c := Cli.Get(<span class="string">&quot;liuxing1&quot;</span>)</span><br><span class="line">	fmt.Println(c.Val())</span><br><span class="line">	fmt.Println(c.Val()==<span class="string">&quot;&quot;</span>)</span><br><span class="line">	fmt.Println(c.Err())</span><br><span class="line">	b = Cli.Del(<span class="string">&quot;liuxing1&quot;</span>)</span><br><span class="line">	fmt.Println(b.Val())</span><br><span class="line">	c = Cli.Get(<span class="string">&quot;liuxing1&quot;</span>)</span><br><span class="line">	fmt.Println(c.Val())</span><br><span class="line">	fmt.Println(c.Val()==<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaaaa</span><br><span class="line">get liuxing1: aaaaa</span><br><span class="line">0</span><br><span class="line">aaaaa</span><br><span class="line">false</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">true</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Project</tag>
        <tag>MySQL</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>IPV4-&gt;IPV6 重构项目</title>
    <url>/2018/01/21/IPV4-%3EIPV6%20%E9%87%8D%E6%9E%84%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="xm-ip-service原结构"><a href="#xm-ip-service原结构" class="headerlink" title="xm_ip_service原结构"></a>xm_ip_service原结构</h1><h2 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h2><p>通过IP地址（目前仅支持IPV4），进行IP地址相关地理信息的查询，查询过程分为，国内信息查询与国际信息查询两个查询方式。</p>
<h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><p>接口内容</p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GeoInfo</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">string</span> ip,</span><br><span class="line">    <span class="number">2</span>: <span class="built_in">string</span> geoip_country_code,</span><br><span class="line">    <span class="number">3</span>: <span class="built_in">string</span> geoip_country_name,</span><br><span class="line">    <span class="number">4</span>: <span class="built_in">string</span> geoip_city_code,</span><br><span class="line">    <span class="number">5</span>: <span class="built_in">string</span> geoip_city_name,</span><br><span class="line">    <span class="number">6</span>: <span class="built_in">i32</span> error_no,</span><br><span class="line">    <span class="number">7</span>: <span class="built_in">string</span> geoip_province_code,</span><br><span class="line">    <span class="number">8</span>: <span class="built_in">string</span> geoip_province_name,</span><br><span class="line">    <span class="number">9</span>: <span class="built_in">string</span> geoip_carrier,</span><br><span class="line">    <span class="number">10</span>: <span class="built_in">string</span> error_msg,</span><br><span class="line">    <span class="number">11</span>: <span class="built_in">i64</span> geoip_start_ip,</span><br><span class="line">    <span class="number">12</span>: <span class="built_in">i64</span> geoip_end_ip</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GeoRequest</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: list&lt;<span class="keyword">string</span>&gt; ipList,</span><br><span class="line">    <span class="number">2</span>: <span class="built_in">string</span> lang <span class="comment">// en or zh-CN</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">IPService</span> </span>&#123;</span><br><span class="line">   list&lt;GeoInfo&gt; queryGeoInfoByIP(<span class="number">1</span>:list&lt;<span class="keyword">string</span>&gt; ipList);</span><br><span class="line"></span><br><span class="line">   list&lt;GeoInfo&gt; queryGeoInfo(<span class="number">1</span>:GeoRequest req);</span><br><span class="line"></span><br><span class="line">   list&lt;GeoInfo&gt; queryI18nGeoInfoByIP(<span class="number">1</span>:list&lt;<span class="keyword">string</span>&gt; ipList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="业务逻辑说明"><a href="#业务逻辑说明" class="headerlink" title="业务逻辑说明"></a>业务逻辑说明</h2><h3 id="hook-go"><a href="#hook-go" class="headerlink" title="hook.go"></a>hook.go</h3><p><strong>描述：</strong></p>
<blockquote>
<p>定义并初始化了IP相关地理信息的原始数据结构体，并从文件当中读取所需地理信息数据，给其赋值，该结构体作为IP地理信息参照表，亦或查询表。</p>
</blockquote>
<p><strong>流程：</strong></p>
<blockquote>
<p>在加载配置文件之后，服务正式运行之前，通过New函数初始化该地理信息结构体；<br>然后，通过Open函数，读取配置里的路径信息，将该路径下文件里的地理信息通过信息的处理，依次读取到GeoModel的中文地理信息（cnGeos）和英文地理信息（enGeos）两个切片中，此时的GeoModel就成为了存储有完整IP相关地理信息的一张参照表；<br>GeoI18nModel类似，不过后者用作存储国际化的全球IP地理信息，没有中英文的区分，而是利用了命名为Names的Map基本结构扩展了所有所需的语言包，所以无需特意进行语言的区分，查询时打上语言标识即可。</p>
</blockquote>
<h3 id="IPservice-go"><a href="#IPservice-go" class="headerlink" title="IPservice.go"></a>IPservice.go</h3><blockquote>
<p>定义新建控制器。</p>
</blockquote>
<h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><p><strong>描述：</strong></p>
<blockquote>
<p>定义并初始化了控制器及其进程，以及hook函数的定义以及运行。</p>
</blockquote>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p><strong>描述：</strong></p>
<table>
<thead>
<tr>
<th>IP_Service_Handler</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>queryGeoInfo_Handler</td>
<td>通过发来的请求里包含的IP地址，参照GeoModel查询对应的地理信息；  如果查询不到或地理位置不在中国，则交给GeoI18nModel来继续查询对比相关的地理信息。  进行合适的日志处理之后，打包返回相关地理信息以及错误信息。</td>
</tr>
<tr>
<td>queryGeoInfoByIP_Handler</td>
<td>与上面不同的是，输入当中直接为IP_list，并没有相关的中英文标识，语言统一预设为中文识别， 当查询到地理信息不是中国的时候，则交给GeoI18nModel来继续查询对比相关的地理信息。</td>
</tr>
<tr>
<td>queryI18nGeoInfoByIP_Handler</td>
<td>与第二条相同，输入也直接为IP_list，不同的是，查询语言预设为英文。 并且是国际IP地理信息的查询服务，所以并不区分是否在“中国”国内。</td>
</tr>
</tbody></table>
<p><strong>流程：</strong><br>见Model里的业务逻辑描述。</p>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><h4 id="geo-model"><a href="#geo-model" class="headerlink" title="geo_model"></a>geo_model</h4><blockquote>
<p>定义了Geo和GeoModel结构体。及其New函数。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Geo定义了一个地区的IP区间</span></span><br><span class="line"><span class="keyword">type</span> Geo <span class="keyword">struct</span> &#123;</span><br><span class="line"> startIp      <span class="keyword">uint32</span></span><br><span class="line"> endIp        <span class="keyword">uint32</span></span><br><span class="line"> countryName  <span class="keyword">string</span></span><br><span class="line"> provinceName <span class="keyword">string</span></span><br><span class="line"> cityName     <span class="keyword">string</span></span><br><span class="line"> districtName <span class="keyword">string</span></span><br><span class="line"> carrierName  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GeoModel定义了中英文地理信息的数据整体信息，包括了数据路径以及所有中英文地理信息完整的数据切片</span></span><br><span class="line"><span class="keyword">type</span> GeoModel <span class="keyword">struct</span> &#123;</span><br><span class="line"> enDataPath <span class="keyword">string</span></span><br><span class="line"> cnDataPath <span class="keyword">string</span></span><br><span class="line"> cnGeos []*Geo</span><br><span class="line"> enGeos []*Geo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>open函数用来从文件中读取IP地理信息到geoModel结构体。该函数在hook.go中调用，用来初始化参照表GeoModel。</li>
<li>charToLong和charTolittle函数用来将IP地址转化为整数(ipValue)，好进行区间比较，以便找到IP的归属地。</li>
<li>search函数和compare函数结合起来，找到ipValue的对应区间，用来查找IP的归属地。</li>
<li>GetInfoByIP函数则整合以上代码，进行查表，将一个IP地址信息，和其语言标识，来查询对应的地理信息表单，返回一个地理信息和相关错误信息。</li>
</ul>
<h4 id="geoi18n-model"><a href="#geoi18n-model" class="headerlink" title="geoi18n_model"></a>geoi18n_model</h4><blockquote>
<p>定义了Geo和GeoModel结构体。及其New函数。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GeoI18nModel定义了国际IP地理信息数据包，包括了数据路劲以及所有的IP地理信息数据</span></span><br><span class="line"><span class="keyword">type</span> GeoI18nModel <span class="keyword">struct</span> &#123;</span><br><span class="line"> dataPath <span class="keyword">string</span></span><br><span class="line"> Data     *geoip2.Reader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>open函数用来从文件中读取IP地理信息到GeoI18nModel结构体。该函数在hook.go中调用，用来初始化参照表GeoI18nModel。</li>
<li>GetI18nInfoByIP函数，进行查表操作，查询国际IP地理信息表单，将一个IP地址信息进行解析，然后查询IP地址的所属城市信息，然后依次赋值给需要返回的单个地理信息，最好返回该地理信息和相关错误信息。</li>
</ul>
<h1 id="重构项目"><a href="#重构项目" class="headerlink" title="重构项目"></a>重构项目</h1><blockquote>
<p>对这个项目进行重构,数据存储层迁移到 PG, 功能上支持 ipv6</p>
</blockquote>
<h2 id="数据存储层迁移到PG"><a href="#数据存储层迁移到PG" class="headerlink" title="数据存储层迁移到PG"></a>数据存储层迁移到PG</h2><h3 id="PGSQL数据存储设计方案"><a href="#PGSQL数据存储设计方案" class="headerlink" title="PGSQL数据存储设计方案"></a>PGSQL数据存储设计方案</h3><p>此处数据存储层指的地理位置信息的参照表，原本是以<code>data</code>形式存储在代码包文件当中的，如下。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fze1gt1peoj30tp0gg42n.jpg" alt="data_en"></p>
<p>需要将该文件存储到PG中，以查表的方式来查询IP_geoInfo。</p>
<p>所以需要设计两张表来分别存储这两个文件。命名分别以ip_service_cn/en命名。<br>设计结果如下：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzgnmbjb8uj30hm06r0tg.jpg"></p>
<p>其中注意</p>
<ul>
<li>PG设置自增语句：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">nextval(&#x27;ip_service_cn_id_seq&#x27;::regclass)</span><br><span class="line">nextval(&#x27;ip_service_en_id_seq&#x27;::regclass)</span><br></pre></td></tr></table></figure>

<ul>
<li>PG插入多个数据的语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> public.ip_service ( start_ip , end_ip , country_name , province_name , city_name , district_name , carrier_name) <span class="keyword">VALUES</span> (<span class="number">16777216</span>,<span class="number">16777471</span>,<span class="string">&#x27;澳大利亚&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>),(<span class="number">16777472</span>,<span class="number">16778239</span>,<span class="string">&#x27;中国&#x27;</span>,<span class="string">&#x27;福建&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;电信&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>PG恢复自增字段序号为1的语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> ip_service_en;</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> ip_service_cn;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SEQUENCE</span> ip_service_cn_id_seq RESTART <span class="keyword">WITH</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SEQUENCE</span> ip_service_en_id_seq RESTART <span class="keyword">WITH</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzgnkb78kfj30u60bntby.jpg"></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzgnklbpfqj30u60didjg.jpg"></p>
<p>因为查询IP_GEOINFO时，最主要是通过比对ip所处的区间，来得知，查询的IP属于哪一个地址范围，且，start_ip，end_ip有明显的连续性，所以可以由此建立索引。建表语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">&quot;public&quot;</span>.<span class="string">&quot;ip_service_en&quot;</span>(</span><br><span class="line">  <span class="string">&quot;id&quot;</span> <span class="built_in">serial8</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  <span class="string">&quot;create_time&quot;</span> timestamptz(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">now</span>(),</span><br><span class="line">  <span class="string">&quot;update_time&quot;</span> timestamptz(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">now</span>(),</span><br><span class="line">  <span class="string">&quot;start_ip&quot;</span> <span class="built_in">int8</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;end_ip&quot;</span> <span class="built_in">int8</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;country_name&quot;</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	<span class="string">&quot;province_name&quot;</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	<span class="string">&quot;city_name&quot;</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	<span class="string">&quot;district_name&quot;</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	<span class="string">&quot;carrier_name&quot;</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> <span class="string">&quot;idx_iprange_en&quot;</span> <span class="keyword">ON</span> <span class="string">&quot;public&quot;</span>.<span class="string">&quot;ip_service_en&quot;</span> (start_ip,end_ip);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">&quot;public&quot;</span>.<span class="string">&quot;ip_service_cn&quot;</span>(</span><br><span class="line">  <span class="string">&quot;id&quot;</span> <span class="built_in">serial8</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  <span class="string">&quot;create_time&quot;</span> timestamptz(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">now</span>(),</span><br><span class="line">  <span class="string">&quot;update_time&quot;</span> timestamptz(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">now</span>(),</span><br><span class="line">  <span class="string">&quot;start_ip&quot;</span> <span class="built_in">int8</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;end_ip&quot;</span> <span class="built_in">int8</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;country_name&quot;</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	<span class="string">&quot;province_name&quot;</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	<span class="string">&quot;city_name&quot;</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	<span class="string">&quot;district_name&quot;</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	<span class="string">&quot;carrier_name&quot;</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> <span class="string">&quot;idx_iprange_cn&quot;</span> <span class="keyword">ON</span> <span class="string">&quot;public&quot;</span>.<span class="string">&quot;ip_service_cn&quot;</span> (start_ip,end_ip);</span><br></pre></td></tr></table></figure>

<h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><blockquote>
<p>因为涉及到的数据量有近五百万条IP地址段，所以需要考虑插入的效率问题。于是结合了两个方案：</p>
</blockquote>
<ul>
<li>开Go程同时往中英文IP表单中插数据</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> NewInsert(p, <span class="string">&quot;en&quot;</span>, &amp;wg)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> NewInsert(p, <span class="string">&quot;cn&quot;</span>, &amp;wg)</span><br><span class="line">wg.Wait()</span><br><span class="line">Db.Close()</span><br></pre></td></tr></table></figure>

<ul>
<li>结合sql语句，1000条数据提交一次。（见上文PG插入多个数据的语句格式）</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInsert</span><span class="params">(p *GeoModel, tableName <span class="keyword">string</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> data, sql, sqlHead, sqlData, oneData <span class="keyword">string</span></span><br><span class="line">	sqlHead = <span class="string">&quot;INSERT INTO public.ip_service_%s ( start_ip , end_ip , country_name , province_name , city_name , district_name , carrier_name)&quot;</span></span><br><span class="line">	sqlData = <span class="string">&quot;(%v,%v,&#x27;%v&#x27;,&#x27;%v&#x27;,&#x27;%v&#x27;,&#x27;%v&#x27;,&#x27;%v&#x27;)&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tableName == <span class="string">&quot;en&quot;</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> k, vousmevoyez := <span class="keyword">range</span> p.enGeos &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> vousmevoyez.StartIP != <span class="number">0</span> &amp;&amp; vousmevoyez.EndIP != <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">				oneData = fmt.Sprintf(sqlData, v.StartIP, v.EndIP, v.CountryName, v.ProvinceName, v.CityName, v.DistrictName, v.CarrierName)</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> k%<span class="number">1000</span> != <span class="number">0</span> &amp;&amp; k &lt; <span class="built_in">len</span>(p.cnGeos) &#123;</span><br><span class="line">					data += oneData</span><br><span class="line">					data += <span class="string">&quot;,&quot;</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					data += oneData</span><br><span class="line">					sql = sqlHead + <span class="string">&quot; VALUES &quot;</span> + data</span><br><span class="line">					fmt.Println(tableName + <span class="string">&quot;***********:**********&quot;</span> + strconv.Itoa(k))</span><br><span class="line">					_, err := Db.Exec(sql)</span><br><span class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">						fmt.Println(sql, err)</span><br><span class="line">						TableHandler(<span class="number">0</span>)</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> k%<span class="number">1000</span> == <span class="number">0</span> &#123;</span><br><span class="line">				data = <span class="string">&quot;&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//···略</span></span><br><span class="line">  &#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其间碰到的一个坑：在英文IP地理信息中，名称中有的时候有单引号如<code>Yi&#39;an City</code>这个时候放在sql语句中就会报错，这个时候，如果想要在数据库中正确插入单引号，就要把一个单引号变成两个。所以，增加了一个排查单引号的功能，例子如下：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(tokens) &gt;= <span class="number">3</span> &#123;</span><br><span class="line">		geo.CountryName = tokens[<span class="number">2</span>]</span><br><span class="line">		<span class="keyword">if</span> strings.Contains(geo.CountryName, <span class="string">&quot;&#x27;&quot;</span>) &#123;</span><br><span class="line">			geo.CountryName = strings.Replace(geo.CountryName, <span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;&#x27;&#x27;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部代码修改"><a href="#内部代码修改" class="headerlink" title="内部代码修改"></a>内部代码修改</h3><p>后续只需要将源代码中关于geoModel的结构体做一次重新的适配，搜索的入口做一个重定向就行了，这里不做赘述。</p>
<h2 id="如何支持IPV6"><a href="#如何支持IPV6" class="headerlink" title="如何支持IPV6"></a>如何支持IPV6</h2><p>由于Leader说了，I18N的重构暂时不需要管IPV6的模块，所以就不动，并且，现阶段只需要做出一个能用的IPV6地址查询即可，于是，我首先要下载数据源，然后做地理查询前，同样要先将数据源转移到PG，然后再以类似的逻辑做地理查询，问题的难点在于，数据如何处理，和如何转移数据，以及数据库如何设计等等。</p>
<h3 id="地理数据集的处理"><a href="#地理数据集的处理" class="headerlink" title="地理数据集的处理"></a>地理数据集的处理</h3><p>IPV6地理信息数据集的<a href="https://www.cnblogs.com/kjcy8/p/5787723.html">特性</a></p>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Project</tag>
        <tag>PgSQL</tag>
      </tags>
  </entry>
</search>
