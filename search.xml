<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode精选算法题目合集</title>
    <url>/2019/04/08/LeetCode_Problems/</url>
    <content><![CDATA[<h1 id="算法合集"><a href="#算法合集" class="headerlink" title="算法合集"></a>算法合集</h1><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p><strong>注意</strong>:你不能在买入股票前卖出股票。</p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: [7,1,5,3,6,4]<br><code>输出</code>: 5<br><code>解释</code>: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: [7,6,4,3,1]<br><code>输出</code>: 0<br><code>解释</code>: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	gaps := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(prices)<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(gaps); i++ &#123;</span><br><span class="line">		gaps[i] = prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">	&#125;</span><br><span class="line">	ans := <span class="number">0</span></span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(gaps); i++ &#123;</span><br><span class="line">		sum += gaps[i]</span><br><span class="line">		ans = getMax(ans, sum)</span><br><span class="line">		sum = getMax(sum, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMax</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: [7,1,5,3,6,4]<br><code>输出</code>: 7<br><code>解释</code>: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: [1,2,3,4,5]<br><code>输出</code>: 4<br><code>解释</code>: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
</blockquote>
<p><code>示例 3</code>:</p>
<blockquote>
<p><code>输入</code>: [7,6,4,3,1]<br><code>输出</code>: 0<br><code>解释</code>: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ans := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(prices)<span class="number">-1</span>; i++ &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> prices[i+<span class="number">1</span>] &gt; prices[i] &#123;</span><br><span class="line">			ans += prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a>123. 买卖股票的最佳时机 III</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p><strong>注意</strong>: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: [3,3,5,0,0,3,1,4]<br><code>输出</code>: 6<br><code>解释</code>: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: [1,2,3,4,5]<br><code>输出</code>: 4<br><code>解释</code>: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
</blockquote>
<p><code>示例 3</code>:</p>
<blockquote>
<p><code>输入</code>: [7,6,4,3,1]<br><code>输出</code>: 0<br><code>解释</code>: 在这个情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> intMin = ^<span class="keyword">int</span>(^<span class="keyword">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fstBuy, secBuy := intMin, intMin</span><br><span class="line">	fstSell, secSell := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, vousmevoyez := <span class="keyword">range</span> prices &#123;</span><br><span class="line">		fstBuy = getMax(fstBuy, -vousmevoyez)</span><br><span class="line">		fstSell = getMax(fstSell, fstBuy+vousmevoyez)</span><br><span class="line">		secBuy = getMax(secBuy, fstSell-vousmevoyez)</span><br><span class="line">		secSell = getMax(secSell, secBuy+vousmevoyez)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> secSell</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMax</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a>188. 买卖股票的最佳时机 IV</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p><strong>注意</strong>: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: [2,4,1], k = 2<br><code>输出</code>: 2<br><code>解释</code>: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: [3,2,6,5,0,3], k = 2<br><code>输出</code>: 7<br><code>解释</code>: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。<br>     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">profits</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>] &#123;</span><br><span class="line">			res += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(k <span class="keyword">int</span>, prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> prices == <span class="literal">nil</span> || <span class="built_in">len</span>(prices) == <span class="number">0</span> || k &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> k &gt;= <span class="built_in">len</span>(prices) &#123;</span><br><span class="line">		<span class="keyword">return</span> profits(prices)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ownDp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">	noDp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> ownDp &#123;</span><br><span class="line">		ownDp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, k+<span class="number">1</span>)</span><br><span class="line">		noDp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, k+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> t := <span class="number">0</span>; t &lt;= k; t++ &#123;</span><br><span class="line">		noDp[<span class="number">0</span>][t] = <span class="number">0</span></span><br><span class="line">		ownDp[<span class="number">0</span>][t] = -prices[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	ownDp[<span class="number">0</span>][k] = <span class="number">-1</span>&lt;&lt;<span class="number">32</span> - <span class="number">1</span></span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">		x := i % <span class="number">2</span></span><br><span class="line">		y := (i - <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">		<span class="keyword">for</span> m := <span class="number">0</span>; m &lt;= k; m++ &#123;</span><br><span class="line">			<span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">				noDp[x][m] = max(<span class="number">-1</span>&lt;&lt;<span class="number">32</span><span class="number">-1</span>, noDp[y][m])</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				noDp[x][m] = max(noDp[y][m], ownDp[y][m<span class="number">-1</span>]+prices[i])</span><br><span class="line">			&#125;</span><br><span class="line">			ownDp[x][m] = max(ownDp[y][m], noDp[y][m]-prices[i])</span><br><span class="line">			tmp := max(noDp[x][m], ownDp[x][m])</span><br><span class="line">			res = max(res, tmp)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: coins = [1, 2, 5], amount = 11<br><code>输出</code>: 3<br><code>解释</code>: 11 = 5 + 5 + 1</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: coins = [2], amount = 3<br><code>输出</code>: -1<br><code>说明</code>: 你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> vousmevoyez := <span class="number">1</span>; vousmevoyez &lt;= amount; vousmevoyez++ &#123;</span><br><span class="line">		dp[vousmevoyez] = <span class="number">0x3f3f3f3f</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">		<span class="keyword">for</span> vousmevoyez := coin; vousmevoyez &lt;= amount; vousmevoyez++ &#123;</span><br><span class="line">			<span class="keyword">if</span> dp[vousmevoyez] &gt; dp[vousmevoyez-coin] + <span class="number">1</span> &#123;</span><br><span class="line">				dp[vousmevoyez] = dp[vousmevoyez-coin] + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> dp[amount] == <span class="number">0x3f3f3f3f</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a>518. 零钱兑换 II</h2><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: amount = 5, coins = [1, 2, 5]<br><code>输出</code>: 4<br><code>解释</code>: 有四种方式可以凑成总金额:<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: amount = 3, coins = [2]<br><code>输出</code>: 0<br><code>解释</code>: 只用面额2的硬币不能凑成总金额3。</p>
</blockquote>
<p><code>示例 3</code>:</p>
<blockquote>
<p><code>输入</code>: amount = 10, coins = [10]<br><code>输出</code>: 1</p>
</blockquote>
<p><strong>注意</strong>:</p>
<blockquote>
<p>你可以假设：<br>0 &lt;= amount (总金额) &lt;= 5000<br>1 &lt;= coin (硬币面额) &lt;= 5000<br>硬币种类不超过 500 种<br>结果符合 32 位符号整数</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(amount <span class="keyword">int</span>, coins []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> amount == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(coins) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(coins); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := coins[i]; j &lt;= amount; j++ &#123;</span><br><span class="line">            dp[j] += dp[j - coins[i]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h2><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p>
<p><strong>说明</strong>:<br>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
<p><code>示例</code>:</p>
<blockquote>
</blockquote>
<p><code>输入</code>:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br><code>输出</code>: [1,2,2,3,5,6]</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="keyword">int</span>, m <span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">copy</span>(nums1, nums2)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(nums1[m:], nums2)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m+n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; m+n<span class="number">-1</span>-i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums1[j] &gt; nums1[j+<span class="number">1</span>] &#123;</span><br><span class="line">				nums1[j], nums1[j+<span class="number">1</span>] = nums1[j+<span class="number">1</span>], nums1[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记</title>
    <url>/2019/09/06/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Redis学习笔记"><a href="#Redis学习笔记" class="headerlink" title="Redis学习笔记"></a>Redis学习笔记</h1></br>

<h2 id="1-Redis-简介"><a href="#1-Redis-简介" class="headerlink" title="1-Redis 简介"></a>1-<a href="https://liuxing1tec.github.io/2019/09/05/redis1/" target="_blank" rel="noopener">Redis 简介</a></h2></br>

<h2 id="2-Redis-基础命令"><a href="#2-Redis-基础命令" class="headerlink" title="2-Redis 基础命令"></a>2-<a href="https://liuxing1tec.github.io/2019/09/05/redis2/" target="_blank" rel="noopener">Redis 基础命令</a></h2></br>

<h2 id="3-Redis-配置"><a href="#3-Redis-配置" class="headerlink" title="3-Redis 配置"></a>3-<a href="https://liuxing1tec.github.io/2019/09/05/redis3/" target="_blank" rel="noopener">Redis 配置</a></h2></br>

<a id="more"></a>

<h2 id="4-Redis-KEY键的操作"><a href="#4-Redis-KEY键的操作" class="headerlink" title="4-Redis KEY键的操作"></a>4-<a href="https://liuxing1tec.github.io/2019/09/05/redis4/" target="_blank" rel="noopener">Redis KEY键的操作</a></h2></br>

<h2 id="5-Redis-数据类型"><a href="#5-Redis-数据类型" class="headerlink" title="5-Redis 数据类型"></a>5-<a href="https://liuxing1tec.github.io/2019/09/05/redis5/" target="_blank" rel="noopener">Redis 数据类型</a></h2></br>

<h2 id="6-Redis-String-字符串"><a href="#6-Redis-String-字符串" class="headerlink" title="6-Redis String(字符串)"></a>6-<a href="https://liuxing1tec.github.io/2019/09/05/redis6/" target="_blank" rel="noopener">Redis String(字符串)</a></h2></br>

<h2 id="7-Redis-Hash-哈希表-字典"><a href="#7-Redis-Hash-哈希表-字典" class="headerlink" title="7-Redis Hash(哈希表/字典)"></a>7-<a href="https://liuxing1tec.github.io/2019/09/05/redis7/" target="_blank" rel="noopener">Redis Hash(哈希表/字典)</a></h2></br>

<h2 id="8-Redis-List-列表"><a href="#8-Redis-List-列表" class="headerlink" title="8-Redis List(列表)"></a>8-<a href="https://liuxing1tec.github.io/2019/09/05/redis8/" target="_blank" rel="noopener">Redis List(列表)</a></h2></br>

<h2 id="9-Redis-Set-集合"><a href="#9-Redis-Set-集合" class="headerlink" title="9-Redis Set(集合)"></a>9-<a href="https://liuxing1tec.github.io/2019/09/05/redis9/" target="_blank" rel="noopener">Redis Set(集合)</a></h2></br>

<h2 id="10-Redis-Sorted-Set-有序集合"><a href="#10-Redis-Sorted-Set-有序集合" class="headerlink" title="10-Redis Sorted Set(有序集合)"></a>10-<a href="https://liuxing1tec.github.io/2019/09/05/redis10/" target="_blank" rel="noopener">Redis Sorted Set(有序集合)</a></h2></br>

<h2 id="11-Redis-常用命令"><a href="#11-Redis-常用命令" class="headerlink" title="11-Redis 常用命令"></a>11-<a href="https://liuxing1tec.github.io/2019/09/05/redis11/" target="_blank" rel="noopener">Redis 常用命令</a></h2></br>

<h2 id="12-Redis-事务"><a href="#12-Redis-事务" class="headerlink" title="12-Redis 事务"></a>12-<a href="https://liuxing1tec.github.io/2019/09/05/redis12/" target="_blank" rel="noopener">Redis 事务</a></h2></br>

<h2 id="13-Redis-发布订阅"><a href="#13-Redis-发布订阅" class="headerlink" title="13-Redis 发布订阅"></a>13-<a href="https://liuxing1tec.github.io/2019/09/05/redis13/" target="_blank" rel="noopener">Redis 发布订阅</a></h2>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>第一阶段新员工小结</title>
    <url>/2020/07/30/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%96%B0%E5%91%98%E5%B7%A5%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<div align='center' ><font size='70'>第一阶段新员工小结</font></div>

<hr>
<p>[TOC]</p>
<hr>
<h1 id="Docker基础知识"><a href="#Docker基础知识" class="headerlink" title="Docker基础知识"></a>Docker基础知识</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run ubuntu:15.10 /bin/<span class="built_in">echo</span> <span class="string">"Hello world"</span></span><br></pre></td></tr></table></figure>
<p><strong>参数含义：</strong></p>
<ul>
<li><code>docker</code>：Docker 的二进制执行文件。</li>
<li><code>run</code>：与前面的 docker 组合来运行一个容器。</li>
<li><code>ubuntu:15.10</code>：指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li>
<li><code>/bin/echo &quot;Hello world&quot;</code>：在启动的容器里执行的命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -i -t ubuntu:15.10 /bin/bash</span><br></pre></td></tr></table></figure>
<p><strong>参数含义：</strong></p>
<ul>
<li><code>-t</code>：在新容器内指定一个伪终端或终端。</li>
<li><code>-i</code>：允许你对容器内的标准输入 <code>stdin</code> 进行交互</li>
<li>可以通过运行 <code>exit</code> 命令或者使用 <code>ctrl+D</code> 来退出容器，会导致容器停止</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-d</code>：让容器在后台运行。</li>
<li><code>-P</code>：将容器内部使用的网络端口随机映射到我们使用的主机上。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit &lt;CONTAINER ID&gt; &lt;REPOSITORY&gt;</span><br></pre></td></tr></table></figure>
<p><strong>参数含义：</strong><br><code>-a</code>：提交的镜像作者;<br><code>-c</code>：使用Dockerfile指令来创建镜像;<br><code>-m</code>：提交时的说明文字;<br><code>-p</code>：在commit时，将容器暂停</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>commend</th>
<th>result</th>
</tr>
</thead>
<tbody><tr>
<td><code>docker ps</code></td>
<td>查看正在运行的容器</td>
</tr>
<tr>
<td><code>docker ps -a</code></td>
<td>查看所有容器</td>
</tr>
<tr>
<td><code>docker stop &lt;CONTAINER ID/REPOSITORY&gt;</code></td>
<td>关闭容器</td>
</tr>
<tr>
<td><code>docker logs &lt;CONTAINER ID/REPOSITORY&gt;</code></td>
<td>查看容器内的标准输出</td>
</tr>
<tr>
<td><code>docker pull &lt;IMAGE_NAME&gt;</code></td>
<td>载入镜像</td>
</tr>
<tr>
<td><code>docker restart &lt;CONTAINER ID&gt;</code></td>
<td>重启停止的容器</td>
</tr>
<tr>
<td><code>docker attach &lt;CONTAINER ID&gt;</code></td>
<td>进入后台运行中的容器</td>
</tr>
<tr>
<td><code>docker exec &lt;CONTAINER ID&gt;</code></td>
<td>退出容器，不会导致容器的停止</td>
</tr>
<tr>
<td><code>docker export &lt;CONTAINER ID&gt; &gt; xxx.tar</code></td>
<td>导出本地某个容器</td>
</tr>
<tr>
<td>`cat docker/xxx.tar</td>
<td>docker import - <EPOSITORY>:<TAG>`</td>
</tr>
<tr>
<td><code>docker import &lt;URL&gt; &lt;EPOSITORY&gt;</code></td>
<td>导入容器快照</td>
</tr>
<tr>
<td><code>docker rm -f &lt;CONTAINER ID&gt;</code></td>
<td>删除容器<code>-f</code>:强制删除;<code>-no-prune</code>:不要删除未带标签的父镜像</td>
</tr>
<tr>
<td><code>docker container prune</code></td>
<td>清理掉所有处于终止状态的容器</td>
</tr>
<tr>
<td><code>docker rm $(docker container ls -aq)</code></td>
<td>删除所有容器</td>
</tr>
<tr>
<td><code>docker commit &lt;CONTAINER ID&gt; &lt;REPOSITORY&gt;</code></td>
<td>把容器打包成镜像</td>
</tr>
<tr>
<td><code>docker inspect &lt;REPOSITORY&gt;:&lt;CONTAINER ID&gt;</code></td>
<td>查看镜像的详细信息</td>
</tr>
<tr>
<td><code>docker rm $(docker container ls -f &quot;status=exited&quot; -q)</code></td>
<td>同时删除多个符合筛选条件(状态为“exited”)的容器</td>
</tr>
</tbody></table>
<h1 id="Linux下MySQL的ODBC配置"><a href="#Linux下MySQL的ODBC配置" class="headerlink" title="Linux下MySQL的ODBC配置"></a>Linux下MySQL的ODBC配置</h1><p>在<strong>安装</strong>配置之前，需要先大概了解一下 MyODBC 的架构，MyODBC 体系结构建立在 5 个组件上，如下图所示：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggwm30f77xj30a20b3aah.jpg" alt=""></p>
<p><strong>Driver Manager</strong><br>负责管理应用程序和驱动程序间的通信，主要功能包括：解析 DSN (数据源名称，ODBC 的数据源名称在 odbc.ini 文件中配置)，加载和卸载驱动程序，处理 ODBC 调用，将其传递给驱动程序。</p>
<p><strong>ODBC.INI</strong><br>odbc.ini 是 ODBC 配置文件，记录了连接到服务器所需的驱动信息和数据库信息。Driver Manager 将使用它来确定加载哪个驱动程序（使用数据源名 DSN ）。驱动程序将根据指定的DSN来读取连接参数。</p>
<p><strong>Connector/ODBC(MyODBC驱动程序)</strong><br>实现 ODBC API 所提供的功能，它负责处理 ODBC 函数调用，将 SQL 请求提交给 MySQL 服务器，并将结果返回给应用程序。</p>
<p>在 Linux 下配置 mysql ODBC 需要有以下步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 安装 Driver Manager，本案例使用 unixODBC 来作为 Driver Manager。</span><br><span class="line">2. 安装 MySQL 驱动程序，本案例使用 Connector&#x2F;ODBC。</span><br><span class="line">3. 配置 ODBC.INI</span><br></pre></td></tr></table></figure>

<h2 id="第一步：下载安装包"><a href="#第一步：下载安装包" class="headerlink" title="第一步：下载安装包"></a>第一步：下载安装包</h2><p>需要下载两个安装包 <code>unixODBC 2.3.0</code> 和 <code>mysql Connector/ODBC 3.51</code><br>unixODBC 源码包：<code>ftp://ftp.unixodbc.org/pub/unixODBC/unixODBC-2.3.0.tar.gz</code><br>mysql Connector/ODBC 源码包：<code>http://dev.mysql.com/downloads/connector/odbc/3.51.html%23downloads</code><br>选择</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">版本：5.1.11</span><br><span class="line">平台：Oracle&amp;Red Hat Linux6</span><br><span class="line">下载：mysql-connector-odbc-5.1.11-linux-el6-x86-64bit.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="第二步：安装-unixODBC"><a href="#第二步：安装-unixODBC" class="headerlink" title="第二步：安装 unixODBC"></a>第二步：安装 unixODBC</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf unixODBC-2.3.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> unixODBC-2.3.4</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/unixODBC-2.3.4 --includedir=/usr/include --libdir=/usr/<span class="built_in">local</span>/lib -bindir=/usr/bin --sysconfdir=/usr/<span class="built_in">local</span>/etc</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装完成后,可以在/usr/bin目录下有下面的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root      75312 Nov 1 16:22 odbcinst</span><br><span class="line">-rwxr-xr-x 1 root root      10922 Nov 1 16:22 odbc_config</span><br><span class="line">-rwxr-xr-x 1 root root      37650 Nov 1 16:22 iusql</span><br><span class="line">-rwxr-xr-x 1 root root      44400 Nov 1 16:22 isql</span><br><span class="line">-rwxr-xr-x 1 root root      95903 Nov 1 16:22 dltest</span><br></pre></td></tr></table></figure>
<p>在/usr/local/lib目录下面有这些文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root 422955 Nov 1 16:22 libodbcinst.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     20 Nov 1 16:22 libodbcinst.so.1 -&gt; libodbcinst.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     20 Nov 1 16:22 libodbcinst.so -&gt; libodbcinst.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    981 Nov 1 16:22 libodbcinst.la</span><br><span class="line">-rwxr-xr-x 1 root root 169157 Nov 1 16:22 libodbc.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     16 Nov 1 16:22 libodbc.so.1 -&gt; libodbc.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     16 Nov 1 16:22 libodbc.so -&gt; libodbc.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    957 Nov 1 16:22 libodbc.la</span><br><span class="line">-rwxr-xr-x 1 root root 489405 Nov 1 16:22 libodbccr.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     18 Nov 1 16:22 libodbccr.so.1 -&gt; libodbccr.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     18 Nov 1 16:22 libodbccr.so -&gt; libodbccr.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    969 Nov 1 16:22 libodbccr.la</span><br></pre></td></tr></table></figure>

<h2 id="第三步：安装-mysql-Connector-ODBC"><a href="#第三步：安装-mysql-Connector-ODBC" class="headerlink" title="第三步：安装 mysql Connector/ODBC"></a>第三步：安装 mysql Connector/ODBC</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf mysql-connector-odbc-5.1.11-linux-el6-x86-64bit.tar.gz</span><br><span class="line"><span class="built_in">cd</span> mysql-connector-odbc-5.1.11-linux-el6-x86-64bit/lib</span><br><span class="line">cp libmyodbc5.so /usr/<span class="built_in">local</span>/lib</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> bin</span><br></pre></td></tr></table></figure>
<p><strong>注册驱动</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./myodbc-installer -d -a -n <span class="string">"MySQL ODBC 5.1 Driver"</span> -t <span class="string">"DRIVER=/usr/local/lib/libmyodbc5.so;SETUP=/usr/local/lib/libmyodbc5.so"</span></span><br><span class="line"></span><br><span class="line">//odbc 5.3及以上是libmyodbc5a.so和libmyodbc5w.so。其中c5a是Ansi版，c5w是Unicode版</span><br></pre></td></tr></table></figure>
<p>假如注册的时候报错找不到libodbc.so.2,但是之前确实装成功了unixodbc,可能是因为系统找不到/usr/local/lib库目录，需要添加系统搜索库目录路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line">//将/usr/<span class="built_in">local</span>/lib直接添加在配置文件里</span><br><span class="line"></span><br><span class="line">ldconfig</span><br><span class="line"></span><br><span class="line">//重新缓存配置文件(为了加快程序执行时对共享库的定位速度，避免使用搜索路径查找共享库的低效率，所以是直接读取库列表文件/etc/ld.so.cache缓存文件并从中进行搜索的)</span><br></pre></td></tr></table></figure>

<h2 id="第四步：配置-ODBC-INI"><a href="#第四步：配置-ODBC-INI" class="headerlink" title="第四步：配置 ODBC.INI"></a>第四步：配置 ODBC.INI</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">odbcinst -j</span><br><span class="line"></span><br><span class="line">unixODBC 2.3.1</span><br><span class="line">DRIVERS............: /etc/odbcinst.ini</span><br><span class="line">SYSTEM DATA SOURCES: /etc/odbc.ini</span><br><span class="line">FILE DATA SOURCES..: /etc/ODBCDataSources</span><br><span class="line">USER DATA SOURCES..: /root/.odbc.ini</span><br><span class="line">SQLULEN Size.......: 8</span><br><span class="line">SQLLEN Size........: 8</span><br><span class="line">SQLSETPOSIROW Size.: 8</span><br></pre></td></tr></table></figure>
<p>编辑文件<code>/etc/odbc.ini</code>，把下面的内容加上去。不同版本<code>mysql</code>驱动的配置方法，有细微差异。此处使用的版本是<code>mysql Connector 3.51</code>。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqlDSN]</span></span><br><span class="line"><span class="attr">Driver</span>      = /usr/local/lib/libmyodbc5.so</span><br><span class="line"><span class="attr">Description</span> = MyODBC <span class="number">5</span> Driver DSN</span><br><span class="line"><span class="attr">SERVER</span>      = <span class="number">172.31</span>.<span class="number">108.133</span></span><br><span class="line"><span class="attr">PORT</span>        = <span class="number">3306</span></span><br><span class="line"><span class="attr">USER</span>        = root</span><br><span class="line"><span class="attr">Password</span>    = <span class="number">123456</span></span><br><span class="line"><span class="attr">Database</span>    = PM</span><br><span class="line"><span class="attr">OPTION</span>      = <span class="number">3</span></span><br><span class="line"><span class="attr">charset</span>     = UTF8</span><br></pre></td></tr></table></figure>

<h2 id="第五步：设置环境变量"><a href="#第五步：设置环境变量" class="headerlink" title="第五步：设置环境变量"></a>第五步：设置环境变量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> DBCINI=/usr/<span class="built_in">local</span>/etc/odbc.ini</span><br><span class="line"><span class="built_in">export</span> DBCSYSINI=/usr/<span class="built_in">local</span>/etc</span><br></pre></td></tr></table></figure>

<h2 id="第六步：重启电脑"><a href="#第六步：重启电脑" class="headerlink" title="第六步：重启电脑"></a>第六步：重启电脑</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h2 id="第七步：测试ODBC配置是否成功"><a href="#第七步：测试ODBC配置是否成功" class="headerlink" title="第七步：测试ODBC配置是否成功"></a>第七步：测试ODBC配置是否成功</h2><p>isql 是 unixODBC 带的一个 ODBC 客户端访问工具，使用<code>isql +数据源名</code>来访问目标数据库。如果 ODBC 配置正确，会显示下面的界面。在<code>SQL&gt;</code>提示符下输入 SQL 语句查询数据库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">isql mysqlDSN</span><br><span class="line"></span><br><span class="line">+---------------------------------------+</span><br><span class="line">| Connected!                           |</span><br><span class="line">|                                      |</span><br><span class="line">| sql-statement                        |</span><br><span class="line">| <span class="built_in">help</span> [tablename]                     |</span><br><span class="line">| quit                                 |</span><br><span class="line">|                                      |</span><br><span class="line">+---------------------------------------+</span><br></pre></td></tr></table></figure>

<h2 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>在第三步安装 mysql connector/ODBC 中的注册驱动中，我总是会出现<code>./myodbc-installer: error while loading shared libraries: libodbc.so.2: cannot open shared object file: No such file or directory.</code>这种错误，后来发现错误有两点：</p>
<ol>
<li>我下载的是 mysql-connector-5.3.6 ，可能版本比较高，而我初次下载用的是unixODBC-2.3.0，版本较低，里面没有 libodbc.so.2 这个库文件（可以用<code>find / -name libodbc.so.2</code>来查）。后来下载了一个 unixODBC-2.3.4 就好了。</li>
<li>改了版本之后，我发现还是有这个错误，在网上查了下，说是程序查找默认路径为 /lib 和 /usr/lib，而我的 libmyodbc5w.so 和 libmmyodbc5a.so 都在 /usr/local/lib 中，所以查不到，所以需要设置一下共享库路径，以下我贴一下网上查的内容：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/ld.so.conf</span><br><span class="line">include ld.so.conf.d/*.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/usr/local/lib"</span> &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>

<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>如果共享库文件安装到了其它”非 /lib 或 /usr/lib “ 目录下，但是又不想在 /etc/ld.so.conf 中加路径(或者是没有权限加路径)。那可以 export 一个全局变量 LD_LIBRARY_PATH ，然后运行程序的时候就会去这个目录中找共享库。</p>
<p>LD_LIBRARY_PATH 的意思是告诉 loader 在哪些目录中可以找到共享库。</p>
<p>可以设置多个搜索目录，这些目录之间用冒号分隔开。</p>
<p>比如：</p>
<p>安装了一个 mysql 到 /usr/local/mysql 目录下，其中有一大堆库文件在 /usr/local/mysql/lib 下面，则可以在 .bashrc 或 .bash_profile 或 shell 里加入以下语句即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/mysql/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>

<p>一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用。</p>
<h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p>如果程序需要的库文件比系统目前存在的村文件版本低，可以做一个链接<br>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error while loading shared libraries: libncurses.so.4: cannot open shared</span><br><span class="line">object file: No such file or directory</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /usr/lib/libncu*</span><br><span class="line">/usr/lib/libncurses.a   /usr/lib/libncurses.so.5</span><br><span class="line">/usr/lib/libncurses.so  /usr/lib/libncurses.so.5.3</span><br></pre></td></tr></table></figure>
<p>可见虽然没有 libncurses.so.4，但有 libncurses.so.5，是可以向下兼容的<br>建一个链接就好了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s  /usr/lib/libncurses.so.5.3  /usr/lib/libncurses.so.4</span><br></pre></td></tr></table></figure>

<h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><p>isql 连接数据库失败，重新注册驱动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/myodbc-installer  -d -a -n <span class="string">"MySQL_UNICODE"</span>  -t <span class="string">"DRIVER=/usr/lib64/libmyodbc8w.so;SETUP=/usr/lib64/libmyodbc8w.so"</span></span><br><span class="line">/usr/bin/myodbc-installer  -d -a -n <span class="string">"MySQL_ANSI"</span>  -t <span class="string">"DRIVER=/usr/lib64/libmyodbc8a.so;SETUP=/usr/lib64/libmyodbc8a.so"</span></span><br></pre></td></tr></table></figure>
<p>使用 rpm 命令查看 rpm 包的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qpl xxx.rpm</span><br></pre></td></tr></table></figure>
<p>可以看到<code>mysql-connector-odbc-8.0.20-1.el7.x86_64.rpm</code>的包内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">warning: mysql-connector-odbc-8.0.20-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">/usr/bin/myodbc-installer</span><br><span class="line">/usr/lib64/libmyodbc8a.so</span><br><span class="line">/usr/lib64/libmyodbc8w.so</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/ChangeLog</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/INFO_BIN</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/INFO_SRC</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/LICENSE.txt</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/README.txt</span><br></pre></td></tr></table></figure>
<p>可以知道 rpm 包 安装的时候各个基础件的安装位置。</p>
<h1 id="运行微服务"><a href="#运行微服务" class="headerlink" title="运行微服务"></a>运行微服务</h1><h2 id="NGINX-的配置与基础命令"><a href="#NGINX-的配置与基础命令" class="headerlink" title="NGINX 的配置与基础命令"></a>NGINX 的配置与基础命令</h2><h3 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h3><p><strong>查看 nginx 配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/nginx/nginx.conf</span><br><span class="line">cat /etc/nginx/conf.d/xxxxxxxx.conf</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">可以看到 `stdname` 对应的监听端口设置 nginx 监听 18026 并转发至 stdnameSvr 的 监听端口 19026。</span><br><span class="line"></span><br><span class="line">```conf</span><br><span class="line">server &#123;</span><br><span class="line">        listen       18026;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location /stdname/  &#123;</span><br><span class="line">                fastcgi_pass   127.0.0.1:19026;</span><br><span class="line">                fastcgi_index index.cgi;</span><br><span class="line">                <span class="comment">#fastcgi_param SCRIPT_FILENAME fcgi$fastcgi_script_name;</span></span><br><span class="line">                include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<p><strong>验证 nginx 配置文件是否正确</strong></p>
<p>进入 nginx 安装目录 sbin 下，输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./nginx -t</span><br></pre></td></tr></table></figure>

<p>看到如下显示 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx: the configuration file /.../nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /.../nginx.conf <span class="built_in">test</span> is successful</span><br></pre></td></tr></table></figure>

<p>说明配置文件正确！</p>
<h3 id="运行-nginx"><a href="#运行-nginx" class="headerlink" title="运行 nginx"></a>运行 nginx</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/path_of_nginx/nginx -c /path_of_nginx.conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p><code>-c</code>：指定 nginx 运行时使用的 conf 文件路径<br><code>-t</code>：加上<code>-t</code>可以测试 nginx 配置是否正确</p>
<h3 id="停止-nginx"><a href="#停止-nginx" class="headerlink" title="停止 nginx"></a>停止 nginx</h3><p>查看进程号然后杀死进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br><span class="line"><span class="built_in">kill</span> -QUIT &lt;pid_of_nginx&gt;   //从容停止</span><br><span class="line"><span class="built_in">kill</span> -TERM &lt;pid_of_nginx&gt;   //快速停止</span><br><span class="line"><span class="built_in">kill</span> -INT &lt;pid_of_nginx&gt;    //快速停止</span><br><span class="line"><span class="built_in">kill</span> -9 nginx               //强制停止</span><br></pre></td></tr></table></figure>

<h3 id="重启-nginx"><a href="#重启-nginx" class="headerlink" title="重启 nginx"></a>重启 nginx</h3><p><strong>方法一：</strong><br>找到 nginx 可执行文件路径，然后输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

</br>

<p><strong>方法二：</strong><br>查找当前 nginx 进程号，然后输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;pid_of_nginx&gt;</span><br></pre></td></tr></table></figure>

<p>实现重启 nginx 服务。</p>
<h2 id="Docker-端口映射"><a href="#Docker-端口映射" class="headerlink" title="Docker 端口映射"></a>Docker 端口映射</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -p 8080:18026 &lt;REPOSITORY&gt;:&lt;TAG&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<p><code>-p</code>：是容器内部端口绑定到指定的主机端口。这里指将主机的8080端口映射到容器的18026端口。</p>
</br>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -p 127.0.0.1:8080:18026 &lt;REPOSITORY&gt;:&lt;TAG&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<p>这样我们就可以通过访问 127.0.0.1:8080 来访问容器的 18026 端口。</p>
</br>

<p>上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 /udp。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -p 127.0.0.1:8080:18026/udp &lt;REPOSITORY&gt;:&lt;TAG&gt; /bin/bash</span><br></pre></td></tr></table></figure>

</br>

<p><code>docker port &lt;CONTAINER ID&gt; &lt;PORT&gt;</code>命令可以让我们快捷地查看端口的绑定情况。</p>
<h2 id="启动微服务"><a href="#启动微服务" class="headerlink" title="启动微服务"></a>启动微服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recurse-submodules https://gitlab.xxxxxxxx.net/.../*.git</span><br><span class="line">//带这个参数，才会把 public 下载到子目录里面去</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /path_of_project/</span><br><span class="line"></span><br><span class="line">sh build.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> bin/root_of_work_dir/</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> VEHICLE_DATA_CONFIG=/root_of_work_dir/vehicle/config/config.xml</span><br><span class="line">//代码中有对 VEHICLE_DATA_CONFIG 的宏定义，修改为本地路径</span><br><span class="line"></span><br><span class="line">spawn_fcgi -a 127.0.0.1 -p 19026 -C 25 -U nginx -f stdnameSvr -F 1</span><br><span class="line">//运行 stdnameSvr 服务</span><br><span class="line"></span><br><span class="line">netstat -ntpl</span><br><span class="line">//查看 nginx 和 stdnameSvr 服务是否均已开启</span><br></pre></td></tr></table></figure>


<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><h2 id="项目文件结构分析"><a href="#项目文件结构分析" class="headerlink" title="项目文件结构分析"></a>项目文件结构分析</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Dockerfile                      &#x2F;&#x2F;运行环境配置</span><br><span class="line">├── README.md                       &#x2F;&#x2F;项目介绍</span><br><span class="line">├── build.sh                        &#x2F;&#x2F;编译脚本</span><br><span class="line">├── rebuild.sh                      &#x2F;&#x2F;重新再编译脚本</span><br><span class="line">└── src                             &#x2F;&#x2F;源码</span><br><span class="line">    ├── CMakeLists.txt              &#x2F;&#x2F;cmake配置文件</span><br><span class="line">    ├── app                         &#x2F;&#x2F;项目代码文件</span><br><span class="line">    └── public                      &#x2F;&#x2F;项目框架依赖代码文件</span><br></pre></td></tr></table></figure>

<p><code>Dockerfile</code>: 实现 Linux 运行环境的部署。</p>
<p><code>build.sh</code>&amp;<code>rebuild.sh</code>: 该脚本文件实现项目代码的编译，包含 cmake make 操作，生成 bin/ 和 lib/ 目录，可执行文件存放在 bin/* 下。</p>
<p><code>src</code>: src 文件夹下 包含所有的项目源码。</p>
<p><code>public</code>: public 文件夹相关知识:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//将代码依赖包下载添加到当前项目中作为 submodule，并存放在 src/public 下</span><br><span class="line">git submodule add https://xxxxxx.git src/public</span><br><span class="line"></span><br><span class="line">//下载代码分支时，带上 submodule 相关代码包</span><br><span class="line">git <span class="built_in">clone</span> --recurse-submodules https://xxxxxx.git</span><br><span class="line"></span><br><span class="line">//更新代码分支时，带上 submodule 相关代码包</span><br><span class="line">git pull --recurse-submodules</span><br></pre></td></tr></table></figure>

<p><code>app</code>: app 文件夹下包含所有的微服务项目代码文件，真正的业务内容都在 app 文件夹下。</p>
<h2 id="微服务框架代码分析"><a href="#微服务框架代码分析" class="headerlink" title="微服务框架代码分析"></a>微服务框架代码分析</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CategoryName 类构造函数:</span><br><span class="line">当创建该类的对象时，通过参数 name 初始化项目名字，通过参数 config_file (配置文件.xml　的绝对路径)来读取构造对象所需的配置参数。构造该对象时，通过对配置参数的解读，获取　mysql　的连接地址用户名密码，以及连接数据库的库名，完成了对　SQL　驱动实体的初始化，并注册对象的接口处理函数。</span><br><span class="line"></span><br><span class="line">ServiceUnit 类通过 setup_app 实现对 app (Category 构造函数创造的对象) 进行注册和初始化操作(加载运行所需的缓存，注册状态接口，以实现在 eureka 服务中正常反馈运行状态，设置日志的分级，存储名和存储地址)。</span><br><span class="line"></span><br><span class="line">部署信号相关的动作，注册 CategoryName 类构造函数创建的对象的调度函数，当出现信号 <span class="number">50</span> 时，进行 reload_cache 操作，信号 <span class="number">51</span> <span class="number">52</span> 则会升级日志类型。</span><br><span class="line"></span><br><span class="line">此时一切准备就绪可以交给 fast_cgi 处理运行微服务框架了。</span><br><span class="line"></span><br><span class="line">ServiceUnit 类构造函数在创建对象时注册了接口调用机制，当找到对应接口时，进行数据处理，未找到时返回相应的错误信息。</span><br><span class="line"></span><br><span class="line">此文件中类为 CategoryName 类对象的接口处理函数，进行实际的函数操作。execute 类成员函数被注册到了 CategoryName 类对象的 set_all_impl() 所注册的的接口中进行执行。</span><br><span class="line"></span><br><span class="line">RequestParam 类构造函数决定了该对象在创建时就从该微服务从外部发来的 http 包中获取到了各个参数，所以将该参数对象，传给各个注册接口对应的操作类创建的对象，即可实现对入参的后端处理流程。</span><br><span class="line"></span><br><span class="line">execute 函数决定了入参的处理逻辑。通过不同的类成员函数决定了不同的入参处理逻辑。以实现各个业务需求。</span><br></pre></td></tr></table></figure>

<h2 id="接口调用记录表的设计与实现"><a href="#接口调用记录表的设计与实现" class="headerlink" title="接口调用记录表的设计与实现"></a>接口调用记录表的设计与实现</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7tnrx8bmj30jp0c2tai.jpg" alt=""></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="string">`t_interface_call_record`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_interface_call_record`</span> (</span><br><span class="line">	<span class="string">`id`</span> <span class="built_in">INT</span> ( <span class="number">11</span> ) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	<span class="string">`caller`</span> <span class="built_in">VARCHAR</span> ( <span class="number">64</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'调用者'</span>,</span><br><span class="line">	<span class="string">`interface_name`</span> <span class="built_in">VARCHAR</span> ( <span class="number">64</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'接口名'</span>,</span><br><span class="line">	<span class="string">`req_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'调用时间'</span>,</span><br><span class="line">	<span class="string">`req_ctx`</span> <span class="built_in">text</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'接口的传参'</span>,</span><br><span class="line">	<span class="string">`resp_ctx`</span> <span class="built_in">text</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'接口的返回'</span>,</span><br><span class="line">	<span class="string">`status`</span> <span class="built_in">VARCHAR</span> ( <span class="number">64</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'接口返回状态'</span>,</span><br><span class="line">	<span class="string">`creator`</span> <span class="built_in">VARCHAR</span> ( <span class="number">64</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	<span class="string">`create_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">	<span class="string">`updator`</span> <span class="built_in">VARCHAR</span> ( <span class="number">64</span> ) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	<span class="string">`update_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span> ( <span class="string">`id`</span> ),</span><br><span class="line">	<span class="keyword">INDEX</span> <span class="string">`idx_interface_name`</span> ( <span class="string">`interface_name`</span> ) <span class="keyword">USING</span> BTREE </span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="built_in">CHARACTER</span> </span><br><span class="line"><span class="keyword">SET</span> = utf8 <span class="keyword">COLLATE</span> = utf8_general_ci;</span><br><span class="line"></span><br><span class="line">// 需要学会的sql命令↓</span><br><span class="line">// DEFAULT CURRENT_TIMESTAMP 表示当插入数据的时候，该字段默认值为当前时间</span><br><span class="line">// ON <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> 在数据库数据有更新的时候UPDATE_TIME的时间会自动更新</span><br><span class="line">// AUTO_INCREMENT 用于主键自动增长</span><br><span class="line">// <span class="keyword">INDEX</span> <span class="string">`idx_interface_name`</span> ( <span class="string">`interface_name`</span> ) <span class="keyword">USING</span> BTREE 建立B树索引</span><br></pre></td></tr></table></figure>

<h1 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>通过编译将<code>/bin</code>目录下的可执行文件中的项目文件拖到<code>/root_work_dir/bin/</code>文件夹下部署。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><p>需要编写<code>.sh</code>文件放在<code>/root_work_dir/script/</code>文件夹下，通过命令<code>sh xxx.sh start/stop/restart</code>用来操作<code>/root_work_dir/bin/</code>文件夹下部署的可执行文件。</p>
<p>脚本中 nginx 内部端口需要修改和 <code>nginx.conf xxxxxxxx.conf</code> 配置一致，服务名称需修改成目前需要部署的服务名称。</p>
<h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><p>修改方法，见<code># 运行微服务 -&gt; ## NGINX 的配置与基础命令 -&gt; ### nginx 配置</code>部分。</p>
<h3 id="运行配置"><a href="#运行配置" class="headerlink" title="运行配置"></a>运行配置</h3><p>需要编写<code>.json</code>文件放在<code>/root_work_dir/script/config/</code>文件夹下，用来配置微服务的注册与发现。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>执行运行脚本后，可部署在服务器上。若部署成功，可在　eureka　服务器中查看接口运行状态。</p>
<h1 id="开发过程中遇到的坑"><a href="#开发过程中遇到的坑" class="headerlink" title="开发过程中遇到的坑"></a>开发过程中遇到的坑</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">private</span> <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">explicit</span> <span class="keyword">extern</span></span><br></pre></td></tr></table></figure>

<ul>
<li>以上限定词的作用以及继承关系的嵌套需要更加明晰，很容易被这些限定词把逻辑弄乱。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CurlCXX <span class="title">curl</span><span class="params">(url, <span class="number">1</span>)</span></span>; <span class="comment">//1s timeout</span></span><br><span class="line">curl.post(body);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意学会<code>curl</code>发包的用法，并且<code>post</code>时，<code>body</code>当中要注意<code>fastcgi</code>框架当中约定了<code>post</code>数据格式为<code>x-www-form-urlencoded/form-data</code>，因此一定要注意<code>body</code>里面的数据，单个字段内不能出现容易导致解析错误的<code>&#39;&amp;&#39;</code>字符，若不得不包含<code>&#39;&amp;&#39;</code>字符，则要用转义字符<code>&#39;\&amp;&#39;</code>包起来，否则会导致参数错误。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CallRecord *app;</span><br><span class="line">app = app_ptr();</span><br><span class="line"><span class="keyword">const_cast</span>&lt;CallRecord *&gt;(app)-&gt;reload_cache();</span><br></pre></td></tr></table></figure>

<ul>
<li>注意对<code>const</code>类型的对象操作时，需要用<code>const_cast&lt;XXXXXX&gt;</code>对该对象进行强制类型转换。</li>
</ul>
]]></content>
      <tags>
        <tag>progress</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下MySQL的ODBC配置</title>
    <url>/2020/07/20/MySQL_ODBC%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>在<strong>安装</strong>配置之前，需要先大概了解一下 MyODBC 的架构，MyODBC 体系结构建立在 5 个组件上，如下图所示：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggwm30f77xj30a20b3aah.jpg" alt=""></p>
<a id="more"></a>

<p><strong>Driver Manager</strong><br>负责管理应用程序和驱动程序间的通信，主要功能包括：解析 DSN (数据源名称，ODBC 的数据源名称在 odbc.ini 文件中配置)，加载和卸载驱动程序，处理 ODBC 调用，将其传递给驱动程序。</p>
<p><strong>ODBC.INI</strong><br>odbc.ini 是 ODBC 配置文件，记录了连接到服务器所需的驱动信息和数据库信息xxxxxx。Driver Manager 将使用它来确定加载哪个驱动程序（使用数据源名 DSN ）。驱动程序将根据指定的DSN来读取连接参数。</p>
<p><strong>Connector/ODBC(MyODBC驱动程序)</strong><br>实现 ODBC API 所提供的功能，它负责处理 ODBC 函数调用，将 SQL 请求提交给 MySQL 服务器，并将结果返回给应用程序。</p>
<p>在 Linux 下配置 mysql ODBC 需要有以下步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 安装 Driver Manager，本案例使用 unixODBC 来作为 Driver Manager。</span><br><span class="line">2. 安装 MySQL 驱动程序，本案例使用 Connector&#x2F;ODBC。</span><br><span class="line">3. 配置 ODBC.INI</span><br></pre></td></tr></table></figure>

<h2 id="第一步：下载安装包"><a href="#第一步：下载安装包" class="headerlink" title="第一步：下载安装包"></a>第一步：下载安装包</h2><p>需要下载两个安装包 <code>unixODBC 2.3.0</code> 和 <code>mysql Connector/ODBC 3.51</code><br>unixODBC 源码包：<code>ftp://ftp.unixodbc.org/pub/unixODBC/unixODBC-2.3.0.tar.gz</code><br>mysql Connector/ODBC 源码包：<code>http://dev.mysql.com/downloads/connector/odbc/3.51.html%23downloads</code><br>选择</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">版本：5.1.11</span><br><span class="line">平台：Oracle&amp;Red Hat Linux6</span><br><span class="line">下载：mysql-connector-odbc-5.1.11-linux-el6-x86-64bit.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="第二步：安装-unixODBC"><a href="#第二步：安装-unixODBC" class="headerlink" title="第二步：安装 unixODBC"></a>第二步：安装 unixODBC</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf unixODBC-2.3.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> unixODBC-2.3.4</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/unixODBC-2.3.4 --includedir=/usr/include --libdir=/usr/<span class="built_in">local</span>/lib -bindir=/usr/bin --sysconfdir=/usr/<span class="built_in">local</span>/etc</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装完成后,可以在/usr/bin目录下有下面的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root      75312 Nov 1 16:22 odbcinst</span><br><span class="line">-rwxr-xr-x 1 root root      10922 Nov 1 16:22 odbc_config</span><br><span class="line">-rwxr-xr-x 1 root root      37650 Nov 1 16:22 iusql</span><br><span class="line">-rwxr-xr-x 1 root root      44400 Nov 1 16:22 isql</span><br><span class="line">-rwxr-xr-x 1 root root      95903 Nov 1 16:22 dltest</span><br></pre></td></tr></table></figure>
<p>在/usr/local/lib目录下面有这些文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root 422955 Nov 1 16:22 libodbcinst.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     20 Nov 1 16:22 libodbcinst.so.1 -&gt; libodbcinst.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     20 Nov 1 16:22 libodbcinst.so -&gt; libodbcinst.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    981 Nov 1 16:22 libodbcinst.la</span><br><span class="line">-rwxr-xr-x 1 root root 169157 Nov 1 16:22 libodbc.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     16 Nov 1 16:22 libodbc.so.1 -&gt; libodbc.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     16 Nov 1 16:22 libodbc.so -&gt; libodbc.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    957 Nov 1 16:22 libodbc.la</span><br><span class="line">-rwxr-xr-x 1 root root 489405 Nov 1 16:22 libodbccr.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     18 Nov 1 16:22 libodbccr.so.1 -&gt; libodbccr.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     18 Nov 1 16:22 libodbccr.so -&gt; libodbccr.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    969 Nov 1 16:22 libodbccr.la</span><br></pre></td></tr></table></figure>

<h2 id="第三步：安装-mysql-Connector-ODBC"><a href="#第三步：安装-mysql-Connector-ODBC" class="headerlink" title="第三步：安装 mysql Connector/ODBC"></a>第三步：安装 mysql Connector/ODBC</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf mysql-connector-odbc-5.1.11-linux-el6-x86-64bit.tar.gz</span><br><span class="line"><span class="built_in">cd</span> mysql-connector-odbc-5.1.11-linux-el6-x86-64bit/lib</span><br><span class="line">cp libmyodbc5.so /usr/<span class="built_in">local</span>/lib</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> bin</span><br></pre></td></tr></table></figure>
<p><strong>注册驱动</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./myodbc-installer -d -a -n <span class="string">"MySQL ODBC 5.1 Driver"</span> -t <span class="string">"DRIVER=/usr/local/lib/libmyodbc5.so;SETUP=/usr/local/lib/libmyodbc5.so"</span></span><br><span class="line"></span><br><span class="line">//odbc 5.3及以上是libmyodbc5a.so和libmyodbc5w.so。其中c5a是Ansi版，c5w是Unicode版</span><br></pre></td></tr></table></figure>
<p>假如注册的时候报错找不到libodbc.so.2,但是之前确实装成功了unixodbc,可能是因为系统找不到/usr/local/lib库目录，需要添加系统搜索库目录路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line">//将/usr/<span class="built_in">local</span>/lib直接添加在配置文件里</span><br><span class="line"></span><br><span class="line">ldconfig</span><br><span class="line"></span><br><span class="line">//重新缓存配置文件(为了加快程序执行时对共享库的定位速度，避免使用搜索路径查找共享库的低效率，所以是直接读取库列表文件/etc/ld.so.cache缓存文件并从中进行搜索的)</span><br></pre></td></tr></table></figure>

<h2 id="第四步：配置-ODBC-INI"><a href="#第四步：配置-ODBC-INI" class="headerlink" title="第四步：配置 ODBC.INI"></a>第四步：配置 ODBC.INI</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">odbcinst -j</span><br><span class="line"></span><br><span class="line">unixODBC 2.3.1</span><br><span class="line">DRIVERS............: /etc/odbcinst.ini</span><br><span class="line">SYSTEM DATA SOURCES: /etc/odbc.ini</span><br><span class="line">FILE DATA SOURCES..: /etc/ODBCDataSources</span><br><span class="line">USER DATA SOURCES..: /root/.odbc.ini</span><br><span class="line">SQLULEN Size.......: 8</span><br><span class="line">SQLLEN Size........: 8</span><br><span class="line">SQLSETPOSIROW Size.: 8</span><br></pre></td></tr></table></figure>
<p>编辑文件<code>/etc/odbc.ini</code>，把下面的内容加上去。不同版本<code>mysql</code>驱动的配置方法，有细微差异。此处使用的版本是<code>mysql Connector 3.51</code>。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqlDSN]</span></span><br><span class="line"><span class="attr">Driver</span>      = /usr/local/lib/libmyodbc5.so</span><br><span class="line"><span class="attr">Description</span> = MyODBC <span class="number">5</span> Driver DSN</span><br><span class="line"><span class="attr">SERVER</span>      = <span class="number">172.31</span>.<span class="number">108.133</span></span><br><span class="line"><span class="attr">PORT</span>        = <span class="number">3306</span></span><br><span class="line"><span class="attr">USER</span>        = root</span><br><span class="line"><span class="attr">Password</span>    = <span class="number">123456</span></span><br><span class="line"><span class="attr">Database</span>    = PM</span><br><span class="line"><span class="attr">OPTION</span>      = <span class="number">3</span></span><br><span class="line"><span class="attr">charset</span>     = UTF8</span><br></pre></td></tr></table></figure>

<h2 id="第五步：设置环境变量"><a href="#第五步：设置环境变量" class="headerlink" title="第五步：设置环境变量"></a>第五步：设置环境变量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> DBCINI=/usr/<span class="built_in">local</span>/etc/odbc.ini</span><br><span class="line"><span class="built_in">export</span> DBCSYSINI=/usr/<span class="built_in">local</span>/etc</span><br></pre></td></tr></table></figure>

<h2 id="第六步：重启电脑"><a href="#第六步：重启电脑" class="headerlink" title="第六步：重启电脑"></a>第六步：重启电脑</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h2 id="第七步：测试ODBC配置是否成功"><a href="#第七步：测试ODBC配置是否成功" class="headerlink" title="第七步：测试ODBC配置是否成功"></a>第七步：测试ODBC配置是否成功</h2><p>isql 是 unixODBC 带的一个 ODBC 客户端访问工具，使用<code>isql +数据源名</code>来访问目标数据库。如果 ODBC 配置正确，会显示下面的界面。在<code>SQL&gt;</code>提示符下输入 SQL 语句查询数据库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">isql mysqlDSN</span><br><span class="line"></span><br><span class="line">+---------------------------------------+</span><br><span class="line">| Connected!                           |</span><br><span class="line">|                                      |</span><br><span class="line">| sql-statement                        |</span><br><span class="line">| <span class="built_in">help</span> [tablename]                     |</span><br><span class="line">| quit                                 |</span><br><span class="line">|                                      |</span><br><span class="line">+---------------------------------------+</span><br></pre></td></tr></table></figure>

<h2 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>在第三步安装 mysql connector/ODBC 中的注册驱动中，我总是会出现<code>./myodbc-installer: error while loading shared libraries: libodbc.so.2: cannot open shared object file: No such file or directory.</code>这种错误，后来发现错误有两点：</p>
<ol>
<li>我下载的是 mysql-connector-5.3.6 ，可能版本比较高，而我初次下载用的是unixODBC-2.3.0，版本较低，里面没有 libodbc.so.2 这个库文件（可以用<code>find / -name libodbc.so.2</code>来查）。后来下载了一个 unixODBC-2.3.4 就好了。</li>
<li>改了版本之后，我发现还是有这个错误，在网上查了下，说是程序查找默认路径为 /lib 和 /usr/lib，而我的 libmyodbc5w.so 和 libmmyodbc5a.so 都在 /usr/local/lib 中，所以查不到，所以需要设置一下共享库路径，以下我贴一下网上查的内容：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/ld.so.conf</span><br><span class="line">include ld.so.conf.d/*.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/usr/local/lib"</span> &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>

<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>如果共享库文件安装到了其它”非 /lib 或 /usr/lib “ 目录下，但是又不想在 /etc/ld.so.conf 中加路径(或者是没有权限加路径)。那可以 export 一个全局变量 LD_LIBRARY_PATH ，然后运行程序的时候就会去这个目录中找共享库。</p>
<p>LD_LIBRARY_PATH 的意思是告诉 loader 在哪些目录中可以找到共享库。</p>
<p>可以设置多个搜索目录，这些目录之间用冒号分隔开。</p>
<p>比如：</p>
<p>安装了一个 mysql 到 /usr/local/mysql 目录下，其中有一大堆库文件在 /usr/local/mysql/lib 下面，则可以在 .bashrc 或 .bash_profile 或 shell 里加入以下语句即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/mysql/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>

<p>一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>如果程序需要的库文件比系统目前存在的村文件版本低，可以做一个链接<br>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error while loading shared libraries: libncurses.so.4: cannot open shared</span><br><span class="line">object file: No such file or directory</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /usr/lib/libncu*</span><br><span class="line">/usr/lib/libncurses.a   /usr/lib/libncurses.so.5</span><br><span class="line">/usr/lib/libncurses.so  /usr/lib/libncurses.so.5.3</span><br></pre></td></tr></table></figure>
<p>可见虽然没有 libncurses.so.4，但有 libncurses.so.5，是可以向下兼容的<br>建一个链接就好了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s  /usr/lib/libncurses.so.5.3  /usr/lib/libncurses.so.4</span><br></pre></td></tr></table></figure>


<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>isql 连接数据库失败，重新注册驱动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/myodbc-installer  -d -a -n <span class="string">"MySQL_UNICODE"</span>  -t <span class="string">"DRIVER=/usr/lib64/libmyodbc8w.so;SETUP=/usr/lib64/libmyodbc8w.so"</span></span><br><span class="line">/usr/bin/myodbc-installer  -d -a -n <span class="string">"MySQL_ANSI"</span>  -t <span class="string">"DRIVER=/usr/lib64/libmyodbc8a.so;SETUP=/usr/lib64/libmyodbc8a.so"</span></span><br></pre></td></tr></table></figure>
<p>使用 rpm 命令查看 rpm 包的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qpl xxx.rpm</span><br></pre></td></tr></table></figure>
<p>可以看到<code>mysql-connector-odbc-8.0.20-1.el7.x86_64.rpm</code>的包内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">warning: mysql-connector-odbc-8.0.20-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">/usr/bin/myodbc-installer</span><br><span class="line">/usr/lib64/libmyodbc8a.so</span><br><span class="line">/usr/lib64/libmyodbc8w.so</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/ChangeLog</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/INFO_BIN</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/INFO_SRC</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/LICENSE.txt</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/README.txt</span><br></pre></td></tr></table></figure>
<p>可以知道 rpm 包 安装的时候各个基础件的安装位置。</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>ODBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 基础知识</title>
    <url>/2020/07/18/docker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run ubuntu:15.10 /bin/<span class="built_in">echo</span> <span class="string">"Hello world"</span></span><br></pre></td></tr></table></figure>

<p><strong>参数含义：</strong></p>
<ul>
<li><code>docker</code>：Docker 的二进制执行文件。</li>
<li><code>run</code>：与前面的 docker 组合来运行一个容器。</li>
<li><code>ubuntu:15.10</code>：指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li>
<li><code>/bin/echo &quot;Hello world&quot;</code>：在启动的容器里执行的命令</li>
</ul>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -i -t ubuntu:15.10 /bin/bash</span><br></pre></td></tr></table></figure>

<p><strong>参数含义：</strong></p>
<ul>
<li><code>-t</code>：在新容器内指定一个伪终端或终端。</li>
<li><code>-i</code>：允许你对容器内的标准输入 <code>stdin</code> 进行交互</li>
<li>可以通过运行 <code>exit</code> 命令或者使用 <code>ctrl+D</code> 来退出容器，会导致容器停止</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-d</code>：让容器在后台运行。</li>
<li><code>-P</code>：将容器内部使用的网络端口随机映射到我们使用的主机上。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit &lt;CONTAINER ID&gt; &lt;REPOSITORY&gt;</span><br></pre></td></tr></table></figure>

<p><strong>参数含义：</strong><br><code>-a</code>：提交的镜像作者;<br><code>-c</code>：使用Dockerfile指令来创建镜像;<br><code>-m</code>：提交时的说明文字;<br><code>-p</code>：在commit时，将容器暂停</p>
<table>
<thead>
<tr>
<th>commend</th>
<th>result</th>
</tr>
</thead>
<tbody><tr>
<td><code>docker ps</code></td>
<td>查看正在运行的容器</td>
</tr>
<tr>
<td><code>docker ps -a</code></td>
<td>查看所有容器</td>
</tr>
<tr>
<td><code>docker stop &lt;CONTAINER ID/REPOSITORY&gt;</code></td>
<td>关闭容器</td>
</tr>
<tr>
<td><code>docker logs &lt;CONTAINER ID/REPOSITORY&gt;</code></td>
<td>查看容器内的标准输出</td>
</tr>
<tr>
<td><code>docker pull &lt;IMAGE_NAME&gt;</code></td>
<td>载入镜像</td>
</tr>
<tr>
<td><code>docker restart &lt;CONTAINER ID&gt;</code></td>
<td>重启停止的容器</td>
</tr>
<tr>
<td><code>docker attach &lt;CONTAINER ID&gt;</code></td>
<td>进入后台运行中的容器</td>
</tr>
<tr>
<td><code>docker exec &lt;CONTAINER ID&gt;</code></td>
<td>退出容器，不会导致容器的停止</td>
</tr>
<tr>
<td><code>docker export &lt;CONTAINER ID&gt; &gt; xxx.tar</code></td>
<td>导出本地某个容器</td>
</tr>
<tr>
<td><code>cat docker/xxx.tar | docker import - &lt;EPOSITORY&gt;:&lt;TAG&gt;</code></td>
<td>导入容器快照</td>
</tr>
<tr>
<td><code>docker import &lt;URL&gt; &lt;EPOSITORY&gt;</code></td>
<td>导入容器快照</td>
</tr>
<tr>
<td><code>docker rm -f &lt;CONTAINER ID&gt;</code></td>
<td>删除容器<code>-f</code>:强制删除;<code>-no-prune</code>:不要删除未带标签的父镜像</td>
</tr>
<tr>
<td><code>docker container prune</code></td>
<td>清理掉所有处于终止状态的容器</td>
</tr>
<tr>
<td><code>docker rm $(docker container ls -aq)</code></td>
<td>删除所有容器</td>
</tr>
<tr>
<td><code>docker commit &lt;CONTAINER ID&gt; &lt;REPOSITORY&gt;</code></td>
<td>把容器打包成镜像</td>
</tr>
<tr>
<td><code>docker inspect &lt;REPOSITORY&gt;:&lt;CONTAINER ID&gt;</code></td>
<td>查看镜像的详细信息</td>
</tr>
<tr>
<td><code>docker rm $(docker container ls -f &quot;status=exited&quot; -q)</code></td>
<td>同时删除多个符合筛选条件(状态为“exited”)的容器</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>2019.5——2019.10工作总结</title>
    <url>/2019/10/18/5%E6%9C%886%E6%9C%88%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="工作总结"><a href="#工作总结" class="headerlink" title="工作总结"></a><center><strong>工作总结</strong></center></h1><h2 id="阶段一：基础知识回顾"><a href="#阶段一：基础知识回顾" class="headerlink" title="阶段一：基础知识回顾"></a>阶段一：基础知识回顾</h2><h3 id="gt-C语言基础语法回顾："><a href="#gt-C语言基础语法回顾：" class="headerlink" title="&gt; C语言基础语法回顾："></a>&gt; C语言基础语法回顾：</h3><blockquote>
<p>变更代码习惯，转语言——“倒时差”</p>
</blockquote>
<h4 id="gt-相关留存资料："><a href="#gt-相关留存资料：" class="headerlink" title="&gt; 相关留存资料："></a>&gt; 相关留存资料：</h4><div class="pdfobject-container" data-target="https://drive.google.com/file/d/1644m_lW65hk8UBkXqBdFv61zy-y17bBq/preview" data-height="500px"></div>

<a id="more"></a>

<h3 id="gt-计算机网络基础知识回顾："><a href="#gt-计算机网络基础知识回顾：" class="headerlink" title="&gt; 计算机网络基础知识回顾："></a>&gt; 计算机网络基础知识回顾：</h3><blockquote>
<p>回顾计算机网络结构，重点回顾计算网络网络层传输层应用层的工作相关知识，并进行总结。</p>
</blockquote>
<h4 id="gt-相关留存资料：-1"><a href="#gt-相关留存资料：-1" class="headerlink" title="&gt; 相关留存资料："></a>&gt; 相关留存资料：</h4><div class="pdfobject-container" data-target="https://drive.google.com/file/d/1MMx2EWgg-tMt0YcJeQkaBbQkAXvVYVJT/preview" data-height="500px"></div>

<h3 id="gt-Unix环境高级编程："><a href="#gt-Unix环境高级编程：" class="headerlink" title="&gt; Unix环境高级编程："></a>&gt; Unix环境高级编程：</h3><blockquote>
<p>学习网络编程，Linux环境下C语言编程，学习Socket编程相关知识。</p>
</blockquote>
<h4 id="gt-相关留存资料：-2"><a href="#gt-相关留存资料：-2" class="headerlink" title="&gt; 相关留存资料："></a>&gt; 相关留存资料：</h4><blockquote>
<p>Github Repository：    <a href="https://github.com/liuxing1Tec/C_Learning/tree/master/SOCKET%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener"><strong>C_Learning/SOCKET编程</strong></a></p>
</blockquote>
<h2 id="阶段二：网络编程实战"><a href="#阶段二：网络编程实战" class="headerlink" title="阶段二：网络编程实战"></a>阶段二：网络编程实战</h2><h3 id="gt-网络聊天客户端的开发："><a href="#gt-网络聊天客户端的开发：" class="headerlink" title="&gt; 网络聊天客户端的开发："></a>&gt; 网络聊天客户端的开发：</h3><blockquote>
<p>Socket编程实战。</p>
</blockquote>
<h4 id="gt-相关留存资料：-3"><a href="#gt-相关留存资料：-3" class="headerlink" title="&gt; 相关留存资料："></a>&gt; 相关留存资料：</h4><blockquote>
<p>Github Repository：    <a href="https://github.com/liuxing1Tec/Unix_chatroom" target="_blank" rel="noopener"><strong>Unix_chatroom</strong></a></p>
</blockquote>
<h3 id="gt-网络开发复盘："><a href="#gt-网络开发复盘：" class="headerlink" title="&gt; 网络开发复盘："></a>&gt; 网络开发复盘：</h3><blockquote>
<p>开发流程总结。</p>
</blockquote>
<h4 id="gt-相关留存资料：-4"><a href="#gt-相关留存资料：-4" class="headerlink" title="&gt; 相关留存资料："></a>&gt; 相关留存资料：</h4><blockquote>
<p>客户端开发流程以源文件：    <a href="https://github.com/liuxing1Tec/C_Learning/blob/master/SOCKET%E7%BC%96%E7%A8%8B/select_echo/src/echocli.c" target="_blank" rel="noopener"><strong>SOCKET编程/select_echo/src/echocli.c</strong></a>，为例<br>服务器端开发流程以源文件：    <a href="https://github.com/liuxing1Tec/C_Learning/blob/master/SOCKET%E7%BC%96%E7%A8%8B/select_echo/src/echosrv.c" target="_blank" rel="noopener"><strong>SOCKET编程/select_echo/src/echosrv.c</strong></a>，为例</p>
</blockquote>
<h2 id="阶段三：补充性学习：查漏补缺"><a href="#阶段三：补充性学习：查漏补缺" class="headerlink" title="阶段三：补充性学习：查漏补缺"></a>阶段三：补充性学习：查漏补缺</h2><h3 id="gt-C语言深入学习："><a href="#gt-C语言深入学习：" class="headerlink" title="&gt; C语言深入学习："></a>&gt; C语言深入学习：</h3><blockquote>
<p>C语言底层知识总结（堆栈、结构体、作用域、malloc()以及free()机制等）。</p>
</blockquote>
<h4 id="gt-相关留存资料：-5"><a href="#gt-相关留存资料：-5" class="headerlink" title="&gt; 相关留存资料："></a>&gt; 相关留存资料：</h4><div class="pdfobject-container" data-target="https://drive.google.com/file/d/1hC78fv6IeNWt6U2EEI7muiUL-xUUW58c/preview" data-height="500px"></div>

<h3 id="gt-项目开发流程深入学习："><a href="#gt-项目开发流程深入学习：" class="headerlink" title="&gt; 项目开发流程深入学习："></a>&gt; 项目开发流程深入学习：</h3><blockquote>
<p>项目开发流程总结（C项目管理、GCC、GDB等）。</p>
</blockquote>
<h4 id="gt-相关留存资料：-6"><a href="#gt-相关留存资料：-6" class="headerlink" title="&gt; 相关留存资料："></a>&gt; 相关留存资料：</h4><div class="pdfobject-container" data-target="https://drive.google.com/file/d/1HWIYnT_FpXFvE0wjUFZTvritoOo9IJVY/preview" data-height="500px"></div>

<h3 id="gt-AC-AP网络知识学习："><a href="#gt-AC-AP网络知识学习：" class="headerlink" title="&gt; AC/AP网络知识学习："></a>&gt; AC/AP网络知识学习：</h3><blockquote>
<p>AC/AP相关知识了解。</p>
</blockquote>
<h4 id="gt-相关留存资料：-7"><a href="#gt-相关留存资料：-7" class="headerlink" title="&gt; 相关留存资料："></a>&gt; 相关留存资料：</h4><div class="pdfobject-container" data-target="https://drive.google.com/file/d/1ClhF03htEg2MFs4S_tFv6znQeFdad3fA/preview" data-height="500px"></div>


<h2 id="阶段四：参与项目"><a href="#阶段四：参与项目" class="headerlink" title="阶段四：参与项目"></a>阶段四：参与项目</h2><p>Revision: 122883<br>Author: liuxingj<br>Date: 2019年9月11日 17:48:49<br>Message:<br>FIX|[RDM55769]【质量整改】【国家码】解除了室外类型下会导致radio1信道失踪的情况<br>FIX|[RDM55771]【质量整改】【国家码】修改配置文件，已成功匹配80M频宽下的信道列表<br>FIX|[yellowstone3.5]在channel判断条件中，新增若干室外AP的型号，新增并维护最新的AP型号列表与Vendor保持一致<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/INCLUDE/public/hwDrv.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/LIB/vendorCfg.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/CLI/cli_config_wireless_ap_profile.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/CLI/cli_show_running_config_wireless.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/CLI/cli_show_wireless_ap.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/CLI/cli_show_wireless_ap_profile.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/WIRELESS/include/wdm_country_code.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/WIRELESS/wdm/reg_domains.conf<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/WIRELESS/wdm/wdm_ap_profile_api.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/WIRELESS/wdm/wdm_api.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/WIRELESS/wdm/wdm_country_code.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/WIRELESS/ws_channel_power/channel_adjustment.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/WIRELESS/wsap_conf/wsap_conf.c</p>
<p>Revision: 122712<br>Author: liuxingj<br>Date: 2019年9月4日 19:50:56<br>Message:<br>FIX|[RDM55466]【质量整改】【国家码】修改YS国家码，和华为信道标准进行全样比对，修改AC实际AP状态显示，修改radio关闭问题，增加AC后台状态显示对802.11ac的支持，增加部分国家对室内室外APhwtype不同造成的信道差异进行适应性匹配，修改80M频宽下信道的运算逻辑，增加80M频宽信道的正常显示<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/INCLUDE/wlan-public/common/wireless_defaultconfig.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/WIRELESS/include/wdm_country_code.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/WIRELESS/wdm/country_code.pl<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/WIRELESS/wdm/reg_domains.conf<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/WIRELESS/wdm/wdm.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/WIRELESS/wdm/wdm_ap_profile_api.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/WIRELESS/wdm/wdm_country_code.c</p>
<p>Revision: 122139<br>Author: liuxingj<br>Date: 2019年8月9日 17:35:36<br>Message:<br>FIX|[RDM55275]【开局】air-match template 初始化 template 1修改默认值为5<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/INCLUDE/wlan-public/common/wireless_commdefs.h</p>
<p>Revision: 122132<br>Author: liuxingj<br>Date: 2019年8月9日 16:48:33<br>Message:<br>FIX|[yellowstone3.5]AC上增加AP射频灯开关控制实现，实现与页面交互<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/WIRELESS/include/ws_manageserver.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/WIRELESS/ws_manage_server/ws_manageserver.c</p>
<p>Revision: 122131<br>Author: liuxingj<br>Date: 2019年8月9日 16:48:17<br>Message:<br>FIX|[RDM53942]【开局】修改印尼国家ID国家码对应的信道和频宽<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_R2/Platform/WIRELESS/WIRELESS/wdm/wdm_country_code.c</p>
<p>Revision: 123404<br>Author: liuxingj<br>Date: 2019年10月14日 15:34:01<br>Message:<br>FIX|[yellowstone3.5-cloud]还原NetworkIDGet接口命名<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/INCLUDE/wlan-public/api/wdm_network_api.h</p>
<p>Revision: 123403<br>Author: liuxingj<br>Date: 2019年10月14日 15:18:37<br>Message:<br>FIX|[yellowstone3.5-cloud]还原NetworkIDGet接口命名<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/ACCESS/Captive_Portal/application/cpcm/cpcm.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/ACCESS/Captive_Portal/application/cpim/captive_portal_config.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/ACCESS/Captive_Portal/application/cpim/cpim_api.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/ACCESS/Captive_Portal/cli/cli_show_running_config_cp.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/INCLUDE/wlan-public/api/wdm_network_api.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/WIRELESS/WIRELESS/wdm/wdm_ap_api.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/WIRELESS/WIRELESS/wdm/wdm_network_api.c</p>
<p>Revision: 123396<br>Author: liuxingj<br>Date: 2019年10月14日 13:50:52<br>Message:<br>FIX|[yellowstone3.5-cloud]新增cloud-mode调试命令行和任务代码文件<br>FIX|[yellowstone3.5-cloud]新增Network下UUID命令行和任务代码文件<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/ACCESS/Captive_Portal/application/cpcm/cpcm.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/ACCESS/Captive_Portal/application/cpim/captive_portal_config.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/ACCESS/Captive_Portal/application/cpim/cpim_api.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/ACCESS/Captive_Portal/cli/cli_show_running_config_cp.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/INCLUDE/wlan-public/api/wdm_network_api.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/INCLUDE/wlan-public/common/wireless_commdefs.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/INCLUDE/wlan-public/common/wireless_defaultconfig.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/INCLUDE/wlan-public/porting/usmdb_wdm_network_api.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/INCLUDE/wlan-public/strlib_wireless_cli.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/WIRELESS/CLI/cli_config_wireless_network.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/WIRELESS/CLI/cli_debug_wireless_extend.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/WIRELESS/CLI/cli_show_running_config_wireless.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/WIRELESS/CLI/clicommands_wireless.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/WIRELESS/CLI/strlib_wireless_cli.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/WIRELESS/USMDB/usmdb_wdm_network.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/WIRELESS/WIRELESS/include/wdm.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/WIRELESS/WIRELESS/wdm/wdm.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/WIRELESS/WIRELESS/wdm/wdm_ap_api.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/WIRELESS/WIRELESS/wdm/wdm_ap_profile_api.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/WIRELESS/WIRELESS/wdm/wdm_api.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/WIRELESS/WIRELESS/wdm/wdm_network_api.c</p>
<p>Revision: 123060<br>Author: liuxingj<br>Date: 2019年9月24日 14:13:32<br>Message:<br>FIX|[yellowstone3.5-cloud]新增cloud-mode中ws_cloudmode.h文件<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_yellowstone3.5_cloud/Platform/WIRELESS/WIRELESS/include/ws_cloudmode.h</p>
<p>Revision: 122881<br>Author: liuxingj<br>Date: 2019年9月11日 15:06:28<br>Message:<br>FIX|[RDM55769]【质量整改】【国家码】解除了室外类型下会导致radio1信道失踪的情况<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/wdm/wdm_ap_profile_api.c</p>
<p>Revision: 122880<br>Author: liuxingj<br>Date: 2019年9月11日 15:04:44<br>Message:<br>FIX|[RDM55771]【质量整改】【国家码】修改配置文件，已成功匹配80M频宽下的信道列表<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/include/wdm_country_code.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/wdm/reg_domains.conf<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/wdm/wdm_country_code.c</p>
<p>Revision: 122854<br>Author: liuxingj<br>Date: 2019年9月10日 17:02:33<br>Message:<br>FIX|[yellowstone3.5]在channel判断条件中，新增若干室外AP的型号，新增并维护最新的AP型号列表与Vendor保持一致<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/LIB/vendorCfg.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/CLI/cli_config_wireless_ap_profile.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/CLI/cli_show_running_config_wireless.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/CLI/cli_show_wireless_ap.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/CLI/cli_show_wireless_ap_profile.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/wdm/wdm_api.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/ws_channel_power/channel_adjustment.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/wsap_conf/wsap_conf.c</p>
<p>Revision: 122848<br>Author: liuxingj<br>Date: 2019年9月10日 15:46:44<br>Message:<br>FIX|[yellowstone3.5]在channel判断条件中，新增若干室外AP的型号，新增并维护最新的AP型号列表与Vendor保持一致<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/INCLUDE/public/hwDrv.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/wdm/wdm_ap_profile_api.c</p>
<p>Revision: 122707<br>Author: liuxingj<br>Date: 2019年9月4日 19:41:15<br>Message:<br>FIX|[RDM55466]【质量整改】【国家码】修改YS国家码，和华为信道标准进行全样比对，修改AC实际AP状态显示，修改radio关闭问题，增加AC后台状态显示对802.11ac的支持，增加部分国家对室内室外APhwtype不同造成的信道差异进行适应性匹配，修改80M频宽下信道的运算逻辑，增加80M频宽信道的正常显示<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/INCLUDE/wlan-public/common/wireless_defaultconfig.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/include/wdm_country_code.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/wdm/country_code.pl<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/wdm/reg_domains.conf<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/wdm/wdm.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/wdm/wdm_ap_profile_api.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/wdm/wdm_api.c<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/wdm/wdm_country_code.c</p>
<p>Revision: 122136<br>Author: liuxingj<br>Date: 2019年8月9日 17:08:52<br>Message:<br>FIX|[RDM55275]【开局】air-match template 初始化 template 1修改默认值为5<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/INCLUDE/wlan-public/common/wireless_commdefs.h</p>
<p>Revision: 122061<br>Author: liuxingj<br>Date: 2019年8月7日 10:16:06<br>Message:<br>FIX|[yellowstone3.5]AC上增加AP射频灯开关控制实现，实现与页面交互<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/include/ws_manageserver.h<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/ws_manage_server/ws_manageserver.c</p>
<p>Revision: 122050<br>Author: liuxingj<br>Date: 2019年8月6日 15:40:41<br>Message:<br>FIX|[RDM53942]【开局】修改印尼国家ID国家码对应的信道和频宽<br>Modified : /Branches/Ivy/Code_Ivy7.5_Bigstone_CS6510_DCAC_yellowstone/Platform/WIRELESS/WIRELESS/wdm/wdm_country_code.c</p>
]]></content>
      <tags>
        <tag>Job</tag>
        <tag>Personal</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2019/09/05/Markdown/</url>
    <content><![CDATA[<h1 id="欢迎使用-Markdown"><a href="#欢迎使用-Markdown" class="headerlink" title="欢迎使用 Markdown"></a>欢迎使用 Markdown</h1><p><strong>Markdown是一种轻量级的「标记语言」</strong></p>
<p><img src="https://www.mdeditor.com/images/logos/markdown.png" alt="markdown" title="markdown"></p>
<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”</p>
<blockquote>
<p>Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如<del>Pandoc</del>，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p>
</blockquote>
<p><img src="https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png" alt="Pandao editor.md" title="Pandao editor.md"></p>
<a id="more"></a>
<h2 id="Markdown的功能列表演示"><a href="#Markdown的功能列表演示" class="headerlink" title="Markdown的功能列表演示"></a>Markdown的功能列表演示</h2><h1 id="标题H1"><a href="#标题H1" class="headerlink" title="标题H1"></a>标题H1</h1><h2 id="标题H2"><a href="#标题H2" class="headerlink" title="标题H2"></a>标题H2</h2><h3 id="标题H3"><a href="#标题H3" class="headerlink" title="标题H3"></a>标题H3</h3><h4 id="标题H4"><a href="#标题H4" class="headerlink" title="标题H4"></a>标题H4</h4><h5 id="标题H5"><a href="#标题H5" class="headerlink" title="标题H5"></a>标题H5</h5><h6 id="标题H5-1"><a href="#标题H5-1" class="headerlink" title="标题H5"></a>标题H5</h6><h3 id="字符效果和横线等"><a href="#字符效果和横线等" class="headerlink" title="字符效果和横线等"></a>字符效果和横线等</h3><hr>
<p><del>删除线</del> <s>删除线（开启识别HTML标签时）</s></p>
<p><em>斜体字</em>      <em>斜体字</em></p>
<p><strong>粗体</strong>  <strong>粗体</strong></p>
<p><strong><em>粗斜体</em></strong> <strong><em>粗斜体</em></strong></p>
<p>上标：X<sub>2</sub>，下标：O<sup>2</sup></p>
<p><strong>缩写(同HTML的abbr标签)</strong></p>
<blockquote>
<p>即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启</p>
</blockquote>
<p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p>
<h3 id="引用-Blockquotes"><a href="#引用-Blockquotes" class="headerlink" title="引用 Blockquotes"></a>引用 Blockquotes</h3><blockquote>
<p>引用文本 Blockquotes</p>
</blockquote>
<p>引用的行内混合 Blockquotes</p>
<blockquote>
<p>引用：如果想要插入空白换行<code>即&lt;br /&gt;标签</code>，在插入处先键入两个以上的空格然后回车即可，<a href="https://www.mdeditor.com/" target="_blank" rel="noopener">普通链接</a>。</p>
</blockquote>
<h3 id="锚点与链接-Links"><a href="#锚点与链接-Links" class="headerlink" title="锚点与链接 Links"></a>锚点与链接 Links</h3><p><a href="https://www.mdeditor.com/" target="_blank" rel="noopener">普通链接</a><br><a href="https://www.mdeditor.com/" target="_blank" rel="noopener" title="普通链接带标题">普通链接带标题</a><br>直接链接：<a href="https://www.mdeditor.com" target="_blank" rel="noopener">https://www.mdeditor.com</a><br>[锚点链接][anchor-id]<br>[anchor-id]: <a href="https://www.mdeditor.com/" target="_blank" rel="noopener">https://www.mdeditor.com/</a><br><a href="mailto:test.test@gmail.com">mailto:test.test@gmail.com</a><br>GFM a-tail link @pandao<br>邮箱地址自动链接 <a href="mailto:test.test@gmail.com">test.test@gmail.com</a>  <a href="mailto:www@vip.qq.com">www@vip.qq.com</a></p>
<blockquote>
<p>@pandao</p>
</blockquote>
<h3 id="多语言代码高亮-Codes"><a href="#多语言代码高亮-Codes" class="headerlink" title="多语言代码高亮 Codes"></a>多语言代码高亮 Codes</h3><h4 id="行内代码-Inline-code"><a href="#行内代码-Inline-code" class="headerlink" title="行内代码 Inline code"></a>行内代码 Inline code</h4><p>执行命令：<code>npm install marked</code></p>
<h4 id="缩进风格"><a href="#缩进风格" class="headerlink" title="缩进风格"></a>缩进风格</h4><p>即缩进四个空格，也做为实现类似 <code>&lt;pre&gt;</code> 预格式化文本 ( Preformatted Text ) 的功能。</p>
<pre><code>&lt;?php
    echo &quot;Hello world!&quot;;
?&gt;</code></pre><p>预格式化文本：</p>
<pre><code>| First Header  | Second Header |
| ------------- | ------------- |
| Content Cell  | Content Cell  |
| Content Cell  | Content Cell  |</code></pre><h4 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HTML-代码-HTML-codes"><a href="#HTML-代码-HTML-codes" class="headerlink" title="HTML 代码 HTML codes"></a>HTML 代码 HTML codes</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mate</span> <span class="attr">charest</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"Editor.md, Markdown, Editor"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;<span class="attribute">color</span>:<span class="number">#444</span>;<span class="attribute">font-family</span>: <span class="string">"Microsoft Yahei"</span>, Tahoma, <span class="string">"Hiragino Sans GB"</span>, Arial;<span class="attribute">background</span>:<span class="number">#fff</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">ul</span>&#123;<span class="attribute">list-style</span>: none;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">img</span>&#123;<span class="attribute">border</span>:none;<span class="attribute">vertical-align</span>: middle;&#125;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-xxl"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-green"</span>&gt;</span>Plain text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="图片-Images"><a href="#图片-Images" class="headerlink" title="图片 Images"></a>图片 Images</h3><p>图片加链接 (Image + Link)：</p>
<p><a href="https://www.mdeditor.com/images/logos/markdown.png" target="_blank" rel="noopener" title="markdown"><img src="https://www.mdeditor.com/images/logos/markdown.png" alt=""></a></p>
<blockquote>
<p>Follow your heart.</p>
</blockquote>
<hr>
<h3 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表 Lists"></a>列表 Lists</h3><h4 id="无序列表（减号）Unordered-Lists"><a href="#无序列表（减号）Unordered-Lists" class="headerlink" title="无序列表（减号）Unordered Lists (-)"></a>无序列表（减号）Unordered Lists (-)</h4><ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h4 id="无序列表（星号）Unordered-Lists"><a href="#无序列表（星号）Unordered-Lists" class="headerlink" title="无序列表（星号）Unordered Lists (*)"></a>无序列表（星号）Unordered Lists (*)</h4><ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h4 id="无序列表（加号和嵌套）Unordered-Lists"><a href="#无序列表（加号和嵌套）Unordered-Lists" class="headerlink" title="无序列表（加号和嵌套）Unordered Lists (+)"></a>无序列表（加号和嵌套）Unordered Lists (+)</h4><ul>
<li>列表一</li>
<li>列表二<ul>
<li>列表二-1</li>
<li>列表二-2</li>
<li>列表二-3</li>
</ul>
</li>
<li>列表三<ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
</li>
</ul>
<h4 id="有序列表-Ordered-Lists"><a href="#有序列表-Ordered-Lists" class="headerlink" title="有序列表 Ordered Lists (-)"></a>有序列表 Ordered Lists (-)</h4><ol>
<li>第一行</li>
<li>第二行</li>
<li>第三行</li>
</ol>
<h4 id="GFM-task-list"><a href="#GFM-task-list" class="headerlink" title="GFM task list"></a>GFM task list</h4><ul>
<li><input checked="" disabled="" type="checkbox"> GFM task list 1</li>
<li><input checked="" disabled="" type="checkbox"> GFM task list 2</li>
<li><input disabled="" type="checkbox"> GFM task list 3<ul>
<li><input disabled="" type="checkbox"> GFM task list 3-1</li>
<li><input disabled="" type="checkbox"> GFM task list 3-2</li>
<li><input disabled="" type="checkbox"> GFM task list 3-3</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> GFM task list 4<ul>
<li><input disabled="" type="checkbox"> GFM task list 4-1</li>
<li><input disabled="" type="checkbox"> GFM task list 4-2</li>
</ul>
</li>
</ul>
<hr>
<h3 id="绘制表格-Tables"><a href="#绘制表格-Tables" class="headerlink" title="绘制表格 Tables"></a>绘制表格 Tables</h3><table>
<thead>
<tr>
<th>项目</th>
<th align="right">价格</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td>计算机</td>
<td align="right">$1600</td>
<td align="center">5</td>
</tr>
<tr>
<td>手机</td>
<td align="right">$12</td>
<td align="center">12</td>
</tr>
<tr>
<td>管线</td>
<td align="right">$1</td>
<td align="center">234</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Function name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>help()</code></td>
<td>Display the help window.</td>
</tr>
<tr>
<td><code>destroy()</code></td>
<td><strong>Destroy your computer!</strong></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">Left-Aligned</th>
<th align="center">Center Aligned</th>
<th align="right">Right Aligned</th>
</tr>
</thead>
<tbody><tr>
<td align="left">col 3 is</td>
<td align="center">some wordy text</td>
<td align="right">$1600</td>
</tr>
<tr>
<td align="left">col 2 is</td>
<td align="center">centered</td>
<td align="right">$12</td>
</tr>
<tr>
<td align="left">zebra stripes</td>
<td align="center">are neat</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Item</th>
<th align="right">Value</th>
</tr>
</thead>
<tbody><tr>
<td>Computer</td>
<td align="right">$1600</td>
</tr>
<tr>
<td>Phone</td>
<td align="right">$12</td>
</tr>
<tr>
<td>Pipe</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<hr>
<h4 id="特殊符号-HTML-Entities-Codes"><a href="#特殊符号-HTML-Entities-Codes" class="headerlink" title="特殊符号 HTML Entities Codes"></a>特殊符号 HTML Entities Codes</h4><p>&copy; &amp;  &uml; &trade; &iexcl; &pound;<br>&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot;</p>
<p>X&sup2; Y&sup3; &frac34; &frac14;  &times;  &divide;   &raquo;</p>
<p>18&ordm;C  &quot;  &apos;</p>
<hr>
<h3 id="Emoji表情-smiley"><a href="#Emoji表情-smiley" class="headerlink" title="Emoji表情 :smiley:"></a>Emoji表情 :smiley:</h3><blockquote>
<p>Blockquotes :star:</p>
</blockquote>
<h4 id="GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x"><a href="#GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x" class="headerlink" title="GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:"></a>GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:</h4><ul>
<li><input checked="" disabled="" type="checkbox"> :smiley: @mentions, :smiley: #refs, <a href="">links</a>, <strong>formatting</strong>, and <del>tags</del> supported :editormd-logo:;</li>
<li><input checked="" disabled="" type="checkbox"> list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;</li>
<li><input checked="" disabled="" type="checkbox"> [ ] :smiley: this is a complete item :smiley:;</li>
<li><input disabled="" type="checkbox"> []this is an incomplete item <a href="#">test link</a> :fa-star: @pandao;</li>
<li><input disabled="" type="checkbox"> [ ]this is an incomplete item :fa-star: :fa-gear:;<ul>
<li><input disabled="" type="checkbox"> :smiley: this is an incomplete item <a href="#">test link</a> :fa-star: :fa-gear:;</li>
<li><input disabled="" type="checkbox"> :smiley: this is  :fa-star: :fa-gear: an incomplete item <a href="#">test link</a>;</li>
</ul>
</li>
</ul>
<h4 id="反斜杠-Escape"><a href="#反斜杠-Escape" class="headerlink" title="反斜杠 Escape"></a>反斜杠 Escape</h4><p>*literal asterisks*</p>
<hr>
<h3 id="科学公式-TeX-KaTeX"><a href="#科学公式-TeX-KaTeX" class="headerlink" title="科学公式 TeX(KaTeX)"></a>科学公式 TeX(KaTeX)</h3><p>$$E=mc^2$$</p>
<p>行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。</p>
<p>$$x &gt; y$$</p>
<p>$$(\sqrt{3x-1}+(1+x)^2)$$</p>
<p>$$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$</p>
<p>多行公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n a\_k b\_k \right)^2</span><br><span class="line">\leq</span><br><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n a\_k^2 \right)</span><br><span class="line">\left( \sum\_&#123;k&#x3D;1&#125;^n b\_k^2 \right)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">    \frac&#123;1&#125;&#123;</span><br><span class="line">        \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;</span><br><span class="line">        \frac25 \pi&#125;&#125; &#x3D; 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;</span><br><span class="line">        1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span><br><span class="line">        &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125;</span><br><span class="line">         &#123;1+\cdots&#125; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(x) &#x3D; \int_&#123;-\infty&#125;^\infty</span><br><span class="line">    \hat f(\xi)\,e^&#123;2 \pi i \xi x&#125;</span><br><span class="line">    \,d\xi</span><br></pre></td></tr></table></figure>
<h3 id="分页符-Page-break"><a href="#分页符-Page-break" class="headerlink" title="分页符 Page break"></a>分页符 Page break</h3><blockquote>
<p>Print Test: Ctrl + P</p>
</blockquote>
<hr>
<h3 id="绘制流程图-Flowchart"><a href="#绘制流程图-Flowchart" class="headerlink" title="绘制流程图 Flowchart"></a>绘制流程图 Flowchart</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 用户登陆</span><br><span class="line">op&#x3D;&gt;operation: 登陆操作</span><br><span class="line">cond&#x3D;&gt;condition: 登陆成功 Yes or No?</span><br><span class="line">e&#x3D;&gt;end: 进入后台</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="绘制序列图-Sequence-Diagram"><a href="#绘制序列图-Sequence-Diagram" class="headerlink" title="绘制序列图 Sequence Diagram"></a>绘制序列图 Sequence Diagram</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello</span><br><span class="line">Note right of China: China thinks\nabout it</span><br><span class="line">China--&gt;Andrew: How are you?</span><br><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span><br></pre></td></tr></table></figure>
<h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSL</title>
    <url>/2019/09/05/OpenSSL/</url>
    <content><![CDATA[<h1 id="OpenSSL-API"><a href="#OpenSSL-API" class="headerlink" title="OpenSSL API"></a>OpenSSL API</h1><h2 id="什么是-SSL？"><a href="#什么是-SSL？" class="headerlink" title="什么是 SSL？"></a>什么是 SSL？</h2><p>SSL 是一个缩写，代表的是 Secure Sockets Layer（安全套接层）。它是支持在Internet 上进行安全通信的标准，并且将数据密码术集成到了协议之中。数据在离开您的计算机之前就已经被加密，然后只有 到达它预定的目标后才被解密。证书和密码学算法支持了这一切的运转，使用 OpenSSL，您将有机会切身体会它们。</p>
<p>理论上，如果加密的数据在到达目标之前被截取或窃听，那些数据是不可能被破解的。不过，由于计算机的变化一年比一年快，而且密码翻译方法有了新的发展，因此，SSL 中使用的加密协议被破解的可能性也在增大。</p>
<p>可以将 SSL 和安全连接用于 Internet 上任何类型的协议，不管是 HTTP、POP3，还是 FTP。还可以用 SSL 来保护 Telnet 会话。虽然可以用 SSL 保护任何连接，但是不必对每一类连接都使用 SSL。如果连接传输敏感信息，则应使用 SSL。</p>
<h2 id="什么是-OpenSSL？"><a href="#什么是-OpenSSL？" class="headerlink" title="什么是 OpenSSL？"></a>什么是 OpenSSL？</h2><p>OpenSSL 不仅仅是 SSL。它可以实现消息摘要、文件的加密和解密、数字证书、数字签名 和随机数字。关于 OpenSSL 库的内容非常多，远不是一篇文章可以容纳的。</p>
<p>OpenSSL 不只是 API，它还是一个命令行工具。命令行工具可以完成与 API 同样的工作， 而且更进一步，可以测试 SSL 服务器和客户机。它还让开发人员对 OpenSSL 的能力有一个认识。</p>
<a id="more"></a>
<h2 id="您需要什么"><a href="#您需要什么" class="headerlink" title="您需要什么"></a>您需要什么</h2><p>首先需要的是最新版本的 OpenSSL。查阅<a href="https://www.openssl.org/" target="_blank" rel="noopener">官网</a>，以确定从哪里可以获得最新的可以自己编译的源代码，或者最新版本的二进制文件（如果您不希望花费时间来编译的话）。不过，为了安全起见，我建议您下载最新的源代码并自己编译它。二进制版本通常是由第三方而不是由 OpenSSL 的开发人员来编译和发行的。</p>
<p>一些 Linux 的发行版本附带了 OpenSSL 的二进制版本，对于学习如何使用 OpenSSL 库来说，这足够了；不过，如果您打算去做一些实际的事情，那么一定要得到最新的版本，并保持该版本一直是最新的。</p>
<p>对于以 RPM 形式安装的 Linux 发行版本（Red Hat、Mandrake 等），建议您通过从发行版本制造商那里获得 RPM 程序包来更新您的 OpenSSL 发行版本。出于安全方面的原因，建议您使用最新版本的发行版本。如果您的发行版本不能使用最新版本的 OpenSSL，那么建议您只覆盖库文件，不要覆盖可执行文件。OpenSSL 附带的 FAQ 文档中包含了有关这方面的细节。</p>
<p>还要注意的是，OpenSSL 并没有在所有的平台上都获得官方支持。虽然制造商已经尽力使其能够跨平台兼容，但仍然存在 OpenSSL 不能用于您的计算机和/或操作系统的可能。请参阅 OpenSSL 的 <a href="https://www.openssl.org/" target="_blank" rel="noopener">Web 站点</a>，以获得关于哪些平台可以得到支持的信息。</p>
<p>如果想使用 OpenSSL 来生成证书请求和数字证书，那么必须创建一个配置文件。在OpenSSL 程序包的 apps 文件夹中，有一个名为 openssl.cnf 的 可用模板文件。我不会对该文件进行讨论，因为这不在本文要求范围之内。不过，该模板文件有一些非常好的注释，而且如果在 Internet 上搜索，您可以找到很多讨论修改该文件的教程。</p>
<h2 id="头文件和初始化"><a href="#头文件和初始化" class="headerlink" title="头文件和初始化"></a>头文件和初始化</h2><p>本教程所使用的头文件只有三个：ssl.h、bio.h 和 err.h。它们都位于 openssl 子目录中，而且都是开发您的项目所必需的。要初始化 OpenSSL 库，只需要三个代码行即可。清单 1 中列出了所有内容。其他的头文件 和/或 初始化函数可能是其他一些功能所必需的。</p>
<p>清单 1. 必需的头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* OpenSSL headers */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"openssl/bio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"openssl/ssl.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"openssl/err.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initializing OpenSSL */</span></span><br><span class="line"></span><br><span class="line">SSL_load_error_strings();</span><br><span class="line"></span><br><span class="line">ERR_load_BIO_strings();</span><br><span class="line"></span><br><span class="line">OpenSSL_add_all_algorithms();</span><br></pre></td></tr></table></figure>

<h2 id="建立非安全连接"><a href="#建立非安全连接" class="headerlink" title="建立非安全连接"></a>建立非安全连接</h2><p>不管连接是安全的还是不安全的，OpenSSL 都使用了一个名为 BIO 的抽象库来处理包括文件和套接字在内的各种类型的通信。您还可以将 OpenSSL 设置成为一个过滤器，比如用于 UU 或 Base64 编码的过滤器。</p>
<p>在这里对 BIO 库进行全面说明有点麻烦，所以我将根据需要一点一点地介绍它。首先，我将向您展示如何建立一个标准的套接字连接。相对于使用 BSD 套接字库，该操作需要的代码行更少一些。</p>
<p>在建立连接（无论安全与否）之前，要创建一个指向 BIO 对象的指针。这类似于在标准 C 中为文件流创建 FILE 指针。</p>
<p>清单 2. 指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BIO * bio;</span><br></pre></td></tr></table></figure>

<h3 id="打开连接"><a href="#打开连接" class="headerlink" title="打开连接"></a>打开连接</h3><p>创建新的连接需要调用 BIO_new_connect 。您可以在同一个调用中同时 指定主机名和端口号。也可以将其拆分为两个单独的调用：一个是创建连接并设置主机名的BIO_new_connect 调用，另一个是设置端口号的 BIO_set_conn_port （或者 BIO_set_conn_int_port ）调用。</p>
<p>不管怎样，一旦 BIO 的主机名和端口号都已指定，该指针会尝试打开连接。没有什么可以影响它。如果创建 BIO 对象时遇到问题，指针将会是 NULL。为了确保连接成功，必须执行 BIO_do_connect 调用。</p>
<p>清单 3. 创建并打开连接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bio = BIO_new_connect(<span class="string">"hostname:port"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bio == <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle the failure */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BIO_do_connect(bio) &lt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle failed connection */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，第一行代码使用指定的主机名和端口创建了一个新的 BIO 对象，并以所示风格对该对象进行格式化。例如，如果您要连接到 <a href="http://www.ibm.com" target="_blank" rel="noopener">www.ibm.com</a> 的 80 端口，那么该字符串将是 <a href="http://www.ibm.com:80" target="_blank" rel="noopener">www.ibm.com:80</a> 。调用 BIO_do_connect 检查连接是否成功。如果出错，则返回 0 或 -1。</p>
<h3 id="与服务器进行通信"><a href="#与服务器进行通信" class="headerlink" title="与服务器进行通信"></a>与服务器进行通信</h3><p>不管 BIO 对象是套接字还是文件，对其进行的读和写操作都是通过以下两个函数来完成的： BIO_read 和 BIO_write 。很简单，对吧？精彩之处就在于它始终如此。</p>
<p>BIO_read 将尝试从服务器读取一定数目的字节。它返回读取的字节数、 0 或者 -1。在受阻塞的连接中，该函数返回 0，表示连接已经关闭，而 -1 则表示连接出现错误。在非阻塞连接的情况下，返回 0 表示没有可以获得的数据，返回 -1 表示连接出错。可以调用 BIO_should_retry 来确定是否可能重复出现该错误。</p>
<p>清单 4. 从连接读取</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = BIO_read(bio, buf, len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle closed connection */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(! BIO_should_retry(bio))</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle failed read here */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do something to handle the retry */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BIO_write 会试着将字节写入套接字。它将返回实际写入的字节数、0 或者 -1。同 BIO_read ，0 或 -1 不一定表示错误。BIO_should_retry 是找出问题的途径。如果需要重试写操作，它必须使用和前一次完全相同的参数。</p>
<p>清单 5. 写入到连接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(BIO_write(bio, buf, len) &lt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(! BIO_should_retry(bio))</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle failed write here */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do something to handle the retry */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>关闭连接也很简单。您可以使用以下两种方式之一来关闭连接： BIO_reset 或 BIO_free_all 。如果您还需要重新使用对象，那么请使用第一种方式。 如果您不再重新使用它，则可以使用第二种方式。</p>
<p>BIO_reset 关闭连接并重新设置 BIO 对象的内部状态，以便可以重新使用连接。如果要在整个应用程序中使用同一对象，比如使用一台安全的聊天客户机，那么这样做是有益的。该函数没有返回值。</p>
<p>BIO_free_all 所做正如其所言：它释放内部结构体，并释放所有相关联的内存，其中包括关闭相关联的套接字。如果将 BIO 嵌入于一个类中，那么应该在类的析构函数中使用这个调用。</p>
<p>清单 6. 关闭连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* To reuse the connection, use this line *&#x2F;</span><br><span class="line"></span><br><span class="line">BIO_reset(bio);</span><br><span class="line"></span><br><span class="line">&#x2F;* To free it from memory, use this line *&#x2F;</span><br><span class="line"></span><br><span class="line">BIO_free_all(bio);</span><br></pre></td></tr></table></figure>

<h2 id="建立安全连接"><a href="#建立安全连接" class="headerlink" title="建立安全连接"></a>建立安全连接</h2><p>现在需要给出建立安全连接需要做哪些事情。唯一要改变的地方就是建立并进行连接。其他所有内容都是相同的。</p>
<p>安全连接要求在连接建立后进行握手。在握手过程中，服务器向客户机发送一个证书，然后，客户机根据一组可信任证书来核实该证书。它还将检查证书，以确保它没有过期。要 检验证书是可信任的，需要在连接建立之前提前加载一个可信任证书库。</p>
<p>只有在服务器发出请求时，客户机才会向服务器发送一个证书。该过程叫做客户机认证。使用证书，在客户机和服务器之间传递密码参数，以建立安全连接。尽管握手是在建立连接之后才进行的，但是客户机或服务器可以在任何时刻请求进行一次新的握手。</p>
<p><a href="">参考资料</a>部分中列出的 Netscasp 文章 和 RFC 2246 ，对握手以及建立安全连接的其他方面的知识进行了更详尽的论述。</p>
<h3 id="为安全连接进行设置"><a href="#为安全连接进行设置" class="headerlink" title="为安全连接进行设置"></a>为安全连接进行设置</h3><p>为安全连接进行设置要多几行代码。同时需要有另一个类型为 SSL_CTX 的指针。该结构保存了一些 SSL 信息。您也可以利用它通过 BIO 库建立 SSL 连接。可以通过使用 SSL 方法函数调用 SSL_CTX_new 来创建这个结构，该方法函数通常是 SSLv23_client_method 。</p>
<p>还需要另一个 SSL 类型的指针来保持 SSL 连接结构（这是短时间就能完成的一些连接所必需的）。以后还可以用该 SSL 指针来检查连接信息或设置其他 SSL 参数。</p>
<p>清单 7. 设置 SSL 指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SSL_CTX * ctx = SSL_CTX_new(SSLv23_client_method());</span><br><span class="line"></span><br><span class="line">SSL * ssl;</span><br></pre></td></tr></table></figure>
<h3 id="加载可信任证书库"><a href="#加载可信任证书库" class="headerlink" title="加载可信任证书库"></a>加载可信任证书库</h3><p>在创建上下文结构之后，必须加载一个可信任证书库。这是成功验证每个证书所必需的。如果不能确认证书是可信任的，那么 OpenSSL 会将证书标记为无效（但连接仍可以继续）。</p>
<p>OpenSSL 附带了一组可信任证书。它们位于源文件树的 certs 目录中。 不过，每个证书都是一个独立的文件 —— 也就是说，需要单独加载每一个证书。在 certs 目录下，还有一个存放过期证书的子目录。试图加载这些证书将会出错。</p>
<p>如果您愿意，可以分别加载每一个文件，但为了简便起见，最新的 OpenSSL 发行版本的可信任证书通常存放在源代码档案文件中，这些档案文件位于名为“TrustStore.pem”的单个文件中。如果已经有了一个可信任证书库，并打算将它用于特定的项目中，那么只需使用您的文件替换清单 8 中的“TrustStore.pem”（或者使用单独的函数调用将它们全部加载）即可。</p>
<p>可以调用<code>int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,
                                  const char *CApath);</code> 来加载可信任证书库文件。这里要用到三个参数：上下文指针、可信任库文件的路径和文件名，以及证书所在目录的路径。必须指定可信任库文件或证书的目录。如果指定成功，则返回 1，如果遇到问题，则返回 0。</p>
<p>清单 8. 加载信任库</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(! SSL_CTX_load_verify_locations(ctx, <span class="string">"/path/to/TrustStore.pem"</span>, <span class="literal">NULL</span>))</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle failed load here */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果打算使用目录存储可信任库，那么必须要以特定的方式命名文件。OpenSSL 文档清楚 地说明了应该如何去做，不过，OpenSSL 附带了一个名为 c_rehash 的工具， 它可以将文件夹配置为可用于 SSL_CTX_load_verify_locations 的路径参数。</p>
<p>清单 9. 配置证书文件夹并使用它</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Use this at the command line */</span></span><br><span class="line"></span><br><span class="line">c_rehash /path/to/certfolder</span><br><span class="line"></span><br><span class="line"><span class="comment">/* then call this from within the application */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(! SSL_CTX_load_verify_locations(ctx, <span class="literal">NULL</span>, <span class="string">"/path/to/certfolder"</span>))</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle error here */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了指定所有需要的验证证书，您可以根据需要命名任意数量的单独文件或文件夹。您还可以同时指定文件和文件夹。</p>
<h3 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h3><p>将指向 SSL 上下文的指针作为唯一参数，使用 BIO_new_ssl_connect 创建 BIO 对象。还需要获得指向 SSL 结构的指针。在本文中，只将该指针用于 SSL_set_mode 函数。而这个函数是用来设置 SSL_MODE_AUTO_RETRY 标记的。使用这个选项进行设置，如果服务器突然希望进行一次新的握手，那么 OpenSSL 可以在后台处理它。如果没有这个选项，当服务器希望进行一次新的握手时，进行读或写操作都将返回一个错误，同时还会在该过程中设置 retry 标记。</p>
<p>清单 10. 设置 BIO 对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bio = BIO_new_ssl_connect(ctx);</span><br><span class="line"></span><br><span class="line">BIO_get_ssl(bio, &amp; ssl);</span><br><span class="line"></span><br><span class="line">SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);</span><br></pre></td></tr></table></figure>
<p>设置 SSL 上下文结构之后，就可以创建连接了。主机名是使用 BIO_set_conn_hostname 函数设置的。主机名和端口的指定格式与前面的相同。该函数还可以打开到主机的连接。为了确认已经成功打开连接，必须执行对 BIO_do_connect 的调用。该调用还将执行握手来建立安全连接。</p>
<p>清单 11. 打开安全连接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Attempt to connect */</span></span><br><span class="line"></span><br><span class="line">BIO_set_conn_hostname(bio, <span class="string">"hostname:port"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Verify the connection opened and perform the handshake */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BIO_do_connect(bio) &lt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle failed connection */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接建立后，必须检查证书，以确定它是否有效。实际上，OpenSSL 为我们完成了这项任务。如果证书有致命的问题（例如，哈希值无效），那么将无法建立连接。但是，如果证书的问题并不是致命的（当它已经过期或者尚不合法时），那么仍可以继续使用连接。</p>
<p>可以将 SSL 结构作为唯一参数，调用 SSL_get_verify_result 来查明证书是否通过了 OpenSSL 的检验。如果证书通过了包括信任检查在内的 OpenSSL 的内部检查，则返回 X509_V_OK。如果有地方出了问题，则返回一个错误代码，该代码被记录在命令行工具的 verify 选项下。</p>
<p>应该注意的是，验证失败并不意味着连接不能使用。是否应该使用连接取决于验证结果和安全方面的考虑。例如，失败的信任验证可能只是意味着没有可信任的证书。连接仍然可用，只是需要从思想上提高安全意识。</p>
<p>清单 12. 检查证书是否有效</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(SSL_get_verify_result(ssl) != X509_V_OK)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle the failed verification */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是所需要的全部操作。通常，与服务器进行通信都要使用 BIO_read 和 BIO_write 。并且只需调用 BIO_free_all 或 BIO_reset ，就可以关闭连接，具体调用哪一个方法取决于是否重用 BIO。</p>
<p>必须在结束应用程序之前的某个时刻释放 SSL 上下文结构。可以调用 SSL_CTX_free 来释放该结构。</p>
<p>清单 13. 清除 SSL 上下文</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SSL_CTX_free(ctx);</span><br></pre></td></tr></table></figure>

<h2 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h2><p>显然 OpenSSL 抛出了某种类型的错误。这意味着什么？首先，您需要得到错误代码本身； ERR_get_error 可以完成这项任务；然后，需要将错误代码转换为错误字符串，它是一个指向由 SSL_load_error_strings 或 ERR_load_BIO_strings 加载到内存中的永久字符串的指针。可以在一个嵌套调用中完成这项操作。</p>
<p>表 1 略述了从错误栈检索错误的方法。清单 24 展示了如何打印文本字符串中的最后一个 错误信息。</p>
<p>表 1. 从栈中检索错误</p>
<table>
    <tr>
        <th>ERR_reason_error_string</th>
        <th>返回一个静态字符串的指针，然后可以将字符串显示在屏幕上、写入文件，或者以任何您希望的方式进行处理</th>
    </tr>
    <tr>
        <th>ERR_lib_error_string</th>
        <th>指出错误发生在哪个库中</th>
    </tr>
    <tr>
        <th>ERR_func_error_string</th>
        <th>返回导致错误的 OpenSSL 函数</th>
    </tr>
</table>

<p>清单 14. 打印出最后一个错误</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, ERR_reason_error_string(ERR_get_error()));</span><br></pre></td></tr></table></figure>
<p>您还可以让库给出预先格式化了的错误字符串。可以调用 ERR_error_string 来得到该字符串。该函数将错误代码和一个预分配的缓冲区作为参数。而这个缓冲区必须是 256 字节长。如果参数为 NULL，则 OpenSSL 会将字符串写入到一个长度为 256 字节的静态缓冲区中，并返回指向该缓冲区的 指针。否则，它将返回您给出的指针。如果您选择的是静态缓冲区选项，那么在下一次调用 ERR_error_string 时，该缓冲区会被覆盖。</p>
<p>清单 15. 获得预先格式化的错误字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ERR_error_string(ERR_get_error(), <span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>
<p>您还可以将整个错误队列转储到文件或 BIO 中。可以通过 ERR_print_errors 或 ERR_print_errors_fp 来实现这项操作。队列是以可读格式被转储的。第一个函数将队列发送到 BIO ，第二个函数将队列发送到 FILE 。字符串格式如下（引自 OpenSSL 文档）：</p>
<pre><code>[pid]:error:[error code]:[library name]:[function name]:[reason string]:[file name]:[line]:[optional text message]</code></pre><p>其中， [pid] 是进程 ID， [error code] 是一个 8 位十六进制代码， [file name] 是 OpenSSL 库中的源代码文件， [line]是源文件中的行号。</p>
<p>清单 16. 转储错误队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ERR_print_errors_fp(FILE *);</span><br><span class="line"></span><br><span class="line">ERR_print_errors(BIO *);</span><br></pre></td></tr></table></figure>
<h2 id="开始做吧"><a href="#开始做吧" class="headerlink" title="开始做吧"></a>开始做吧</h2><p>使用 OpenSSL 创建基本的连接并不困难，但是，当试着确定该如何去做时，文档可能是一个小障碍。本文向您介绍了一些基本概念，但 OpenSSL 还有很多灵活之处有待发掘，而且您还可能需要一些高级设置，以便项目能够充分利用 SSL 的功能。</p>
<p>本文中有两个样例。一个样例展示了到 <a href="http://www.verisign.com/" target="_blank" rel="noopener">http://www.verisign.com/</a> 的非安全连接，另一个则展示了到 <a href="http://www.verisign.com/" target="_blank" rel="noopener">http://www.verisign.com/</a> 的安全 SSL 连接。两者都是连接到服务器并下载其主页。它们没有进行任何安全检查，而且库中的所有设置都是默认值 —— 作为本文的一部分，应该只将这些用于教学目的。</p>
<p>在任何支持的平台上，源代码的编译都应该是非常容易的，不过我建议您使用最新版本的 OpenSSL。</p>
]]></content>
      <tags>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 简介</title>
    <url>/2019/09/05/redis1/</url>
    <content><![CDATA[<h1 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h1><p>redis 是一个开源的使用 ANSI C 语言编写、基于内存亦可持久化的日志型、Key-Value 数据库，并提供了对多种编程语言的支持。<br></br><br>redis 的外围由一个键、值映射的字典构成，Redis 五种数据类型：string ，hash ，list ，set 及 zset (sorted set) ，所以Redis 也被称为数据结构服务器。<br></br><br>redis 是一个 key-value 存储系统。支持存储的 value 类型包括 string (字符串)、list (链表)、set (集合)、zset (sorted set –有序集合)和 hash（哈希）。这些数据类型都支持 push/pop 、 add/remove 及取交集并集和差集等操作，且 Redis 支持各种不同方式的排序。为了保证效率，数据都是缓存在内存中。 redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave (主从)同步。<br></br><br>redis 支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得 Redis 可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。</p>
<a id="more"></a>
</br>
</br>
## Redis的特点
- redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
- redis 是完全在内存中保存数据的数据库，使用磁盘只是为了持久化。
- redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list ，set ，zset ，hash 等数据结构的存储。
- redis 支持数据的备份，即 master-slave 模式的数据备份。
</br>
</br>

<h2 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h2><ul>
<li><code>性能极高</code> —— redis 是一个高性能的 key-value 数据库，读的速度能达到110000次/s,写的速度能达到81000次/s。</li>
<li><code>丰富的数据类型</code> —— Redis 支持 string ， hash ，list ，set 及 zset (sorted set) 等数据类型。</li>
<li><code>原子性</code> —— redis 的所有操作都是原子性的，要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。</li>
<li><code>丰富的特性</code> —— redis 支持 publish / subscribe , 通知, key 过期等特性。</li>
</ul>
</br>
</br>
>redis 使用了两种文件格式：

<ul>
<li><code>全量数据格式</code>：把内存中的数据写入磁盘，便于下次读取文件进行加载</li>
<li><code>增量请求文件</code>：把内存中的数据序列化为操作请求，用于读取文件进行replay得到数据，序列化的操作包括 SET 、 RPUSH 、 SADD 、 ZADD 。</li>
</ul>
</br>
</br>

<blockquote>
<p>redis 的存储分为内存存储、磁盘存储和 log 文件三部分，配置文件中有三个参数对其进行配置。</p>
</blockquote>
<ul>
<li><p><code>save seconds updates</code>：save配置，指出在多长时间内，有多少次更新操作，就将数据同步到数据文件。</p>
</li>
<li><p><code>appendonly yes/no</code>：appendonly配置，指出是否在每次更新操作后进行日志记录，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面的save条件来同步的，所以有的数据会在一段时间内只存在于内存中。</p>
</li>
<li><p><code>appendfsync no/always/everysec</code>：appendfsync 配置，no 表示等操作系统进行数据缓存同步到磁盘，always 表示每次更新操作后手动调用 fsync() 将数据写到磁盘， everysec 表示每秒同步一次。</p>
</br>
</br>

</li>
</ul>
<p>redis 运行在内存中但可持久化到磁盘，在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。内存数据库的一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，可以做很多内部复杂性很强的事情。<br></br><br><a href="https://www.vousmevoyez.pro/2019/09/05/redis2/" target="_blank" rel="noopener">下一篇：redis 基础命令</a></p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Sorted Set(有序集合)</title>
    <url>/2019/09/05/redis10/</url>
    <content><![CDATA[<h1 id="Redis-Sorted-Set-有序集合"><a href="#Redis-Sorted-Set-有序集合" class="headerlink" title="Redis Sorted Set(有序集合)"></a>Redis Sorted Set(有序集合)</h1></br>
redis Sorted Set 有序集合是 string 类型元素的集合，元素不允许重复。
</br>
有序集合中的每个元素都会关联一个数值型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。
</br>
有序集合的成员是唯一的（不可重复）,但分数(score)可以重复。
</br>
</br>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zadd key score1 value1 score2 value2 ...    <span class="comment">//往有序集合中添加一个或多个元素。score是数值型，支持整数、浮点数，支持负数。z代表sorted set。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例： </span></span><br><span class="line">zadd students <span class="number">1</span> zhangsan <span class="number">2</span> lisi <span class="number">3</span> wangwu    <span class="comment">//返回此次添加的元素个数。score只是附加信息，真正的元素还是value1，value2，......</span></span><br><span class="line"><span class="comment">//说明：hash、list、set、sorted set，在Reids2.4之前的版本中，1次只支持添加一个元素，不支持1次添加多个元素。</span></span><br><span class="line"></span><br><span class="line">zcard key                                   <span class="comment">//返回元素个数</span></span><br><span class="line"></span><br><span class="line">zcount key minScore maxScore                <span class="comment">//返回分数值在[minScore，maxScore]上的元素个数</span></span><br><span class="line"></span><br><span class="line">zlexcount key minValue maxValue             <span class="comment">//返回元素值在[minValue，maxValue]上的元素个数。</span></span><br><span class="line"><span class="comment">//不能直接用元素值，有3种写法：</span></span><br><span class="line"><span class="comment">//[value   表示包含此元素</span></span><br><span class="line"><span class="comment">//(value  表示不包含此元素</span></span><br><span class="line"><span class="comment">//- 表示第一个元素（包含），+ 表示最后一个元素（包含）</span></span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line">zadd set1 <span class="number">1</span> a <span class="number">2</span> b <span class="number">3</span> c <span class="number">4</span> d</span><br><span class="line">zlexcount set1 - +          <span class="comment">//返回总元素个数，4</span></span><br><span class="line">zlexcount set1 [a [b        <span class="comment">//2 。即[a,b]上元素个数</span></span><br><span class="line"><span class="function">zlexcount <span class="title">set1</span> <span class="params">(a [b        <span class="comment">//1。(a,b]</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">//不能缺省 [  或  (</span></span></span></span><br><span class="line"><span class="function"><span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">zrange key minIndex maxIndex [withscores]   <span class="comment">//返回索引在[minIndex，maxIndex]上的所有元素。</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">//索引从0开始，支持负数，-1表示倒数第一个元素，-2表示倒数第二个元素。</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">//withscores是可选参数，带上则还会显示分数，不带则只显示元素值。</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">zrangebyscore key minScore maxScore [withscores]    <span class="comment">//返回score在[minScore，maxScore]上的所有元素值。</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">//默认使用 [ ，闭区间。也可以显示指定为 [ 或 ( 。</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">//withscores可选，带上时会显示元素的score，不带上时不显示score。</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">//示例： </span></span></span></span><br><span class="line"><span class="function"><span class="params">zrangebyscore set1 [<span class="number">1</span> (<span class="number">2</span>                    <span class="comment">//获取score在[1,2)上的所有元素</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">zrank key elementValue                      <span class="comment">//返回该元素值的索引。默认按score进行升序排列。索引从0开始。</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">//以上3个命令都是按score升序排列的。下面的3个命令：</span></span></span></span><br><span class="line"><span class="function"><span class="params">zrevrange</span></span></span><br><span class="line"><span class="function"><span class="params">zrevrangebyscore</span></span></span><br><span class="line"><span class="function"><span class="params">zrevrank</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">//前缀加不是z，而是zrev。和之前的3个命令一一对应，用法完全相同，只不过是按score降序排列计算的。</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">zscore key elementValue                     <span class="comment">//返回该元素值对应的score值</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">zincrby key increment elementValue          <span class="comment">//increment是增量，将指定元素的score增加increment。increment支持负数，即减。</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">zrem key value1 value2 ...                  <span class="comment">//移除一个或多个元素</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">zremrangebyrank key startIndex endIndex     <span class="comment">//移除下标在[startIndex，endIndex]上的所有元素。zremrangebyrank即z  remove  range  by  rank</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">zremrangebyscore key minScore maxScore      <span class="comment">//移除score在[minScore，maxScore]上的所有元素</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">zremrangebylex key value1 value2            <span class="comment">//移除这2个元素值之间的所有元素。</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">//不能直接写元素值，可以用 - + 表示，或者在元素值前面加[  (</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">zscan key <span class="built_in">cursor</span> [match pattern] [count num]<span class="comment">//迭代</span></span></span></span><br></pre></td></tr></table></figure>
</br>
</br>
sorted set 也提供了计算交集、并集的命令，此处不再一一介绍。]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 常用命令</title>
    <url>/2019/09/05/redis11/</url>
    <content><![CDATA[<h1 id="Redis-常用命令"><a href="#Redis-常用命令" class="headerlink" title="Redis 常用命令"></a>Redis 常用命令</h1></br>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">auth password       <span class="comment">//验证密码</span></span><br><span class="line"></span><br><span class="line">echo message        <span class="comment">//打印文本</span></span><br><span class="line"></span><br><span class="line">ping                <span class="comment">//测试连接，ping一下Redis服务器，如果连接正常（已连接到Redis服务器）返回PONG。</span></span><br><span class="line"></span><br><span class="line">select dbIndex      <span class="comment">//选择当前使用的数据库，默认使用数据库0，下标，从0开始。</span></span><br><span class="line"></span><br><span class="line">quit                <span class="comment">//关闭当前连接，并退到上一级命令行</span></span><br><span class="line"></span><br><span class="line">time                <span class="comment">//获取服务器上的当前时间。</span></span><br><span class="line"><span class="comment">//有2个返回值，第一个是当前时间的时间戳（s），第二个是当前这一秒已经逝去的微秒数。</span></span><br><span class="line"><span class="comment">//1秒=10^3毫秒=10^6微秒。</span></span><br><span class="line"><span class="comment">//两者组合可显示微秒级的时间。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span> <span class="built_in">set</span> param value  <span class="comment">//设置配置参数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span> <span class="built_in">get</span> param    <span class="comment">//获取配置参数的值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span> rewrite      <span class="comment">//将本次连接中，这条命令之前，对配置的设置都同步到redis.conf文件中。</span></span><br><span class="line"><span class="comment">//默认对配置的设置、修改只在本次连接期间有效，并不会同步修改redis.conf文件。断开本次连接，会清除本次连接的配置设置，下次连接时，使用的是redis.conf文件中配置。</span></span><br><span class="line"><span class="comment">//比如：</span></span><br><span class="line"><span class="comment">//配置文件中的密码是abc，连接到redis服务器后</span></span><br><span class="line"><span class="built_in">config</span> <span class="built_in">set</span> requirepass <span class="number">123</span>  <span class="comment">//修改密码为123</span></span><br><span class="line"><span class="comment">//这次连接中，密码不再是abc，而是123。但这个修改并不会同步到redis.conf文件中，redis.conf文件中的密码仍是abc。下次连接时，使用密码123会提示密码错误，需要使用abc。</span></span><br><span class="line"><span class="comment">//有2种方式同步到redis.conf文件中：</span></span><br><span class="line"><span class="comment">//1. 直接在redis.conf文件中修改</span></span><br><span class="line"><span class="comment">//2. 连接到redis服务器后，在命令行修改，然后使用 config rewrite 命令同步到redis.conf中。</span></span><br><span class="line"> </span><br><span class="line">dbsize              <span class="comment">//返回当前数据库中，key的数量</span></span><br><span class="line"></span><br><span class="line">flushdb             <span class="comment">//清除当前数据库中所有的key，即清空当前数据库。flushdb即flush  db。</span></span><br><span class="line"></span><br><span class="line">flushall            <span class="comment">//清除所有数据库中的key，即清空所有数据库。flushall即flush  all。</span></span><br><span class="line"></span><br><span class="line">save                <span class="comment">//将redis数据库中的所有数据同步到.rdb文件中。redis数据库中的数据是常驻内存的，save命令将内存中的redis数据库数据同步写到数据库文件.rdb中。</span></span><br><span class="line"></span><br><span class="line">bgsave              <span class="comment">//同上，只不过bgsave是在后台异步保存。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">.rdb 文件是 redis 的数据库文件，rdb即 redis db。启动 redis 服务的时候，会从 .rdb 文件加载所有的数据库数据到内存。就是说数据库数据有 2 份，一份常驻内存，一份是持久化的磁盘文件。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">.rdb 文件也被称为 redis 数据库的备份文件。可以将一个 .rdb 文件放在redis安装目录下，作为这个  redis 服务器的数据库数据。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">client <span class="built_in">list</span>             <span class="comment">//列出所有的连接</span></span><br><span class="line"></span><br><span class="line">client kill ip:port     <span class="comment">//关闭某个连接。</span></span><br><span class="line"><span class="comment">//6379只是redis服务器、客户端程序通信使用的端口号。建立一个redis数据库连接，会单独使用一个端口号，一个redis客户端可以建立多个数据库连接，一个连接对应一个端口号，并不是使用6379。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shutdown</span> [save/nosave]  <span class="comment">//关闭redis服务器。会自动关闭与所有的redis客户端连接、以及与这些客户端建立的数据库连接，并同步数据集到rdb文件中。</span></span><br><span class="line"><span class="comment">//shutdown命令可带一个可选参数：是否将数据集同步到rdb文件中。save——同步，nosave——不同步。</span></span><br><span class="line"></span><br><span class="line">client kill ip:port     <span class="comment">//是关闭某个数据库连接，quit是关闭redis客户端（会自动关闭这个客户端建立的所有数据库连接），shutdown save是关闭redis服务器（会自动关闭这个redis服务器的所有数据库连接）。</span></span><br><span class="line"></span><br><span class="line">slaveof ip port         <span class="comment">//原本默认本身是主服务器，此句命令会将当前redis服务器作为某个服务器的从服务器。</span></span><br><span class="line"><span class="comment">//示例： </span></span><br><span class="line">slaveof <span class="number">127.23</span><span class="number">.23</span><span class="number">.35</span> <span class="number">6379</span>   <span class="comment">//把当前服务器作为127.23.23.35这台服务器的从服务器。</span></span><br><span class="line"><span class="comment">//变成从服务器后，会丢弃原来数据库的数据集，从主服务器复制、同步数据到从服务器。</span></span><br><span class="line"><span class="comment">//slave，意为奴隶、从属。</span></span><br><span class="line"></span><br><span class="line">sync                        <span class="comment">//从主服务器复制、同步数据集</span></span><br><span class="line"></span><br><span class="line">slave no one                </span><br><span class="line"><span class="comment">//这句命令是关闭这个从服务器的从主服务器复制数据的功能，使这个从服务器变成一个主服务器。使用的仍是作为从服务器时的数据集。</span></span><br><span class="line"><span class="comment">//当主服务器出问题、或者需要做其他用途的时候，可以把一台从服务器作为主服务器，再把其它的从服务器作为这个主服务器的从属，这样就不会影响服务器的运转。</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 事务</title>
    <url>/2019/09/05/redis12/</url>
    <content><![CDATA[<h1 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h1><p>redis 事务可以一次执行多个命令。</p>
</br>

<p>常用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">multi       //开起一个事务，标记一个事务块的开始，multi即multiple</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span>        //执行事务块内的命令</span><br><span class="line"></span><br><span class="line">discard     //取消事务</span><br></pre></td></tr></table></figure>

<p>使用步骤：</p>
<ol>
<li>先使用 multi 命令标记事务开始</li>
<li>将多个命令入队( queue ，队列)</li>
<li>使用 exec 命令执行事务</li>
</ol>
<a id="more"></a>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">multi                   //标记事务开始</span><br><span class="line"><span class="built_in">set</span> name <span class="string">"zhangsan"</span>     //依次输入多个命令。输入一条命令后会提示“QUEUED”，表示此条命令已入队</span><br><span class="line"><span class="built_in">set</span> age 20 </span><br><span class="line">get name </span><br><span class="line"><span class="built_in">exec</span>                    //执行事务，会依次执行事务块内的命令，依次显示执行结果。</span><br><span class="line">//<span class="built_in">exec</span>是执行事务，如果想取消事务，将<span class="built_in">exec</span>换为discard即可。</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6pmw8jc4pj30g60egq3t.jpg" alt=""></p>
</br>
</br>

<p>单个 redis 命令的执行是原子性的，但 redis 并没有在事务上增加任何维持原子性的机制，所以 redis 事务的执行不是原子性的。</p>
</br>

<p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p>
</br>

<p>比如执行事务时，第一条执行成功，第二条执行失败，此时并不会回滚之前的操作（此处指第一条、第二条命令），而是继续执行后面的命令。但会显示第二条的结果是Fail。</p>
</br>

<p>即事务中任意命令执行失败，其余的命令依然被执行。</p>
</br>

<p>在事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令队列中。</p>
<p>Redis2.6以后的版本，在服务器内置了Lua环境（Lua解释器），可以通过eval命令执行Lua脚本。</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 发布订阅</title>
    <url>/2019/09/05/redis13/</url>
    <content><![CDATA[<h1 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h1></br>
redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。
pub 即 publish ，推送。
sub 即 subscribe ，订阅。
</br>
订阅者订阅某个 channel（频道），发布者将消息发布到 redis 服务器， redis 服务器将消息推送给这个频道的订阅者。
channel 管道、通道、频道。
</br>
![订阅发布](https://tva1.sinaimg.cn/large/006y8mN6gy1g6pqnr02aoj30kt08z0tw.jpg)
</br>
redis 的 channel 是公共频道，谁都可以发布消息。
就像微信群、QQ群，谁都可以发送消息，群成员（订阅者）都会收到消息。
<a id="more"></a>
</br>
redis 的消息是在线即时消息，类似于广播，只有在线的订阅者（连接到 redis  服务器的订阅者），才会收到消息。
若当时不在线，并不会收到消息。后面登陆了（连接到服务器），服务器也不会推送之前（这个客户端未收到）的消息。服务器只推送一遍。
</br>
</br>

<hr>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p><strong>1.</strong> 启动一个客户端，连接到服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -a password</span><br></pre></td></tr></table></figure>
</br>
**2.** 订阅频道

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">subscribe channel1 channel2 ... <span class="comment">//可订阅一个或多个频道</span></span><br></pre></td></tr></table></figure>
<p>会显示订阅的频道的信息，一个频道显示 3 个条目:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;subscribe&quot;                 &#x2F;&#x2F;固定的值，表示这是一个订阅频道</span><br><span class="line">订阅的频道名</span><br><span class="line">一个int型的数，表示这个频道是当前客户端订阅的第几个频道</span><br></pre></td></tr></table></figure>
<p>订阅之后，当前命令提示符会阻塞，只能接收 redis 服务器推送的消息，不能再执行命令。所以我们再启动一个客户端推送消息。<br></br><br><strong>3.</strong> 在另一个 redis 客户端推送消息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">publish channel message         <span class="comment">//channel指定要推送消息到哪个频道，message是要推送的消息</span></span><br></pre></td></tr></table></figure>
<p>返回当前接收到消息的订阅者的数量。1表示只有一个订阅者收到了这条消息。</p>
<p>我们看到另一个客户端已接收到消息。一条消息显示3个项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“message”                   &#x2F;&#x2F;固定值，表示这是一条消息</span><br><span class="line">这条消息来自哪个订阅频道</span><br><span class="line">消息内容</span><br></pre></td></tr></table></figure>
</br>
</br>
redis 的订阅是临时订阅，只在本次连接期间有效。断开连接后，会清除这个客户端的订阅信息，即取消所有订阅的频道。
</br>
谁都可以是发布者，谁都可以发送消息。可以向任何频道发送消息。
</br>
</br>
## 相关命令

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">subscribe channel1 channel2 ...     <span class="comment">//订阅一个或多个频道</span></span><br><span class="line"></span><br><span class="line">unsubscribe channel1 channel2 ...   <span class="comment">//退订一个或多个频道。多了un</span></span><br><span class="line"></span><br><span class="line">psubscribe pattern1 pattern2 ...    <span class="comment">//多了一个p，即pattern，订阅该模式匹配的所有频道，可以有多个匹配模式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line">psubscribe tv       <span class="comment">//订阅频道tv</span></span><br><span class="line">psubscribe *<span class="built_in">home</span>    <span class="comment">//订阅所有以home结尾的频道</span></span><br><span class="line">psubscribe china*   <span class="comment">//订阅所有以china开头的频道</span></span><br><span class="line"></span><br><span class="line">punsubscribe pattern1 pattern2 ...  <span class="comment">//退订符合匹配的所有频道，可指定多个匹配模式，满足pattern1或者满足pattern2.....,，注意是或。</span></span><br><span class="line"></span><br><span class="line">publish channel message             <span class="comment">//推送消息到某个频道</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基础命令</title>
    <url>/2019/09/05/redis2/</url>
    <content><![CDATA[<h1 id="Redis-基础命令"><a href="#Redis-基础命令" class="headerlink" title="Redis 基础命令"></a>Redis 基础命令</h1></br>
## 服务器端命令

<ul>
<li><p>启动服务： <code>redis-server --service-start</code></p>
</li>
<li><p>关闭服务： <code>redis-server --service-stop</code></p>
</li>
<li><p>使用redis.conf配置开启服务： <code>redis-server /path/to/redis.conf</code></p>
</li>
</ul>
</br>
## 客户端命令
### 1、连接服务器：
`redis-cli -h 127.0.0.1 -p 6379 -a abcd`

<p>参数说明：</p>
<ul>
<li><p>redis-cli    即redis-cli.exe，我们通常缺省后缀.exe</p>
</li>
<li><p>-h    即host，服务器的IP地址</p>
</li>
<li><p>-p    即port，服务器的端口</p>
</li>
<li><p>-a    即auth，Redis服务器的密码</p>
<a id="more"></a>

</li>
</ul>
<p>如果连接远程的Redis服务器，必须指定服务器的IP地址。参数都可缺省，缺省时默认 -h 为 127.0.0.1 ，-p 为 6379 。<br></br><br>连接本地的Redis服务器： <code>redis-cli -a yourPassword</code></p>
<p>连接远程的Redis服务器： <code>redis-cli -h serverIP -a yourPassword</code><br></br><br>也可以之后再输入密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"></span><br><span class="line">auth yourPassword</span><br></pre></td></tr></table></figure>
</br>
### 2、密码操作
- 设置/修改密码： `config set requirepass newPassword`，修改密码后需要重新输入密码验证。Reids默认的数据类型是String，比如设置密码为123，会自动作为字符串“123”。

<ul>
<li>查看密码： <code>config get requirepass</code></li>
</ul>
</br>
也可以通过修改配置文件来实现：
</br>
![requirepass](https://tva1.sinaimg.cn/large/006y8mN6gy1g6opk9rkstj30u00uxwtl.jpg)
</br>
推荐使用修改配置文件的方式。
</br>
因为本次连接期间，对配置文件的修改（包括密码），只在本次连接期间有效，并不会同步到 redis.conf 中。

<p>断开连接后，下次连接时，使用的仍是配置文件中的参数（包括密码），之前命令行修改的配置参数失效。<br></br><br>redis 命令的关键字不区分大小写，比如以下2句命令等效：</p>
<pre><code>set name &quot;张三&quot; 
SET name &quot;张三&quot; </code></pre></br>
## 查看帮助

<ul>
<li><p>查看服务器端帮助： <code>redis-server --help</code></p>
</li>
<li><p>查看客户端帮助： <code>redis-cli --help</code></p>
</li>
</ul>
<blockquote>
<p>这2个命令不能在redis命令行中使用。</p>
</blockquote>
<ul>
<li>查看某个命令的说明： <code>help command</code> 。</li>
</ul>
<blockquote>
<p>该命令要在redis命令行下使用。</p>
</blockquote>
<p><a href="https://www.vousmevoyez.pro/2019/09/05/redis1/" target="_blank" rel="noopener">上一篇：redis 简介</a><br><a href="https://www.vousmevoyez.pro/2019/09/05/redis3/" target="_blank" rel="noopener">下一篇：redis 配置</a></p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 配置</title>
    <url>/2019/09/05/redis3/</url>
    <content><![CDATA[<h1 id="Redis-配置"><a href="#Redis-配置" class="headerlink" title="Redis 配置"></a>Redis 配置</h1><h2 id="redis-conf-中的部分参数说明"><a href="#redis-conf-中的部分参数说明" class="headerlink" title="redis.conf 中的部分参数说明"></a>redis.conf 中的部分参数说明</h2><blockquote>
<p>redis.conf 配置的是 redis 服务器。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>      <span class="comment">//设置redis服务器的ip地址</span></span><br><span class="line"></span><br><span class="line">port <span class="number">6379</span>           <span class="comment">//指定端口号</span></span><br><span class="line"></span><br><span class="line">timeout <span class="number">300</span>         <span class="comment">//当客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能。默认为0，需要修改。</span></span><br><span class="line"></span><br><span class="line">loglevel notice     <span class="comment">//指定日志记录级别，redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</span></span><br><span class="line"></span><br><span class="line">logfile <span class="built_in">stdout</span>      <span class="comment">//日志记录方式，需要修改为标准输出。默认为空串""。</span></span><br><span class="line"></span><br><span class="line">databases <span class="number">16</span>        <span class="comment">//设置数据库的数量</span></span><br><span class="line"></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span>          <span class="comment">//指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合使用，默认是3个。900s=15minutes</span></span><br><span class="line"></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>         <span class="comment">//300s=5minutes</span></span><br><span class="line"></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>       <span class="comment">//60s=1minute</span></span><br><span class="line"></span><br><span class="line">rdbcompression yes  <span class="comment">//指定存储至本地数据库时是否压缩数据，默认为 yes，redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</span></span><br><span class="line"></span><br><span class="line">dbfilename dump.rdb <span class="comment">//指定本地数据库文件名，默认值为 dump.rdb</span></span><br><span class="line"></span><br><span class="line">dir ./              <span class="comment">//指定本地数据库存放目录</span></span><br><span class="line"></span><br><span class="line">requirepass foobared<span class="comment">//设置 redis 连接密码，如果配置了连接密码，客户端在连接 redis 时需要提供密码，默认关闭</span></span><br><span class="line"></span><br><span class="line">maxclients <span class="number">128</span>      <span class="comment">//设置同一时间最大客户端连接数，默认是注释了的</span></span><br><span class="line"></span><br><span class="line">maxmemory <span class="number">536870912</span> <span class="comment">//指定 redis 最大内存限制，512M。默认是注释了的，默认单位字节。</span></span><br><span class="line"></span><br><span class="line">appendonly yes      <span class="comment">//指定是否在每次更新操作后进行日志记录，redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</span></span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span> <span class="comment">//指定日志文件名，默认为 appendonly.aof</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定日志更新条件，有3个值：always、everysec、no，默认使用everysec（其余2条是注释了的）</span></span><br><span class="line"><span class="meta"># appendfsync always<span class="comment">//表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）</span></span></span><br><span class="line">appendfsync everysec<span class="comment">//表示每秒同步一次（折中，默认值）</span></span><br><span class="line"><span class="meta"># appendfsync no    <span class="comment">//表示等操作系统进行数据缓存同步到磁盘（快）</span></span></span><br><span class="line"></span><br><span class="line">activerehashing yes <span class="comment">//指定是否激活重置哈希，默认为yes</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>redis 在启动时会把数据加载到内存中，达到最大内存后，redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区。</p>
<h2 id="命令行设置配置参数"><a href="#命令行设置配置参数" class="headerlink" title="命令行设置配置参数"></a>命令行设置配置参数</h2><p>设置配置参数： <code>CONFIG SET key value</code><br>查看配置参数： <code>CONFIG GET key</code><br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG SET timeout 300 &#x2F;&#x2F;设置timeout为300s</span><br><span class="line"></span><br><span class="line">CONFIG GET timeout     &#x2F;&#x2F;查看timeout的配置值</span><br><span class="line"></span><br><span class="line">CONFIG GET *           &#x2F;&#x2F;查看所有的配置参数</span><br></pre></td></tr></table></figure>


</br>
[上一篇：redis 简介](https://www.vousmevoyez.pro/2019/09/05/redis2/)
[下一篇：redis 配置](https://www.vousmevoyez.pro/2019/09/05/redis4/)]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis KEY键的操作</title>
    <url>/2019/09/05/redis4/</url>
    <content><![CDATA[<h1 id="Redis-KEY键的操作"><a href="#Redis-KEY键的操作" class="headerlink" title="Redis KEY键的操作"></a>Redis KEY键的操作</h1></br>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> key value       <span class="comment">//设置、修改值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">get</span> key             <span class="comment">//如果key不存在，返回nil，表示空。</span></span><br><span class="line"></span><br><span class="line">type key            <span class="comment">//返回key对应的value的数据类型</span></span><br><span class="line"></span><br><span class="line">rename key newKey   <span class="comment">//重命名key，即修改键的名称。当key和newKey重名时，或者key不存在时，会提示错误。如果newKey已存在，会覆盖原来的值。</span></span><br><span class="line"></span><br><span class="line">renamenx key newKey <span class="comment">//多了nx。返回一个整数。如果newKey不存在，则执行重命名，返回1；如果newKey已存在，不执行重命名，返回0。就是说newKey不存在时才执行。</span></span><br><span class="line"></span><br><span class="line">randomkey           <span class="comment">//从当前数据库中随机返回一个key</span></span><br><span class="line"></span><br><span class="line">keys  pattern       <span class="comment">//返回所有满足pattern的key</span></span><br><span class="line"></span><br><span class="line">keys person*        <span class="comment">//示例：假设当前数据库中有3个key——person1，person2，person3，则该命令会返回所有以person开头的key，即person1、person2、person3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exists</span> key          <span class="comment">//检测key是否存在，存在返回1，不存在返回0</span></span><br><span class="line"></span><br><span class="line">dump key            <span class="comment">//序列化指定的key，返回序列化得到的二进制数据。</span></span><br><span class="line"></span><br><span class="line">del  key            <span class="comment">//删除指定的键值对。若key存在，则删除key，并返回1；若key不存在，直接返回0.</span></span><br><span class="line"></span><br><span class="line">expire key seconds  <span class="comment">//设置key的过期时间，以秒为单位</span></span><br><span class="line"></span><br><span class="line">expire age <span class="number">60</span>       <span class="comment">//示例：60s后age过期，会自动删除age。</span></span><br><span class="line"></span><br><span class="line">expireat key timestamp              <span class="comment">//设置key的过期时间。多了at。timestamp是时间戳，到了timestamp指定的时间，key过期，自动删除key。时间戳以秒为单位。</span></span><br><span class="line"></span><br><span class="line">pexpire  key  milliseconds          <span class="comment">//设置key的过期时间，以毫秒为单位。多了前缀p</span></span><br><span class="line"></span><br><span class="line">pexpireat key milliseconds-timestamp<span class="comment">//设置key的过期时间，时间戳，以毫秒为单位。多了前缀p、后缀at。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">move</span> key db         <span class="comment">//将键值对移到指定的数据库，相当于剪切。返回db——当前使用的数据库的index。</span></span><br><span class="line"></span><br><span class="line">select db           <span class="comment">//Redis默认使用数据库0，也可以用显式指定当前使用的数据库。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="built_in">set</span> age <span class="number">10</span>      <span class="comment">//默认使用数据库0</span></span><br><span class="line"><span class="built_in">move</span> age <span class="number">1</span>      <span class="comment">//将age键值对移到数据库1中。返回1——表示数据库1</span></span><br><span class="line"><span class="built_in">exists</span> age      <span class="comment">//此时使用的仍是数据库0，返回0——表示当前数据库中不存在age</span></span><br><span class="line">select <span class="number">1</span>        <span class="comment">//选择（切换）到数据库1</span></span><br><span class="line"><span class="built_in">exists</span> age      <span class="comment">//返回1——表示存在age</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
</br>
</br>
![select](https://tva1.sinaimg.cn/large/006y8mN6gy1g6oqr11vylj30di0a6jtd.jpg)
</br>
端口号后面的 [1] 表示当前使用的是数据库 1 。使用数据库 0 时默认缺省。

<p>redis 中 key 、value 加不加引号均可，都默认作为 String 处理。</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 数据结构</title>
    <url>/2019/09/05/redis5/</url>
    <content><![CDATA[<h1 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h1></br>
redis 支持五种数据类型： string（字符串），hash（哈希），list（列表），set（集合）及 zset ( sorted set :有序集合)。
</br>
## string 字符串
</br>
示例： `set name "zhangsan"`

<p>key 、 value 都是 string 类型， key 、 value 引不引都行，习惯上 key 不加引号， value 随意。</p>
<p>string 是 redis 的基础数据类型。<br></br></p>
<h2 id="hash-哈希表-字典"><a href="#hash-哈希表-字典" class="headerlink" title="hash 哈希表/字典"></a>hash 哈希表/字典</h2></br>
redis hash 是一个 string 类型的 field 和 value 的映射表，一个 hash 可储存多个键值对。

<p>一个对象往往有多个属性（键值对形式）， hash 特别适合存储对象。</p>
<p>redis 中一个 hash 可以存储 2<sup>32</sup> - 1个 键值对（40多亿）。<br></br><br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hmset zhangsan name &quot;zhangsan&quot; age 12 gender male score 90</span><br></pre></td></tr></table></figure>
<p><code>hmset</code> : hm 即 hash multiple ，set 这里表示设置，不是集合。</p>
<p><code>zhangsan</code> : 即这张 hash 表的名称。 redis 是 key-value 数据库， zhangsan 就是 key ，后面的一堆属性看做一个整体（value）。</p>
<a id="more"></a>
</br>
## list 列表
</br>
redis 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素（字符串）到列表的头部（左边）或者尾部（右边）。

<p>一个列表最多可以包含 2<sup>32</sup> - 1 个元素 (40多亿)。<br></br><br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lpush students &quot;zhangsan&quot; &quot;lisi&quot; &quot;wangwu&quot;</span><br></pre></td></tr></table></figure>
<p><code>lpush</code> : list push ，往 list 中添加元素。</p>
<p><code>students</code> : 即这个列表的名称（key）。列表中的元素看做一个整体（value）。<br></br></p>
<h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h2></br>
redis set 是 string 类型的无序集合。集合成员是唯一的（不允许重复）。

<p>redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p>集合的最大成员数为 2<sup>32</sup> - 1 (40多亿)。<br></br><br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sadd mySet &quot;zhangsan&quot; &quot;lisi&quot; &quot;wangwu&quot;</span><br></pre></td></tr></table></figure>
<p><code>sadd</code> : set add ，往集合中添加元素。</p>
<p><code>mySet</code> : 即集合名称（key）。把集合中的所有元素作为一个整体（value）。<br></br></p>
<h2 id="sorted-set-有序集合"><a href="#sorted-set-有序集合" class="headerlink" title="sorted set 有序集合"></a>sorted set 有序集合</h2></br>
redis 有序集合和集合一样也是 string 类型元素的集合,且不允许出现重复的成员。

<p>但 sorted set 的每个元素都会关联一个 int 型或 double 型的数。 redis 正是通过这个数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员不允许重复，但分数(score)可以重复。</p>
<p>有序集合是通过哈希表实现的，添加，删除，查找的复杂度都是O(1)。</p>
<p>集合的最大成员数为 2<sup>32</sup> - 1 (40多亿)。<br></br><br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zadd sortedSet 2 &quot;zhangsan&quot; 2.9 &quot;lisi&quot; 1.3 &quot;wangwu&quot;</span><br></pre></td></tr></table></figure>
<p><code>zadd</code> : z 代表有序集合。</p>
<p><code>sortedSet</code> : 即有序集合的名称（key）。把有序集合中的所有元素（包括分数）看做一个整体（value）。</p>
<p><code>2 &quot;zhangsan&quot;</code> : 2 就是 “zhangsan” 的 score ，顺序就是根据 score 进行升序排列的。 score 可以是 int 、 double 型。</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis String(字符串)</title>
    <url>/2019/09/05/redis6/</url>
    <content><![CDATA[<h1 id="Redis-String-字符串"><a href="#Redis-String-字符串" class="headerlink" title="Redis String(字符串)"></a>Redis String(字符串)</h1></br>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">getset key newValue     <span class="comment">//给key设置value，并返回旧的value，如果没有旧的value，返回nil。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="built_in">set</span> age <span class="number">10</span>  </span><br><span class="line">getset age <span class="number">20</span>           <span class="comment">//age 的值被设置为20，并返回旧的值10</span></span><br><span class="line"></span><br><span class="line">getrange key start <span class="built_in">end</span>  <span class="comment">//获取value的部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="built_in">set</span> content <span class="string">"hello world!"</span> </span><br><span class="line">getrange content <span class="number">0</span> <span class="number">4</span>    <span class="comment">//返回content对应value的[0,4]上的字符，"hello"，下标</span></span><br><span class="line">getrange content <span class="number">0</span> <span class="number">-1</span>   <span class="comment">//支持负数索引，-1表示最后一个字符</span></span><br><span class="line"></span><br><span class="line">mget key1 key2 ......   <span class="comment">//mget即multiple get，同时获取多个key的value，若某个key不存在，该key返回nil</span></span><br><span class="line"></span><br><span class="line">setex key timeout value <span class="comment">//setex即set expire，给key设置timeout、value，若key已存在，会覆盖原来的timeout、value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line">setex age <span class="number">60</span> <span class="number">10</span>         <span class="comment">//设置age 60s后过期，value为10</span></span><br><span class="line"></span><br><span class="line">setnx key value         <span class="comment">//在 key 不存在时，为 key 设置value，设置成功返回1；若key已存在，不执行（不会替换原来的value），返回0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="built_in">set</span> age <span class="number">10</span>              <span class="comment">//若age已存在，会则覆盖value</span></span><br><span class="line">setnx age <span class="number">20</span>            <span class="comment">//age不存在时才设置，age已存在就不设置（不会覆盖原来的value）</span></span><br><span class="line"></span><br><span class="line">mset key1 value1 key2 value2 ......     <span class="comment">//mset即multiple  set。同时设置多个键值对。因为是set，所以若某个key已存在，会覆盖。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例： </span></span><br><span class="line">mset name <span class="string">"lisi"</span> age <span class="number">20</span> </span><br><span class="line"></span><br><span class="line">msetnx key1 value1 key2 value2 ......   <span class="comment">//msetnx即multiple setnx，当key不存在时才设置该key，已存在就不设置该key</span></span><br><span class="line"></span><br><span class="line">append key content      <span class="comment">//若key已存在，则在value末尾追加content；若key不存在，则为其设置值，此时相当于set key value。返回操作过后，value（新）的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line">append str <span class="string">"hello"</span>      <span class="comment">//之前str不存在，此句命令相当于set str "hello"</span></span><br><span class="line">append str <span class="string">" world!"</span>    <span class="comment">//之前str已存在，则在其末尾追加" world!"，现在str的值变为"hello world!"</span></span><br><span class="line"></span><br><span class="line">incr key                <span class="comment">//incr即increase，如果value是整数（可以是负整数），将value的值+1，并返回操作后的value。如果value不是整数，提示错误。如果key不存在，先将value初始化为0，再执行+1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="built_in">set</span> age <span class="number">10</span>              <span class="comment">//等价于set age "10"。</span></span><br><span class="line">incr age                <span class="comment">//value的值+1，变为11，并返回11。value是整数才会+1。</span></span><br><span class="line"><span class="built_in">get</span> age                 <span class="comment">//11</span></span><br><span class="line">incr price              <span class="comment">//之前price不存在，value会先初始化为0，再+1，返回1</span></span><br><span class="line"><span class="built_in">get</span> price               <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">incrby key amount       <span class="comment">//同上，只不过是+amout，不是+1。原来的value要是整数，amount也要是整数，否则提示错误。若key不存在，先初始化value为0。支持负整数（即减）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="built_in">set</span> age <span class="number">20</span> </span><br><span class="line">incrby age <span class="number">5</span>            <span class="comment">//+5</span></span><br><span class="line"><span class="built_in">get</span> age                 <span class="comment">//25</span></span><br><span class="line"></span><br><span class="line">incrbyfloat key amount  <span class="comment">//同上，只不过原来的value可以是浮点数，增量amount也可以是浮点数。当然，整数也行。支持负数（减）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="built_in">set</span> price <span class="number">2.3</span> </span><br><span class="line">incrbyfloat price <span class="number">1.5</span>     </span><br><span class="line"><span class="built_in">get</span> price               <span class="comment">//3.8</span></span><br><span class="line"></span><br><span class="line">decr key                <span class="comment">//同incr key只不过decr是减。decr即decrease。</span></span><br><span class="line"></span><br><span class="line">decrby key amount       <span class="comment">//同incrby  key  amount，只不过是减</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Hash(哈希表/字典)</title>
    <url>/2019/09/05/redis7/</url>
    <content><![CDATA[<h1 id="Redis-Hash-哈希表-字典"><a href="#Redis-Hash-哈希表-字典" class="headerlink" title="Redis Hash(哈希表/字典)"></a>Redis Hash(哈希表/字典)</h1></br>
redis hash 可储存多个键值对，适合储存对象的属性。
</br>
```c
hset key fieldName fileValue    //hset即hash set，set这里是设置的意思。往hash中添加一个字段（键值对）

<p>//示例：<br>hset score zhangsan 90          //score是hash的名称，zhangsan 90是一个键值对。若zhangsan这个字段名之前不存在，则添加成功返回1。<br>hset score lisi 85              //一个hash可储存多个键值对（40多亿）。<br>hset score lisi 100             //之前这个hash中已存在lisi这个字段名，会覆盖原来的字段值，返回0.</p>
<p>hsetnx key fieldName fieldValue //多了后缀nx，同上，只是如果这个hash中已存在fieldName，则不执行操作（不覆盖原来的值），此时返回0。即当这个hash中fieldName不存在时才添加字段。</p>
<p>hmset key fileName1 fieldValue1 fieldName2 fieldValue2 ……   //同时添加多个字段。hmset即hash multiple set，因为是set所以字段已存在时会覆盖原有的值。</p>
<p>hget key fieldName              //获取指定字段的值</p>
<p>hmget key fieldName1 fieldName2 ……  //同时获取一个或多个字段的值</p>
<p>hgetall key                     //获取所有字段的值，会同时显示fieldName、fieldValue。hgetall即hash get all。</p>
<p>hdel key fieldName1 fieldName2 …      //删除一个或多个字段</p>
<p>hexists key fieldName           //检查该字段是否已存在，已存在则返回1，该fieldName不存在或key不存在，则返回0</p>
<p>hlen key                        //获取hash中的字段（键值对）数量</p>
<p>hkeys  key                      //获取hash中所有的feildName</p>
<p>hvals key                       //获取hash中所有的fieldValue</p>
<p>hscan key cursor [match pattern] [count count]  //迭代hash中的键值对</p>
<p>hincrby key fieldName acount    //将指定字段的值增加acount。原来的字段值、acount都要是整数，否则提示错误。</p>
<p>//示例：<br>hincrby score lisi 5            //返回操作后的字段值，假如之前lisi的值是80，则返回85<br>hincrby score lisi -10          //acount支持负整数，即减。</p>
<p>hincrbyfloat  key fieldName acount  //同上，但是支持浮点数，就是说整数、浮点数都行。</p>
<p>```<br></br><br><strong>说明</strong>：</p>
<ul>
<li>没有 hincr 这个命令 (+1) ；</li>
<li>没有提供 hdecr 命令 (减) ；</li>
<li>都带有前缀 h 表示 hash 。</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis List(列表)</title>
    <url>/2019/09/05/redis8/</url>
    <content><![CDATA[<h1 id="Redis-List-列表"><a href="#Redis-List-列表" class="headerlink" title="Redis List(列表)"></a>Redis List(列表)</h1></br>
redis 列表是简单的字符串列表，列表是有序的，列表中的元素可以重复。

<p>可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>一个列表最多可以包含 2<sup>32</sup> - 1 个元素 (40多亿)。<br></br></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lpush key value1 value2 ......  <span class="comment">//往列表的头部（左边）推入一个或多个元素，lpush的l表示left。key是列表名称，把列表中的所有元素作为一个整体（value）。若key不存在，会自动创建。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line">lpush students <span class="string">"zhangsan"</span> <span class="string">"lisi"</span> <span class="string">"wangwu"</span>   <span class="comment">//返回操作后列表中的总元素个数</span></span><br><span class="line"><span class="comment">//先在列表头部添加“zhangsan”，再在列表头部添加“lisi”，接着在列表头部添加“wangwu”，最后列表的前三个元素依次是"wangwu"、“lisi”、“zhangsan”。</span></span><br><span class="line"></span><br><span class="line">lpushx key value1 value2 ...... <span class="comment">//同上，只是key不存在时，不执行操作（不会自动创建）。要key已存在且key时list类型时才会添加元素。</span></span><br><span class="line"></span><br><span class="line">lpop key                        <span class="comment">//弹出列表的第一个元素，会从列表中移除并返回该元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//l表示left，列表的头部。</span></span><br><span class="line"></span><br><span class="line">rpush key value1 value2 ......  <span class="comment">//在列表尾部推入1个或多个元素。</span></span><br><span class="line"></span><br><span class="line">rpushx key value1 value2 ...... <span class="comment">//尾部，key已存在时才会推入。</span></span><br><span class="line"></span><br><span class="line">rpop                            <span class="comment">//弹出列表的最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//r表示right，列表的尾部。</span></span><br><span class="line"><span class="comment">//上面的l、r命令是一一对应的。</span></span><br><span class="line"></span><br><span class="line">rpoplpush sourceKey destKey     <span class="comment">//弹出sourceKey的最后一个元素，并在destKey的头部推入元素，即剪切。返回该元素。rpoplpush即对sourceKey执行rpop，对destKey执行lpush。</span></span><br><span class="line"></span><br><span class="line">blpop key1 key2 ... timeout     <span class="comment">//弹出一个或多个的列表的第一个元素，如果列表为空会阻塞列表直到等待超时或发现可弹出元素为止。blpop即bind  lpop。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例： </span></span><br><span class="line">blpop students <span class="number">60</span>               <span class="comment">//60s</span></span><br><span class="line"></span><br><span class="line">brpop key1 key2 ...... timeout</span><br><span class="line"></span><br><span class="line">brpoplpush sourceKey destKey timeout</span><br><span class="line"></span><br><span class="line">llen key                        <span class="comment">//返回列表中的元素个数</span></span><br><span class="line"></span><br><span class="line">lset key index value            <span class="comment">//给指定索引处的元素设置值（即修改元素值）</span></span><br><span class="line"></span><br><span class="line">lindex key index                <span class="comment">//根据index索引元素，返回指定位置上的元素</span></span><br><span class="line"></span><br><span class="line">lrange key start <span class="built_in">end</span>            <span class="comment">//返回[start，end]区间上的所有元素。start、end是索引，比如0  -1  就是返回所有元素。</span></span><br><span class="line"></span><br><span class="line">ltrim key start <span class="built_in">end</span>             <span class="comment">//修剪列表，只保留[start，end]区间上的元素，其余元素会被删除。</span></span><br><span class="line"></span><br><span class="line">linsert key before/after value1 value2  <span class="comment">//在元素value1之前/之后插入元素value2。value2是要插入的元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例： </span></span><br><span class="line">linsert student before <span class="string">"lisi"</span> <span class="string">"zhangsan"</span><span class="comment">//在lisi的前面插入zhangsan</span></span><br><span class="line"><span class="comment">//插入成功，返回操作后列表的总长度；若value1不存在，返回-1；若key不存在或key是一个空的list，则返回0.</span></span><br><span class="line"></span><br><span class="line">lrem key count value            <span class="comment">//移除列表中值为value的所有元素。lrem即list remove。count是一个整数，表示要删除的个数、搜索方向。</span></span><br><span class="line"><span class="comment">//count&gt;0：从表头向表尾搜索，移除count个值为value的元素</span></span><br><span class="line"><span class="comment">//count&lt;0：从表尾向表头搜索，移除count的绝对值个值为value的元素</span></span><br><span class="line"><span class="comment">//count=0：移除表中所有的值为value的元素。要遍历列表，从哪边开始结果、速度都是一样的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例： </span></span><br><span class="line">lrem scores <span class="number">0</span> <span class="number">90</span>                <span class="comment">//移除列表中所有的90</span></span><br></pre></td></tr></table></figure>
</br>
以上几个命令中，l 表示 list 。 index 从 0 开始，支持负数索引，index 要是已存在的

<p>redis 的区间，都是闭区间，[ start ，end ] ，两边都包含。</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Set(集合)</title>
    <url>/2019/09/05/redis9/</url>
    <content><![CDATA[<h1 id="Redis-Set-集合"><a href="#Redis-Set-集合" class="headerlink" title="Redis Set(集合)"></a>Redis Set(集合)</h1></br>
redis 的 Set 是 String 类型的无序集合，元素不允许重复。

<p>redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p>集合中最大的元素数为 2<sup>32</sup> - 1 (40多亿)。<br></br></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sadd key value1 value2 ...  <span class="comment">//向集合中添加一个或多个元素。sadd即set add，key是集合的名称。返回此次添加的元素个数。</span></span><br><span class="line"></span><br><span class="line">scard key                   <span class="comment">//返回集合的元素个数</span></span><br><span class="line"></span><br><span class="line">smembers key                <span class="comment">//返回集合中所有的元素</span></span><br><span class="line"></span><br><span class="line">sismember key elementValue  <span class="comment">//判断该集合中是否有elementValue这个元素。有返回1，没有或者key不存在则返回0.</span></span><br><span class="line"></span><br><span class="line">spop key                    <span class="comment">//随机移除并返回集合中的一个元素</span></span><br><span class="line"></span><br><span class="line">srandmember key             <span class="comment">//随机返回集合中的一个元素，并不移除该元素。srandmember即set random  member.</span></span><br><span class="line"><span class="comment">//可带一个可选参数：</span></span><br><span class="line">srandmember key count       <span class="comment">//count是一个整数，指定返回的元素个数。</span></span><br><span class="line"><span class="comment">//count&gt;0：随机返回count个元素，这些元素互不相同。随机确定一个返回的元素后，再从剩余的元素中随机。</span></span><br><span class="line"><span class="comment">//count&lt;0：随机返回count的绝对值个元素，这些元素可能相同。每次都是从整个集合中随机一个。</span></span><br><span class="line"><span class="comment">//count的绝对值大于等于集合的元素个数时，返回集合中所有的元素。</span></span><br><span class="line"></span><br><span class="line">srem key value1 value2 ...  <span class="comment">//移除集合中的一个或多个元素，若集合中没有该元素，会忽略该元素。</span></span><br><span class="line"></span><br><span class="line">smove sourceKey destKey elementValue        <span class="comment">//将元素从一个集合移动到另一个集合。（剪切）</span></span><br><span class="line"></span><br><span class="line">sscan key <span class="built_in">cursor</span> match pattern count num    <span class="comment">//迭代集合中的元素。cursor指定对每元素的操作。</span></span><br><span class="line"><span class="comment">//2个可选参数：</span></span><br><span class="line"><span class="comment">//match pattern     指定配置模式，只迭代符合pattern的元素</span></span><br><span class="line"><span class="comment">//count num         指定要迭代的元素个数</span></span><br><span class="line"></span><br><span class="line">sinter key1 key2 ...        <span class="comment">//返回这些集合的交集</span></span><br><span class="line"></span><br><span class="line">sinterstore destKey key1 key2 ...           <span class="comment">//多了store，求key1、key2.....这些集合的交集，并将交集中的元素存储在destKey集合中，返回交集中的元素个数</span></span><br><span class="line"><span class="comment">//相同用法的还有：</span></span><br><span class="line"><span class="comment">//sunion    并集</span></span><br><span class="line"><span class="comment">//sdiff     差集</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>cJson学习笔记</title>
    <url>/2019/08/02/cJson/</url>
    <content><![CDATA[<h1 id="cJSON的使用方法"><a href="#cJSON的使用方法" class="headerlink" title="cJSON的使用方法"></a>cJSON的使用方法</h1><h2 id="一-JSON格式简述"><a href="#一-JSON格式简述" class="headerlink" title="一.JSON格式简述"></a>一.JSON格式简述</h2><blockquote>
<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写，同时也易于机器解析和生成。它基于JavaScript（Standard ECMA-262 3rd Edition - December 1999）的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使JSON成为理想的数据交换语言。（来自“开源中国”资料）。</p>
</blockquote>
<p>cJSON从名字可知，整个项目都是以极标准的C来写的，意思说，可以跨各种平台使用了。cJSON是一个超轻巧，携带方便，单文件，简单的可以作为ANSI-C标准的JSON解析器。</p>
 <a id="more"></a>

<p>cJSON 开源项目位置：<a href="https://github.com/DaveGamble/cJSON" target="_blank" rel="noopener">DaveGamble/cJSON</a><br>更加详细的解释和示例请查看<a href="http://www.json.org/" target="_blank" rel="noopener">主页</a>。</p>
<p>cJSON，目前来说，就只有两个文件，一个cJSON.c 一个cJSON.h文件。使用的时候，自己创建好一个main.c文件后，将头文件include进去。<br>如果是在linux pc上，请使用以下命令进行编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc  *.c  cJSON.c    -lm</span><br></pre></td></tr></table></figure>
<p>记得编译时末尾链接libm库。<br></br></p>
<h2 id="二-JSON结构体"><a href="#二-JSON结构体" class="headerlink" title="二.JSON结构体"></a>二.JSON结构体</h2><p>熟悉使用cJSON库函数可从cJSON结构体入手，cJSON结构体如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">cJSON</span> *<span class="title">next</span>,*<span class="title">prev</span>;</span>   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">cJSON</span> *<span class="title">child</span>;</span>   </span><br><span class="line">    <span class="keyword">int</span>     type;   </span><br><span class="line">    <span class="keyword">char</span>    *valuestring;   </span><br><span class="line">    <span class="keyword">int</span>     valueint;  </span><br><span class="line">    <span class="keyword">double</span>  valuedouble;   </span><br><span class="line">    <span class="keyword">char</span>    *<span class="built_in">string</span>;   </span><br><span class="line">&#125; cJSON;</span><br></pre></td></tr></table></figure>


<p><strong>几点说明</strong></p>
<ol>
<li>cJOSN结构体为一个双向列表，并可通过child指针访问下一层。</li>
<li>type变量决定数据项类型（键的类型），数据项可以是字符串可以是整形，也可以是浮点型。如果是整形值的话可从valueint，如果是浮点型的话可从valuedouble取出，以此类推。</li>
<li>string可理解为节点的名称，综合此处的第2点可理解为“键”的名称。</li>
</ol>
<p>cJSON作为Json格式的解析库，其主要功能无非就是构建和解析Json格式了，用途就是一端将要发送的数据已cjson形式封装，然后发送，另一端收到此数据后，还是按cjson形式解析，就得到想要的数据了。<br></br></p>
<h2 id="三-封装成json形式"><a href="#三-封装成json形式" class="headerlink" title="三.封装成json形式"></a>三.封装成json形式</h2><p>接下来直接通过几个例子代码，一一解析。</p>
<p>第一，创建json数据串。这数据串，可能是对象，也可能是数组，也可能是它们的各种组合，其中再加上一些键值对。有一点要先说明：它们的组合，符合父子继承格式－－这也是json数据串的特点。<br></br></p>
<p><strong>&lt;1&gt;</strong> 创建一个对象，并向这个对象里添加字符串和整型键值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cJSON.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cJSON * usr;</span><br><span class="line">        cJSON *arry;</span><br><span class="line"> </span><br><span class="line">        usr=cJSON_CreateObject();   <span class="comment">//创建根数据对象</span></span><br><span class="line">        cJSON_AddStringToObject(usr,<span class="string">"name"</span>,<span class="string">"fengxin"</span>);  <span class="comment">//加入键值，加字符串</span></span><br><span class="line">        cJSON_AddStringToObject(usr,<span class="string">"passwd"</span>,<span class="string">"123"</span>);</span><br><span class="line">        cJSON_AddNumberToObject(usr,<span class="string">"num"</span>,<span class="number">1</span>);  <span class="comment">//加整数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> *out = cJSON_Print(usr);   <span class="comment">//将json形式打印成正常字符串形式</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,out);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 释放内存  </span></span><br><span class="line">        cJSON_Delete(usr);  </span><br><span class="line">        <span class="built_in">free</span>(out); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;:	&quot;fengxin&quot;,</span><br><span class="line">	&quot;passwd&quot;:	&quot;123&quot;,</span><br><span class="line">	&quot;num&quot;:	1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>若干说明</strong></p>
<ol>
<li>cJSON_CreateObject函数可创建一个根数据项，之后便可向该根数据项中添加string或int等内容,返回的是一个 cJSON的指针，注意，在这个指针用完了以后，需要手工调用 cJSON_Delete(root); 进行内存回收。</li>
<li>cJSON_AddNumberToObject向节点中添加子节点，例如此处添加name节点，节点值为字符串”fengxin”</li>
<li>需要注意的是  json 格式的数据，虽然也是一个字符串的样子，但这个时候还是无法当成普通的字符串进行使用，需要调用 cJSON_PrintUnformatted(root) 或者 cJSON_Print(root);来将json对象转换成普通的字符串，并且都是以该json对象的根为基点。两个API的区别即是：一个是没有格式的：也就是转换出的字符串中间不会有”\n” “\t”之类的东西存在，而cJSON_Print(root);打印出来是人看起来很舒服的格式。</li>
<li>因为函数内部封装有malloc函数，所以使用free函数释放被out占用的内存空间</br>
</br>

</li>
</ol>
<p><strong>&lt;2&gt;</strong> 创建一个数组，并向数组添加一个字符串和一个数字：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_js</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cJSON *root, *js_body;</span><br><span class="line">    root = cJSON_CreateArray();</span><br><span class="line">    cJSON_AddItemToArray(root, cJSON_CreateString(<span class="string">"Hello world"</span>));</span><br><span class="line">    cJSON_AddItemToArray(root, cJSON_CreateNumber(<span class="number">10</span>)); </span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//      char *s = cJSON_Print(root);</span></span><br><span class="line">        <span class="keyword">char</span> *s = cJSON_PrintUnformatted(root);</span><br><span class="line">        <span class="keyword">if</span>(s)&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">" %s \n"</span>,s);</span><br><span class="line">            <span class="built_in">free</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">        cJSON_Delete(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    create_js();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;Hello world&quot;,10]</span><br></pre></td></tr></table></figure>
</br>
</br>

<p><strong>&lt;3&gt;</strong>对象里面包括一个数组，数组里面包括对象，对象里面再添加一个字符串和一个数字：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_js</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cJSON *root, *js_body, *js_list;</span><br><span class="line">    root = cJSON_CreateObject();</span><br><span class="line">    cJSON_AddItemToObject(root,<span class="string">"body"</span>, js_body = cJSON_CreateArray());</span><br><span class="line">    cJSON_AddItemToArray(js_body, js_list = cJSON_CreateObject());</span><br><span class="line">    cJSON_AddStringToObject(js_list,<span class="string">"name"</span>,<span class="string">"fengxin"</span>);</span><br><span class="line">    cJSON_AddNumberToObject(js_list,<span class="string">"status"</span>,<span class="number">100</span>);</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//        char *s = cJSON_Print(root);</span></span><br><span class="line">        <span class="keyword">char</span> *s = cJSON_PrintUnformatted(root);</span><br><span class="line">        <span class="keyword">if</span>(s)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %s \n"</span>,s);</span><br><span class="line">            <span class="built_in">free</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">        cJSON_Delete(root);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    create_js();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;body&quot;:[&#123;&quot;name&quot;:&quot;fengxin&quot;,&quot;status&quot;:100&#125;]&#125;</span><br></pre></td></tr></table></figure>
</br>
</br>

<p><strong>&lt;4&gt;</strong>其他组合就依次类推，只要搞清楚父子关系即可。随便嵌套随便玩。不再贴了。<br></br></p>
<h2 id="四-解析json得到数据"><a href="#四-解析json得到数据" class="headerlink" title="四.解析json得到数据"></a>四.解析json得到数据</h2><p>解析数据包的过程和组装数据包的过程相反<br><strong>处理流程：</strong></p>
<p><strong>&lt;1&gt;</strong> 先将普通的json串处理成json对象，也就是所谓的创建json root的过程，只有一行代码即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cJSON *root;</span><br><span class="line">root = cJSON_Parse(js_string);</span><br></pre></td></tr></table></figure>

<p><strong>&lt;2&gt;</strong> 开始拿关键字，但如果关键字还有父层或者祖层，那就需要先从父层开拿，所谓剥洋葱是也！先说没有父层的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">out=&#123;\<span class="string">"name\":\"fengxin\",\"passwd\":\"123\",\"num\":1&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="string">#include&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="string">#include&lt;string.h&gt;</span></span><br><span class="line"><span class="string">#include"</span>cJSON.h<span class="string">"</span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    cJSON *json,*json_name,*json_passwd,*json_num;</span></span><br><span class="line"><span class="string">    char* out="</span>&#123;\<span class="string">"name\":\"fengxin\",\"passwd\":\"123\",\"num\":1&#125;"</span>;</span><br><span class="line"> </span><br><span class="line">    json = cJSON_Parse(out); <span class="comment">//解析成json形式</span></span><br><span class="line">    json_name = cJSON_GetObjectItem( json , <span class="string">"name"</span> );  <span class="comment">//获取键值内容</span></span><br><span class="line">    json_passwd = cJSON_GetObjectItem( json , <span class="string">"passwd"</span> );</span><br><span class="line">    json_num = cJSON_GetObjectItem( json , <span class="string">"num"</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name:%s,passwd:%s,num:%d\n"</span>,json_name-&gt;valuestring,json_passwd-&gt;valuestring,json_num-&gt;valueint);</span><br><span class="line"> </span><br><span class="line">    cJSON_Delete(json);  <span class="comment">//释放内存 </span></span><br><span class="line">    <span class="built_in">free</span>(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>显示结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name:fengxin,passwd:123,num:1</span><br></pre></td></tr></table></figure>
<p>需要注意的是： 上面的type 已经在cJSON.h里面定义好了，有自己的意义。如果是在严格的场所，应该先判定该 item的type，然后再考虑去拿值。而如果有父层的话，无非就是接着向下拿就是了。</p>
</br>
**<3>** 处理这串数据：

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">out=&#123;\<span class="string">"list\":&#123;\"name\":\"xiao hong\",\"age\":10&#125;,\"other\":&#123;\"name\":\"hua hua\"&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">char *s = "</span>&#123;\<span class="string">"list\":&#123;\"name\":\"xiao hong\",\"age\":10&#125;,\"other\":&#123;\"name\":\"hua hua\"&#125;&#125;"</span>;</span><br><span class="line"></span><br><span class="line">cJSON *root = cJSON_Parse(s);</span><br><span class="line"><span class="keyword">if</span>(!root) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get root faild !\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> cJSON *js_list = cJSON_GetObjectItem(root, <span class="string">"list"</span>);</span><br><span class="line"><span class="keyword">if</span>(!js_list) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"no list!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"list type is %d\n"</span>,js_list-&gt;type);</span><br><span class="line"></span><br><span class="line">cJSON *name = cJSON_GetObjectItem(js_list, <span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">if</span>(!name) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No name !\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"name type is %d\n"</span>,name-&gt;type);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"name is %s\n"</span>,name-&gt;valuestring);</span><br><span class="line"></span><br><span class="line">cJSON *age = cJSON_GetObjectItem(js_list, <span class="string">"age"</span>);</span><br><span class="line"><span class="keyword">if</span>(!age) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"no age!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"age type is %d\n"</span>, age-&gt;type);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"age is %d\n"</span>,age-&gt;valueint);</span><br><span class="line"></span><br><span class="line">cJSON *js_other = cJSON_GetObjectItem(root, <span class="string">"other"</span>);</span><br><span class="line"><span class="keyword">if</span>(!js_other) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"no list!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"list type is %d\n"</span>,js_other-&gt;type);</span><br><span class="line"></span><br><span class="line">cJSON *js_name = cJSON_GetObjectItem(js_other, <span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">if</span>(!js_name) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No name !\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"name type is %d\n"</span>,js_name-&gt;type);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"name is %s\n"</span>,js_name-&gt;valuestring);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(root) &#123;</span><br><span class="line">    cJSON_Delete(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>打印结果:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list type is 6</span><br><span class="line">name type is 4</span><br><span class="line">name is xiao hong</span><br><span class="line">age type is 3</span><br><span class="line">age is 10</span><br><span class="line">list type is 6</span><br><span class="line">name type is 4</span><br><span class="line">name is hua hua</span><br></pre></td></tr></table></figure>
<p>所谓子子孙孙无穷尽也，按照上面那个方法推下去即可。<br></br><br><strong>&lt;4&gt;</strong> json里数组怎么取？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;\<span class="string">"list\":[\"name1\",\"name2\"]&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main(int argc, char **argv)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">char *s = "</span>&#123;\<span class="string">"list\":[\"name1\",\"name2\"]&#125;"</span>;</span><br><span class="line">cJSON *root = cJSON_Parse(s);</span><br><span class="line"><span class="keyword">if</span>(!root) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get root faild !\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cJSON *js_list = cJSON_GetObjectItem(root, <span class="string">"list"</span>);</span><br><span class="line"><span class="keyword">if</span>(!js_list)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"no list!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> array_size = cJSON_GetArraySize(js_list);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"array size is %d\n"</span>,array_size);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">cJSON *item;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; array_size; i++) &#123;</span><br><span class="line">    item = cJSON_GetArrayItem(js_list, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"item type is %d\n"</span>,item-&gt;type);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,item-&gt;valuestring);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(root)</span><br><span class="line">    cJSON_Delete(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>
**<5>** 如果json数组里面又搞了对象怎么办？ 

<p>不怕搞对象，就怕这样搞对象？ 无他，就是稍微复杂了一点，全是体力活儿：</p>
<ol>
<li>既然是数组里面，那肯定要先测量数组的大小，然后根据大小循环拿；</li>
<li>拿到一个数组项，然后把这个项先转化成普通的json字符串，也就是 char *s 能接受的。</li>
<li>再次将这个json字符串，转化成一个json对象。</li>
<li>按照拿普通对象中的东西那样开干就行了。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;\<span class="string">"list\":[&#123;\"name\":\"xiao hong\",\"age\":10&#125;,&#123;\"name\":\"hua hua\",\"age\":11&#125;]&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">list 是一个数组，数组里面有两个对象，那么代码如下</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main(int argc, char **argv)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">char *s = "</span>&#123;\<span class="string">"list\":[&#123;\"name\":\"xiao hong\",\"age\":10&#125;,&#123;\"name\":\"hua hua\",\"age\":11&#125;]&#125;"</span>;</span><br><span class="line">cJSON *root = cJSON_Parse(s);</span><br><span class="line"><span class="keyword">if</span>(!root) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get root faild !\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cJSON *js_list = cJSON_GetObjectItem(root, <span class="string">"list"</span>);</span><br><span class="line"><span class="keyword">if</span>(!js_list)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"no list!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> array_size = cJSON_GetArraySize(js_list);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"array size is %d\n"</span>,array_size);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">cJSON *item,*it, *js_name, *js_age;</span><br><span class="line"><span class="keyword">char</span> *p  = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; array_size; i++) &#123;</span><br><span class="line">    item = cJSON_GetArrayItem(js_list, i);</span><br><span class="line">    <span class="keyword">if</span>(!item) &#123;</span><br><span class="line">        <span class="comment">//TODO...</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = cJSON_PrintUnformatted(item);</span><br><span class="line">    it = cJSON_Parse(p);</span><br><span class="line">    <span class="keyword">if</span>(!it)</span><br><span class="line">        <span class="keyword">continue</span> ;</span><br><span class="line">    js_name = cJSON_GetObjectItem(it, <span class="string">"name"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name is %s\n"</span>,js_name-&gt;valuestring);</span><br><span class="line">    js_age = cJSON_GetObjectItem(it, <span class="string">"age"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age is %d\n"</span>,js_age-&gt;valueint);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(root)</span><br><span class="line">    cJSON_Delete(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT协议</title>
    <url>/2019/07/12/MQTT%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="MQTT协议"><a href="#MQTT协议" class="headerlink" title="MQTT协议"></a>MQTT协议</h1><h2 id="MQTT协议的概念"><a href="#MQTT协议的概念" class="headerlink" title="MQTT协议的概念"></a>MQTT协议的概念</h2><blockquote>
<p>MQTT协议，全称 <em>Message Queue Telemetry Transport消息队列遥测传输协议</em> ，是一种基于发布/订阅的轻量级通讯协议<br>适用于条件较差的网络环境，如：网络延迟高、带宽低、通信讯号不稳定等情况。</p>
</blockquote>
<h2 id="MQTT协议的特点"><a href="#MQTT协议的特点" class="headerlink" title="MQTT协议的特点"></a>MQTT协议的特点</h2><ul>
<li><p>构建于TCP/IP协议之上</p>
<blockquote>
<p>TCP/IP参考模型可分为四层：应用层、传输层、网络层、链路层。TCP、UDP协议均属于传输层，MQTT运行与TCP之上，属于应用层协议，只要支持TCP/IP协议栈的地方都可应用MQTT。</p>
</blockquote>
<a id="more"></a></li>
<li><p>基于C-S架构的消息发布/订阅</p>
<blockquote>
<p>提供一对多的消息发布，作为客户端之间的中间介质，解除应用程序的耦合。</p>
</blockquote>
</li>
<li><p>对负载内容屏蔽的消息传输</p>
</li>
<li><p>使用TCP连接进行数据推送</p>
</li>
<li><p>三种消息发布QoS</p>
<blockquote>
<ul>
<li>QoS 0：至多一次。服务器只推送1次，至于客户端是否收到，收到的消息是否正确，数据是否有所丢失，都不管。</li>
<li>QoS 1：至少一次。客户端收到服务器的推送后要回复一个PUBACK告诉服务器已收到，否则服务器会认为Client未收到推送，隔一段时间后重新发送，直到对方回复PUBACK。</li>
<li>QoS 2：只发一次。保证数据包到达目的地，且不会出现重复。服务器发送数据包，客户端接收后回复PUBREC（收到发布消息）报文，服务器存储PUBREC中的报文标识符，发送PUBREL（释放发布消息）。</li>
</ul>
</blockquote>
<p> <img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4x7jsup5wj30se13m0vy.jpg" alt=""></p>
</li>
</ul>
<h2 id="MQTT协议规范"><a href="#MQTT协议规范" class="headerlink" title="MQTT协议规范"></a>MQTT协议规范</h2><h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p><strong>表1</strong> 报文类型值</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">值</th>
<th align="left">流向</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CONNECT</td>
<td align="left">1</td>
<td align="left">C -&gt; S</td>
<td align="left">客户端连接请求</td>
</tr>
<tr>
<td align="left">CONNACK</td>
<td align="left">2</td>
<td align="left">S -&gt; C</td>
<td align="left">服务端确认连接</td>
</tr>
<tr>
<td align="left">PUBLISH</td>
<td align="left">3</td>
<td align="left">C &lt;-&gt; S</td>
<td align="left">发布消息</td>
</tr>
<tr>
<td align="left">PUBACK</td>
<td align="left">4</td>
<td align="left">C &lt;-&gt; S</td>
<td align="left">QoS1消息确认</td>
</tr>
<tr>
<td align="left">PUBREC</td>
<td align="left">5</td>
<td align="left">C &lt;-&gt; S</td>
<td align="left">QoS2收到消息（保证传输step1）</td>
</tr>
<tr>
<td align="left">PUBREL</td>
<td align="left">6</td>
<td align="left">C &lt;-&gt; S</td>
<td align="left">QoS2释放消息（保证传输step2）</td>
</tr>
<tr>
<td align="left">PUBCOMP</td>
<td align="left">7</td>
<td align="left">C &lt;-&gt; S</td>
<td align="left">QoS2完成消息（保证传输step3）</td>
</tr>
<tr>
<td align="left">SUBSCRIBE</td>
<td align="left">8</td>
<td align="left">C -&gt; S</td>
<td align="left">订阅消息</td>
</tr>
<tr>
<td align="left">SUBACK</td>
<td align="left">9</td>
<td align="left">S -&gt; C</td>
<td align="left">订阅确认</td>
</tr>
<tr>
<td align="left">UNSUBSCRIBE</td>
<td align="left">10</td>
<td align="left">C -&gt; S</td>
<td align="left">取消订阅</td>
</tr>
<tr>
<td align="left">UNSUBACK</td>
<td align="left">11</td>
<td align="left">S -&gt; C</td>
<td align="left">取消订阅确认</td>
</tr>
<tr>
<td align="left">PINGREQ</td>
<td align="left">12</td>
<td align="left">C -&gt; S</td>
<td align="left">连接保活请求</td>
</tr>
<tr>
<td align="left">PINGRESP</td>
<td align="left">13</td>
<td align="left">S -&gt; C</td>
<td align="left">保活回应</td>
</tr>
<tr>
<td align="left">DISCONNECT</td>
<td align="left">14</td>
<td align="left">C -&gt; S</td>
<td align="left">断开连接</td>
</tr>
</tbody></table>
<p><strong>注：</strong>值为0和15表示保留</p>
<h3 id="MQTT控制报文"><a href="#MQTT控制报文" class="headerlink" title="MQTT控制报文"></a>MQTT控制报文</h3><p>MQ控制报文由三部分组成：固定报头+可变报头+有效载荷</p>
<p><strong>表2：</strong>报文格式</p>
<table>
<thead>
<tr>
<th>↓</th>
<th>↓</th>
</tr>
</thead>
<tbody><tr>
<td>固定报头</td>
<td>所有控制报文都包含</td>
</tr>
<tr>
<td>可变报头</td>
<td>部分报文包含</td>
</tr>
<tr>
<td>有效载荷</td>
<td>部分报文包含</td>
</tr>
</tbody></table>
<h4 id="固定报头"><a href="#固定报头" class="headerlink" title="固定报头"></a>固定报头</h4><p><strong>表3：</strong> 固定报头格式</p>
<table>
    <tr>
        <td>Bit</td> 
        <td>7</td>
        <td>6</td> 
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
   </tr>
    <tr>
        <td>Byte 1</td>
        <td colspan="4">MQTT控制报文类型</td>
        <td colspan="4">控制报文类型的标志位</td>
    </tr>
    <tr>
        <td>Byte 2</td>
        <td colspan="8" align="center">剩余长度</td>
    </tr>
</table>

<p><strong>注：</strong>固定报头Byte1的高四位是表1中消息类型的值，以二进制数表示。低四位是报文类型的标志位。</p>
<h4 id="可变报头"><a href="#可变报头" class="headerlink" title="可变报头"></a>可变报头</h4><p>可变报头在固定报头和负载之间。可变报头的报文标识符字段存在于在多个类型的报文里。</p>
<blockquote>
<p>很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是QoS &gt; 0时的PUBLISH，PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCRIBE，UNSUBACK。SUBSCRIBE，UNSUBSCRIBE和PUBLISH（QoS大于0）控制报文必须包含一个非零的16位报文标识符。客户端每次发送一个新的这些类型的报文时都必须分配一个当前未使用的报文标识符。如果一个客户端要重发这个特殊的控制报文，在随后重发那个报文时，它必须使用相同的标识符。当客户端处理完这个报文对应的确认后，这个报文标识符就释放可重用。发送一个QoS 0的PUBLISH报文时，相同的条件也适用于服务端。</p>
</blockquote>
<p>即uuid，标识会话，当标识符一致时表示在同一会话中。</p>
<h4 id="有效载荷"><a href="#有效载荷" class="headerlink" title="有效载荷"></a>有效载荷</h4><p>-&gt;Body.</p>
<h1 id="Wireshark抓包"><a href="#Wireshark抓包" class="headerlink" title="Wireshark抓包"></a>Wireshark抓包</h1><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4x7qw0kdfj31ht0u0avb.jpg" alt=""><br>从报文可看到，Client与MQ Server首先做三次TCP握手连接，建立连接成功后，Client给MQ服务器发送connect登录请求，服务器回应一个ACK表示登录成功。协议消息中可看出，登录请求报文的QoS=0，即只推送一次消息。</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4x7rqvccfj31hk0u0hbz.jpg" alt=""><br>客户端向MQ服务器发布消息，发送publish报文，可从报文信息中看到，QoS=1，即至少发送1次，服务器收到后回复Publish Ack确认报文，否则一段时间后发布方没收到确认将进行重传。另外，报文中可看出MQTT固定报文头0x32 = 00110010,3表示消息类型为Publish（表1能查到）。此处Publish报文发布新Portal消息，AC程序主动发送的无感知报文。</p>
<hr>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4x7sfyqb9j31fw0u0x07.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4x7st93sjj31lx0u0tq9.jpg" alt=""></p>
<p>订阅请求报文Subscribe Request。上图1报文为客户端向MQ服务器请求订阅YS保活Topic消息。图2为二级AC上线后的订阅请求，可看到MQTT报文有效载荷包含二级AC的MAC地址。收到消息后对端回复Subscribe Ack，QoS=1。</p>
]]></content>
      <tags>
        <tag>protocol</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习笔记</title>
    <url>/2019/05/27/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">'XXX'</span></span><br><span class="line">git config --global user.email <span class="string">'XXX'</span></span><br></pre></td></tr></table></figure>

<h1 id="创建本地库"><a href="#创建本地库" class="headerlink" title="创建本地库"></a>创建本地库</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkidir learngit     //自定义文件夹</span><br><span class="line"><span class="built_in">cd</span> learngit</span><br><span class="line">touch test.md       //创建test.md文件</span><br><span class="line"><span class="built_in">pwd</span>                 //显示当前目录</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h1 id="常用CRT"><a href="#常用CRT" class="headerlink" title="常用CRT"></a>常用CRT</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init                    //初始化代码仓库</span><br><span class="line">git add learngit.txt        //把所有要提交的文件修改放到暂存区</span><br><span class="line">git commit -m <span class="string">'add a file'</span>  //把暂存区的所有内容提交到当前分支</span><br><span class="line">git status                  //查看工作区状态</span><br><span class="line">git diff                    //查看文件修改内容</span><br><span class="line">git <span class="built_in">log</span>                     //查看提交历史</span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline    //单行显示</span><br><span class="line">git reset --hard HEAD^      //回退到上一个版本，其中（HEAD^^(上上版本),HEAD~100(往上100个版本)）</span><br><span class="line">commit id                   //(版本号) 可回到指定版本</span><br><span class="line">git reflog                  //查看历史命令</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中说明<br>工作区（Working Directory）<br>版本库（Repository） #.git<br>stage(index) 暂存区<br>master Git自动创建的分支<br>HEAD 指针</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff HEAD -- &lt;file&gt;     //查看工作区和版本库里最新版本的区别</span><br><span class="line">git checkout -- &lt;file&gt;      //用版本库的版本替换工作区的版本，无论是工作区的修改还是删除，都可以<span class="string">'一键还原'</span></span><br><span class="line">git reset HEAD &lt;file&gt;       //把暂存区的修改撤销掉，重新放回工作区。</span><br><span class="line">git rm &lt;file&gt;               //删除文件，若文件已提交到版本库，不用担心误删，但是只能恢复文件到最新版本</span><br></pre></td></tr></table></figure>

<h1 id="创建SSH-Key，建立本地Git仓库和GitHub仓库之间的传输的秘钥"><a href="#创建SSH-Key，建立本地Git仓库和GitHub仓库之间的传输的秘钥" class="headerlink" title="创建SSH Key，建立本地Git仓库和GitHub仓库之间的传输的秘钥"></a>创建SSH Key，建立本地Git仓库和GitHub仓库之间的传输的秘钥</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//创建SSH Key</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">'your_email'</span></span><br><span class="line">//关联本地仓库，远程库的名字为origin   </span><br><span class="line">git remote add origin git@github.com:username/repostery.git </span><br><span class="line">//第一次把当前分支master推送到远程</span><br><span class="line">//-u参数不但推送，而且将本地的分支和远程的分支关联起来</span><br><span class="line">git push -u origin master</span><br><span class="line">//把当前分支master推送到远程</span><br><span class="line">git push origin master</span><br><span class="line">//从远程库克隆一个到本地库</span><br><span class="line">git <span class="built_in">clone</span> git@github.com:username/repostery.git</span><br></pre></td></tr></table></figure>

<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b dev         //创建并切换分支</span><br><span class="line"><span class="comment">#相当于git branch dev 和git checkout dev </span></span><br><span class="line">git branch                  //查看当前分支，当前分支前有个*号</span><br><span class="line">git branch &lt;name&gt;           //创建分支</span><br><span class="line">git checkout &lt;name&gt;         //切换分支</span><br><span class="line">git merge &lt;name&gt;            //合并某个分支到当前分支</span><br><span class="line">git branch -d &lt;name&gt;        //删除分支</span><br><span class="line">git <span class="built_in">log</span> --graph             //查看分支合并图</span><br><span class="line">/* 禁用Fast forward合并dev分支*/</span><br><span class="line">git merge --no-ff -m <span class="string">'message'</span> dev</span><br><span class="line">git stash                   //隐藏当前工作现场，等恢复后继续工作</span><br><span class="line">git stash list              //查看stash记录</span><br><span class="line">git stash apply             //仅恢复现场，不删除stash内容</span><br><span class="line">git stash drop              //删除stash内容</span><br><span class="line">git stash pop               //恢复现场的同时删除stash内容</span><br><span class="line">git branch -D &lt;name&gt;        //强行删除某个未合并的分支</span><br><span class="line"><span class="comment">#开发新feature最好新建一个分支</span></span><br><span class="line">git remote                  //查看远程仓库</span><br><span class="line">git remote -v               //查看远程库详细信息</span><br><span class="line">git pull                    //抓取远程提交</span><br><span class="line">/* 在本地创建和远程分支对应的分支*/</span><br><span class="line">git checkout -b branch-name origin/branch-name</span><br><span class="line">/* 建立本地分支和远程分支的关联*/</span><br><span class="line">git branch --<span class="built_in">set</span>-upstream branch-name origin/branch-name</span><br></pre></td></tr></table></figure>
<h1 id="其他—标签"><a href="#其他—标签" class="headerlink" title="其他—标签"></a>其他—标签</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag v1.0                    //给当前分支最新的commit打标签</span><br><span class="line">/* -a指定标签名，-m指定说明文字*/</span><br><span class="line">git tag -a v0.1 -m <span class="string">'version 0.1 released'</span> 3628164</span><br><span class="line">git tag -s &lt;tagname&gt; -m <span class="string">'blabla'</span>//可以用PGP签名标签</span><br><span class="line">git tag                         //查看所有标签</span><br><span class="line">git show v1.0                   //查看标签信息</span><br><span class="line">git tag -d v0.1                 //删除标签</span><br><span class="line">git push origin &lt;tagname&gt;       //推送某个标签到远程</span><br><span class="line">git push origin --tags          //推送所有尚未推送的本地标签</span><br></pre></td></tr></table></figure>
<h1 id="其他—出错解决方案"><a href="#其他—出错解决方案" class="headerlink" title="其他—出错解决方案"></a>其他—出错解决方案</h1><h2 id="1-git报错：’fatal-remote-origin-already-exists’怎么解决？"><a href="#1-git报错：’fatal-remote-origin-already-exists’怎么解决？" class="headerlink" title="1. git报错：’fatal:remote origin already exists’怎么解决？"></a>1. git报错：’fatal:remote origin already exists’怎么解决？</h2><p>只要两步：</p>
<p>1、先删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure>
<p>2、再次执行添加就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin XXX</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="2-如何删除GIT远程仓库项目的所有内容，重新提交所有内容"><a href="#2-如何删除GIT远程仓库项目的所有内容，重新提交所有内容" class="headerlink" title="2. 如何删除GIT远程仓库项目的所有内容，重新提交所有内容"></a>2. 如何删除GIT远程仓库项目的所有内容，重新提交所有内容</h2><blockquote>
<p>如果我们上传了一个项目到 <strong>git</strong> 并已经 <strong>commit</strong> 和 <strong>push</strong> 了所有内容，但是忘记搞 <strong>gitignore</strong> 文件，导致一些不想加入版本控制的文件，如IDE配置文件，编译文件，部署文件等，现在不知道怎么办了？<br>试一试如下命令：<br>首先配置好你的 <strong>.gitignore</strong> 文件，然后</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm -r --cache .</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"gitignore working"</span></span><br></pre></td></tr></table></figure>

<h2 id="3-git取消本地修改"><a href="#3-git取消本地修改" class="headerlink" title="3. git取消本地修改"></a>3. git取消本地修改</h2><blockquote>
<p>如果在修改时发现修改错误，而要放弃本地修改时</p>
</blockquote>
<h3 id="1-gt-当未使用-git-add-缓存代码时。"><a href="#1-gt-当未使用-git-add-缓存代码时。" class="headerlink" title="1-&gt;当未使用 git add 缓存代码时。"></a>1-&gt;当未使用 <strong>git add</strong> 缓存代码时。</h3><p>可以使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -- filepathname //比如: git checkout -- readme.md</span><br></pre></td></tr></table></figure>
<p>不要忘记中间的 “–” ，不写就成了新增分支了！！<br>放弃所有的文件修改可以使用 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure>
<p>此命令用来放弃掉所有还没有加入到缓存区（就是 <strong>git add</strong> 命令）的修改：内容修改与整个文件删除。但是此命令不会删除掉刚新建的文件。因为刚新建的文件还没已有加入到 <strong>git</strong> 的管理系统中。所以对于 <strong>git</strong> 是未知的。自己手动删除就好了。</p>
<h3 id="2-gt-已经使用了-git-add-缓存了代码"><a href="#2-gt-已经使用了-git-add-缓存了代码" class="headerlink" title="2-&gt;已经使用了 git add 缓存了代码"></a>2-&gt;已经使用了 <strong>git add</strong> 缓存了代码</h3><p>可以使用  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD filepathname //比如: git reset HEAD readme.md</span><br></pre></td></tr></table></figure>
<p>来放弃指定文件的缓存，放弃所有的缓存可以使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD .</span><br></pre></td></tr></table></figure>
<p>此命令用来清除 <strong>git</strong> 对于文件修改的缓存。相当于撤销 <strong>git add</strong> 命令所在的工作。在使用本命令后，本地的修改并不会消失，而是回到了1的状态。继续用1中的操作，就可以放弃本地的修改。</p>
<h3 id="3-gt-已经用-git-commit-提交了代码。"><a href="#3-gt-已经用-git-commit-提交了代码。" class="headerlink" title="3-&gt;已经用 git commit 提交了代码。"></a>3-&gt;已经用 <strong>git commit</strong> 提交了代码。</h3><p>可以使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>
<p>来回退到上一次commit的状态。此命令可以用来回退到任意版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard  commitid</span><br></pre></td></tr></table></figure>
<p>你可以使用 <strong>git log</strong> 命令来查看git的提交历史。<strong>git log</strong> 的输出如下,之一这里可以看到第一行就是 <strong>commitid</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit cf0d692e982d8e372a07aaa6901c395eec73e356 (HEAD -&gt; master)</span><br><span class="line">Author: toyflivver &lt;2440659688@qq.com&gt;</span><br><span class="line">Date: Thu Sep 28 14:07:14 2017 +0800</span><br><span class="line">多余的空行</span><br><span class="line">commit 14aa4d7ad4ac6fba59b4b8261d32e478e8cc99ff</span><br><span class="line">Author: toyflivver &lt;2440659688@qq.com&gt;</span><br><span class="line">Date: Thu Sep 28 14:06:44 2017 +0800</span><br><span class="line">正常的代码</span><br><span class="line">commit da3a95c84b6a92934ee30b6728e258bcda75f276</span><br><span class="line">Author: toyflivver &lt;2440659688@qq.com&gt;</span><br><span class="line">Date: Thu Sep 28 13:58:12 2017 +0800</span><br><span class="line">qbf</span><br><span class="line">commit 267466352079296520320991a75321485224d6c6</span><br><span class="line">Author: toyflivver &lt;2440659688@qq.com&gt;</span><br><span class="line">Date: Thu Sep 28 13:40:09 2017 +0800</span><br><span class="line">qbf</span><br></pre></td></tr></table></figure>
<p>可以看出现在的状态在 <strong>commitid</strong> 为 cf0d692e982d8e372a07aaa6901c395eec73e356 的提交上（有 HEAD -&gt; master 标记）。</p>
<h2 id="4-删除文件夹下的-所有-svn或者-git文件夹信息"><a href="#4-删除文件夹下的-所有-svn或者-git文件夹信息" class="headerlink" title="4. 删除文件夹下的 所有.svn或者.git文件夹信息"></a>4. 删除文件夹下的 所有.svn或者.git文件夹信息</h2><p>两步：</p>
<ol>
<li><p>cd到该文件夹</p>
</li>
<li><p>删除管理文件</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//删除文件夹下的所有 .svn 文件</span><br><span class="line">find . -name <span class="string">".svn"</span> | xargs rm -Rf</span><br><span class="line">//删除文件夹下的所有 .git 文件</span><br><span class="line">find . -name <span class="string">".git"</span> | xargs rm -Rf</span><br></pre></td></tr></table></figure>

<h2 id="5-git-clone-反复需要输入用户名密码"><a href="#5-git-clone-反复需要输入用户名密码" class="headerlink" title="5. git clone 反复需要输入用户名密码"></a>5. git clone 反复需要输入用户名密码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>tools</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake学习笔记(一)</title>
    <url>/2019/05/24/cmake1/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<ul>
<li>最大的Qt4程序群(KDE4)采用cmake作为构建系统</li>
<li>Qt4的python绑定(pyside)采用了cmake作为构建系统</li>
<li>开源的图像处理库 opencv 采用cmake 作为构建系统</li>
<li>…</li>
</ul>
<p>看来不学习一下cmake是不行了，一点一点来吧，找个最简单的C程序，慢慢复杂化，试试看：</p>
<table>
<thead>
<tr>
<th align="center">example</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">例子1</td>
<td align="left">单个源文件 main.c</td>
</tr>
<tr>
<td align="center">例子2</td>
<td align="left">==&gt;分解成多个 main.c hello.h hello.c</td>
</tr>
<tr>
<td align="center">例子3</td>
<td align="left">==&gt;先生成一个静态库，链接该库</td>
</tr>
<tr>
<td align="center">例子4</td>
<td align="left">==&gt;将源文件放置到不同的目录</td>
</tr>
<tr>
<td align="center">例子5</td>
<td align="left">==&gt;控制生成的程序和库所在的目录</td>
</tr>
<tr>
<td align="center">例子6</td>
<td align="left">==&gt;使用动态库而不是静态库</td>
</tr>
</tbody></table>
<a id="more"></a>
<h1 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h1><p>一个经典的C程序，如何用cmake来进行构建程序呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!/n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写一个 CMakeList.txt 文件(可看做cmake的工程文件)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line"><span class="built_in">set</span>(SRC_LIST main.c)</span><br><span class="line">add_executable(hello $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>
<p>然后，建立一个任意目录（比如本目录下创建一个build子目录），在该build目录下调用cmake</p>
<blockquote>
<p>注意：为了简单起见，我们从一开始就采用cmake的 out-of-source 方式来构建（即生成中间产物与源代码分离），并始终坚持这种方法，这也就是此处为什么单独创建一个目录，然后在该目录下执行 cmake 的原因</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake .. -G<span class="string">"NMake Makefiles"</span></span><br><span class="line">nmake</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake .. -G<span class="string">"MinGW Makefiles"</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>即可生成可执行程序 hello(.exe)</p>
<p>目录结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+</span><br><span class="line">| </span><br><span class="line">+--- main.c</span><br><span class="line">+--- CMakeList.txt</span><br><span class="line">|</span><br><span class="line">&#x2F;--+ build&#x2F;</span><br><span class="line">   |</span><br><span class="line">   +--- hello.exe</span><br></pre></td></tr></table></figure>

<p>cmake 真的不太好用哈，使用cmake的过程，本身也就是一个编程的过程，只有多练才行。</p>
<p>我们先看看：前面提到的这些都是什么呢？</p>
<h2 id="CMakeList-txt"><a href="#CMakeList-txt" class="headerlink" title="CMakeList.txt"></a>CMakeList.txt</h2><p>第一行<strong>project</strong>不是强制性的，但最好始终都加上。这一行会引入两个变量</p>
<ul>
<li>HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR</li>
</ul>
<p>同时，cmake自动定义了两个等价的变量</p>
<ul>
<li>PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR</li>
</ul>
<p>因为是out-of-source方式构建，所以我们要时刻区分这两个变量对应的目录<br>可以通过<strong>message</strong>来输出变量的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">message(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>set</strong> 命令用来设置变量<br><strong>add_exectuable</strong> 告诉工程生成一个可执行文件。<br><strong>add_library</strong> 则告诉生成一个库文件。</p>
<ul>
<li>注意：CMakeList.txt 文件中，命令名字是不区分大小写的，而参数和变量是大小写相关的。</li>
</ul>
<h2 id="cmake命令"><a href="#cmake命令" class="headerlink" title="cmake命令"></a>cmake命令</h2><p>cmake 命令后跟一个路径(..)，用来指出 CMakeList.txt 所在的位置。</p>
<p>由于系统中可能有多套构建环境，我们可以通过-G来制定生成哪种工程文件，通过 cmake -h 可得到详细信息。</p>
<p>要显示执行构建过程中详细的信息(比如为了得到更详细的出错信息)，可以在CMakeList.txt内加入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SET( CMAKE_VERBOSE_MAKEFILE on )</span><br></pre></td></tr></table></figure>
<p>或者执行make时</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make VERBOSE=1</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> VERBOSE=1</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>

<h1 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h1><p>一个源文件的例子一似乎没什么意思，拆成3个文件再试试看：</p>
<ul>
<li>hello.h 头文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DBZHANG_HELLO_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBZHANG_HELLO_</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//DBZHANG_HELLO_</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>hello.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"Hello %s!/n"</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>main.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hello(<span class="string">"World"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后准备好CMakeList.txt 文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line"><span class="built_in">set</span>(SRC_LIST main.c hello.c)</span><br><span class="line">add_executable(hello $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>
<p>执行cmake的过程同上，目录结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+</span><br><span class="line">| </span><br><span class="line">+--- main.c</span><br><span class="line">+--- hello.h</span><br><span class="line">+--- hello.c</span><br><span class="line">+--- CMakeList.txt</span><br><span class="line">|</span><br><span class="line">&#x2F;--+ build&#x2F;</span><br><span class="line">   |</span><br><span class="line">   +--- hello.exe</span><br></pre></td></tr></table></figure>

<p>例子很简单，没什么可说的。</p>
<h1 id="例子三"><a href="#例子三" class="headerlink" title="例子三"></a>例子三</h1><p>接前面的例子，我们将 hello.c 生成一个库，然后再使用会怎么样？<br>改写一下前面的CMakeList.txt文件试试：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line"><span class="built_in">set</span>(LIB_SRC hello.c)</span><br><span class="line"><span class="built_in">set</span>(APP_SRC main.c)</span><br><span class="line">add_library(libhello $&#123;LIB_SRC&#125;)</span><br><span class="line">add_executable(hello $&#123;APP_SRC&#125;)</span><br><span class="line">target_link_libraries(hello libhello)</span><br></pre></td></tr></table></figure>
<p>和前面相比，我们添加了一个新的目标 libhello，并将其链接进hello程序<br>然后想前面一样，运行cmake，得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+</span><br><span class="line">| </span><br><span class="line">+--- main.c</span><br><span class="line">+--- hello.h</span><br><span class="line">+--- hello.c</span><br><span class="line">+--- CMakeList.txt</span><br><span class="line">|</span><br><span class="line">&#x2F;--+ build&#x2F;</span><br><span class="line">   |</span><br><span class="line">   +--- hello.exe</span><br><span class="line">   +--- libhello.lib</span><br></pre></td></tr></table></figure>

<p>里面有一点不爽，对不？</p>
<ul>
<li>因为我的可执行程序(add_executable)占据了 hello 这个名字，所以 add_library 就不能使用这个名字了</li>
<li>然后，我们去了个libhello 的名字，这将导致生成的库为 libhello.lib(或 liblibhello.a)，很不爽</li>
<li>想生成 hello.lib(或libhello.a) 怎么办?</li>
</ul>
<p>添加一行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">set_target_properties(libhello PROPERTIES OUTPUT_NAME <span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure>
<p>就可以了</p>
<h1 id="例子四"><a href="#例子四" class="headerlink" title="例子四"></a>例子四</h1><p>在前面，我们成功地使用了库，可是源代码放在同一个路径下，还是不太正规，怎么办呢？分开放呗<br>我们期待是这样一种结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+</span><br><span class="line">|</span><br><span class="line">+--- CMakeList.txt</span><br><span class="line">+--+ src&#x2F;</span><br><span class="line">|  |</span><br><span class="line">|  +--- main.c</span><br><span class="line">|  &#x2F;--- CMakeList.txt</span><br><span class="line">|</span><br><span class="line">+--+ libhello&#x2F;</span><br><span class="line">|  |</span><br><span class="line">|  +--- hello.h</span><br><span class="line">|  +--- hello.c</span><br><span class="line">|  &#x2F;--- CMakeList.txt</span><br><span class="line">|</span><br><span class="line">&#x2F;--+ build&#x2F;</span><br></pre></td></tr></table></figure>
<p>哇，现在需要3个CMakeList.txt 文件了，每个源文件目录都需要一个，还好,每一个都不是太复杂</p>
<ul>
<li><p>顶层的CMakeList.txt 文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line">add_subdirectory(src)</span><br><span class="line">add_subdirectory(libhello)</span><br></pre></td></tr></table></figure>
</li>
<li><p>src 中的 CMakeList.txt 文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/libhello)</span><br><span class="line"><span class="built_in">set</span>(APP_SRC main.c)</span><br><span class="line">add_executable(hello $&#123;APP_SRC&#125;)</span><br><span class="line">target_link_libraries(hello libhello)</span><br></pre></td></tr></table></figure>
</li>
<li><p>libhello 中的 CMakeList.txt 文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(LIB_SRC hello.c)</span><br><span class="line">add_library(libhello $&#123;LIB_SRC&#125;)</span><br><span class="line">set_target_properties(libhello PROPERTIES OUTPUT_NAME <span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>恩，和前面一样，建立一个build目录，在其内运行cmake，然后可以得到</p>
<ul>
<li>build/src/hello.exe</li>
<li>build/libhello/hello.lib</li>
</ul>
<p>回头看看，这次多了点什么，顶层的 CMakeList.txt 文件中使用 add_subdirectory 告诉cmake去子目录寻找新的CMakeList.txt 子文件<br>在 src 的 CMakeList.txt 文件中，新增加了include_directories，用来指明头文件所在的路径。</p>
<h1 id="例子五"><a href="#例子五" class="headerlink" title="例子五"></a>例子五</h1><p>前面还是有一点不爽：如果想让可执行文件在 bin 目录，库文件在 lib 目录怎么办？</p>
<p>就像下面显示的一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ build&#x2F;</span><br><span class="line">|</span><br><span class="line">+--+ bin&#x2F;</span><br><span class="line">|  |</span><br><span class="line">|  &#x2F;--- hello.exe</span><br><span class="line">|</span><br><span class="line">&#x2F;--+ lib&#x2F;</span><br><span class="line">   |</span><br><span class="line">   &#x2F;--- hello.lib</span><br></pre></td></tr></table></figure>

<ul>
<li>一种办法：修改顶级的 CMakeList.txt 文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line">add_subdirectory(src bin)</span><br><span class="line">add_subdirectory(libhello lib)</span><br></pre></td></tr></table></figure>
<p>不是build中的目录默认和源代码中结构一样么，我们可以指定其对应的目录在build中的名字。<br>这样一来：build/src 就成了 build/bin 了，可是除了 hello.exe，中间产物也进来了。还不是我们最想要的。<br>另一种方法：不修改顶级的文件，修改其他两个文件</p>
<ul>
<li>src/CMakeList.txt 文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/libhello)</span><br><span class="line">#link_directories($&#123;PROJECT_BINARY_DIR&#125;/lib)</span><br><span class="line"><span class="built_in">set</span>(APP_SRC main.c)</span><br><span class="line"><span class="built_in">set</span>(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)</span><br><span class="line">add_executable(hello $&#123;APP_SRC&#125;)</span><br><span class="line">target_link_libraries(hello libhello)</span><br></pre></td></tr></table></figure>
<ul>
<li>libhello/CMakeList.txt 文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(LIB_SRC hello.c)</span><br><span class="line">add_library(libhello $&#123;LIB_SRC&#125;)</span><br><span class="line"><span class="built_in">set</span>(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib)</span><br><span class="line">set_target_properties(libhello PROPERTIES OUTPUT_NAME <span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="例子六"><a href="#例子六" class="headerlink" title="例子六"></a>例子六</h1><p>在例子三至五中，我们始终用的静态库，那么用动态库应该更酷一点吧。 试着写一下<br>如果不考虑windows下，这个例子应该是很简单的，只需要在上个例子的 libhello/CMakeList.txt 文件中的add_library命令中加入一个SHARED参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add_library(libhello SHARED $&#123;LIB_SRC&#125;)</span><br></pre></td></tr></table></figure>
<p>可是，我们既然用cmake了，还是兼顾不同的平台吧，于是，事情有点复杂：</p>
<ul>
<li>修改 hello.h 文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DBZHANG_HELLO_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBZHANG_HELLO_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _WIN32</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> LIBHELLO_BUILD</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> LIBHELLO_API __declspec(dllexport)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> LIBHELLO_API __declspec(dllimport)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> LIBHELLO_API</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function">LIBHELLO_API <span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//DBZHANG_HELLO_</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改 libhello/CMakeList.txt 文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(LIB_SRC hello.c)</span><br><span class="line">add_definitions(<span class="string">"-DLIBHELLO_BUILD"</span>)</span><br><span class="line">add_library(libhello SHARED $&#123;LIB_SRC&#125;)</span><br><span class="line"><span class="built_in">set</span>(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib)</span><br><span class="line">set_target_properties(libhello PROPERTIES OUTPUT_NAME <span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure>
<p>恩，剩下来的工作就和原来一样了。</p>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>cmake</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>微信机器人业务报警项目的实现</title>
    <url>/2019/03/01/wx_robot/</url>
    <content><![CDATA[<h1 id="任务背景↓"><a href="#任务背景↓" class="headerlink" title="任务背景↓"></a>任务背景↓</h1><p>目前商城的业务报警多采用短信报警方式, 目前短信报警效果做得并不好.经常出现无人关注的情况,造成了成本浪费,也影响了正常的业务报警,计划对这块进行优化</p>
<h2 id="任务需求↓"><a href="#任务需求↓" class="headerlink" title="任务需求↓"></a>任务需求↓</h2><h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>目前的想法是做一个微信机器人用做报警<br><a href="https://github.com/littlecodersh/ItChat" target="_blank" rel="noopener">微信机器人项目1</a><br><a href="https://github.com/youfou/wxpy" target="_blank" rel="noopener">微信机器人项目2</a><br>先把发消息的模块进行实现,可以做到robot在群内进行广播发消息，然后将目前短信报警的数据copy一份进微信报警模块中，进行试运行，看一看效果，再针对性优化，后面逐步将报警全面切到微信中。</p>
<a id="more"></a>]]></content>
      <tags>
        <tag>Projects</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>一次重构项目</title>
    <url>/2019/01/21/xm_ip_service/</url>
    <content><![CDATA[<h1 id="xm-ip-service原结构"><a href="#xm-ip-service原结构" class="headerlink" title="xm_ip_service原结构"></a>xm_ip_service原结构</h1><h2 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h2><p>通过IP地址（目前仅支持IPV4），进行IP地址相关地理信息的查询，查询过程分为，国内信息查询与国际信息查询两个查询方式。</p>
<h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><p>接口内容</p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AAA</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">string</span> ip,</span><br><span class="line">    <span class="number">2</span>: <span class="built_in">string</span> geo_ip_country_code,</span><br><span class="line">    <span class="number">3</span>: <span class="built_in">string</span> geo_ip_country_name,</span><br><span class="line">    <span class="number">4</span>: <span class="built_in">string</span> geo_ip_city_code,</span><br><span class="line">    <span class="number">5</span>: <span class="built_in">string</span> geo_ip_city_name,</span><br><span class="line">    <span class="number">6</span>: <span class="built_in">i32</span> error_no,</span><br><span class="line">    <span class="number">7</span>: <span class="built_in">string</span> geo_ip_province_code,</span><br><span class="line">    <span class="number">8</span>: <span class="built_in">string</span> geo_ip_province_name,</span><br><span class="line">    <span class="number">9</span>: <span class="built_in">string</span> geo_ip_carrier,</span><br><span class="line">    <span class="number">10</span>: <span class="built_in">string</span> error_msg,</span><br><span class="line">    <span class="number">11</span>: <span class="built_in">i64</span> geo_ip_start_ip,</span><br><span class="line">    <span class="number">12</span>: <span class="built_in">i64</span> geo_ip_end_ip</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BBB</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: list&lt;<span class="keyword">string</span>&gt; ipList,</span><br><span class="line">    <span class="number">2</span>: <span class="built_in">string</span> lang <span class="comment">// en or zh-CN</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">IP_Geo_Service</span> </span>&#123;</span><br><span class="line">   list&lt;GeoInfo&gt; queryGeoInfoByIP(<span class="number">1</span>:list&lt;<span class="keyword">string</span>&gt; ipList);</span><br><span class="line"></span><br><span class="line">   list&lt;GeoInfo&gt; queryGeoInfo(<span class="number">1</span>:GeoRequest req);</span><br><span class="line"></span><br><span class="line">   list&lt;GeoInfo&gt; queryI18nGeoInfoByIP(<span class="number">1</span>:list&lt;<span class="keyword">string</span>&gt; ipList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="业务逻辑说明"><a href="#业务逻辑说明" class="headerlink" title="业务逻辑说明"></a>业务逻辑说明</h2><h3 id="hook-go"><a href="#hook-go" class="headerlink" title="hook.go"></a>hook.go</h3><p><strong>描述：</strong></p>
<blockquote>
<p>定义并初始化了IP相关地理信息的原始数据结构体，并从文件当中读取所需地理信息数据，给其赋值，该结构体作为IP地理信息参照表，亦或查询表。</p>
</blockquote>
<p><strong>流程：</strong></p>
<blockquote>
<p>在加载配置文件之后，服务正式运行之前，通过New函数初始化该地理信息结构体；<br>然后，通过Open函数，读取配置里的路径信息，将该路径下文件里的地理信息通过信息的处理，依次读取到GeoModel的中文地理信息（cnGeos）和英文地理信息（enGeos）两个切片中，此时的GeoModel就成为了存储有完整IP相关地理信息的一张参照表；<br>GeoI18nModel类似，不过后者用作存储国际化的全球IP地理信息，没有中英文的区分，而是利用了命名为Names的Map基本结构扩展了所有所需的语言包，所以无需特意进行语言的区分，查询时打上语言标识即可。</p>
</blockquote>
<h3 id="IPservice-go"><a href="#IPservice-go" class="headerlink" title="IPservice.go"></a>IPservice.go</h3><blockquote>
<p>定义新建控制器。</p>
</blockquote>
<h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><p><strong>描述：</strong></p>
<blockquote>
<p>定义并初始化了控制器及其进程，以及hook函数的定义以及运行。</p>
</blockquote>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p><strong>描述：</strong></p>
<table>
<thead>
<tr>
<th>IP_Service_Handler</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>queryGeoInfo_Handler</td>
<td>通过发来的请求里包含的IP地址，参照GeoModel查询对应的地理信息；  如果查询不到或地理位置不在中国，则交给GeoI18nModel来继续查询对比相关的地理信息。  进行合适的日志处理之后，打包返回相关地理信息以及错误信息。</td>
</tr>
<tr>
<td>queryGeoInfoByIP_Handler</td>
<td>与上面不同的是，输入当中直接为IP_list，并没有相关的中英文标识，语言统一预设为中文识别， 当查询到地理信息不是中国的时候，则交给GeoI18nModel来继续查询对比相关的地理信息。</td>
</tr>
<tr>
<td>queryI18nGeoInfoByIP_Handler</td>
<td>与第二条相同，输入也直接为IP_list，不同的是，查询语言预设为英文。 并且是国际IP地理信息的查询服务，所以并不区分是否在“中国”国内。</td>
</tr>
</tbody></table>
<p><strong>流程：</strong><br>见Model里的业务逻辑描述。</p>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><h4 id="geo-model"><a href="#geo-model" class="headerlink" title="geo_model"></a>geo_model</h4><blockquote>
<p>定义了Geo和GeoModel结构体。及其New函数。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Geo定义了一个地区的IP区间</span></span><br><span class="line"><span class="keyword">type</span> Geo <span class="keyword">struct</span> &#123;</span><br><span class="line"> startIp      <span class="keyword">uint32</span></span><br><span class="line"> endIp        <span class="keyword">uint32</span></span><br><span class="line"> countryName  <span class="keyword">string</span></span><br><span class="line"> provinceName <span class="keyword">string</span></span><br><span class="line"> cityName     <span class="keyword">string</span></span><br><span class="line"> districtName <span class="keyword">string</span></span><br><span class="line"> carrierName  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GeoModel定义了中英文地理信息的数据整体信息，包括了数据路径以及所有中英文地理信息完整的数据切片</span></span><br><span class="line"><span class="keyword">type</span> GeoModel <span class="keyword">struct</span> &#123;</span><br><span class="line"> enDataPath <span class="keyword">string</span></span><br><span class="line"> cnDataPath <span class="keyword">string</span></span><br><span class="line"> cnGeos []*Geo</span><br><span class="line"> enGeos []*Geo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>open函数用来从文件中读取IP地理信息到geoModel结构体。该函数在hook.go中调用，用来初始化参照表GeoModel。</li>
<li>charToLong和charTolittle函数用来将IP地址转化为整数(ipValue)，好进行区间比较，以便找到IP的归属地。</li>
<li>search函数和compare函数结合起来，找到ipValue的对应区间，用来查找IP的归属地。</li>
<li>GetInfoByIP函数则整合以上代码，进行查表，将一个IP地址信息，和其语言标识，来查询对应的地理信息表单，返回一个地理信息和相关错误信息。</li>
</ul>
<h4 id="geoi18n-model"><a href="#geoi18n-model" class="headerlink" title="geoi18n_model"></a>geoi18n_model</h4><blockquote>
<p>定义了Geo和GeoModel结构体。及其New函数。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GeoI18nModel定义了国际IP地理信息数据包，包括了数据路劲以及所有的IP地理信息数据</span></span><br><span class="line"><span class="keyword">type</span> GeoI18nModel <span class="keyword">struct</span> &#123;</span><br><span class="line"> dataPath <span class="keyword">string</span></span><br><span class="line"> Data     *geoip2.Reader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>open函数用来从文件中读取IP地理信息到GeoI18nModel结构体。该函数在hook.go中调用，用来初始化参照表GeoI18nModel。</li>
<li>GetI18nInfoByIP函数，进行查表操作，查询国际IP地理信息表单，将一个IP地址信息进行解析，然后查询IP地址的所属城市信息，然后依次赋值给需要返回的单个地理信息，最好返回该地理信息和相关错误信息。</li>
</ul>
<h1 id="重构项目"><a href="#重构项目" class="headerlink" title="重构项目"></a>重构项目</h1><blockquote>
<p>对这个项目进行重构,数据存储层迁移到 PG, 功能上支持 ipv6</p>
</blockquote>
<h2 id="数据存储层迁移到PG"><a href="#数据存储层迁移到PG" class="headerlink" title="数据存储层迁移到PG"></a>数据存储层迁移到PG</h2><h3 id="PGSQL数据存储设计方案"><a href="#PGSQL数据存储设计方案" class="headerlink" title="PGSQL数据存储设计方案"></a>PGSQL数据存储设计方案</h3><p>此处数据存储层指的地理位置信息的参照表，原本是以<code>data</code>形式存储在代码包文件当中的，如下。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fze1gt1peoj30tp0gg42n.jpg" alt="data_en"></p>
<p>需要将该文件存储到PG中，以查表的方式来查询IP_geoInfo。</p>
<p>所以需要设计两张表来分别存储这两个文件。命名分别以ip_service_cn/en命名。<br>设计结果如下：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzgnmbjb8uj30hm06r0tg.jpg" alt=""></p>
<p>其中注意</p>
<ul>
<li>PG设置自增语句：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">nextval('ip_service_cn_id_seq'::regclass)</span><br><span class="line">nextval('ip_service_en_id_seq'::regclass)</span><br></pre></td></tr></table></figure>

<ul>
<li>PG插入多个数据的语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> public.ip_service ( start_ip , end_ip , country_name , province_name , city_name , district_name , carrier_name) <span class="keyword">VALUES</span> (<span class="number">16777216</span>,<span class="number">16777471</span>,<span class="string">'澳大利亚'</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>),(<span class="number">16777472</span>,<span class="number">16778239</span>,<span class="string">'中国'</span>,<span class="string">'福建'</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">'电信'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>PG恢复自增字段序号为1的语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> ip_service_en;</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> ip_service_cn;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SEQUENCE</span> ip_service_cn_id_seq RESTART <span class="keyword">WITH</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SEQUENCE</span> ip_service_en_id_seq RESTART <span class="keyword">WITH</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzgnkb78kfj30u60bntby.jpg" alt=""></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzgnklbpfqj30u60didjg.jpg" alt=""></p>
<p>因为查询IP_GEOINFO时，最主要是通过比对ip所处的区间，来得知，查询的IP属于哪一个地址范围，且，start_ip，end_ip有明显的连续性，所以可以由此建立索引。建表语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">"public"</span>.<span class="string">"ip_service_en"</span>(</span><br><span class="line">  <span class="string">"id"</span> <span class="built_in">serial8</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  <span class="string">"create_time"</span> timestamptz(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">now</span>(),</span><br><span class="line">  <span class="string">"update_time"</span> timestamptz(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">now</span>(),</span><br><span class="line">  <span class="string">"start_ip"</span> <span class="built_in">int8</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">	<span class="string">"end_ip"</span> <span class="built_in">int8</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  <span class="string">"country_name"</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">	<span class="string">"province_name"</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">	<span class="string">"city_name"</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">	<span class="string">"district_name"</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">	<span class="string">"carrier_name"</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> <span class="string">"idx_iprange_en"</span> <span class="keyword">ON</span> <span class="string">"public"</span>.<span class="string">"ip_service_en"</span> (start_ip,end_ip);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">"public"</span>.<span class="string">"ip_service_cn"</span>(</span><br><span class="line">  <span class="string">"id"</span> <span class="built_in">serial8</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  <span class="string">"create_time"</span> timestamptz(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">now</span>(),</span><br><span class="line">  <span class="string">"update_time"</span> timestamptz(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">now</span>(),</span><br><span class="line">  <span class="string">"start_ip"</span> <span class="built_in">int8</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">	<span class="string">"end_ip"</span> <span class="built_in">int8</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  <span class="string">"country_name"</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">	<span class="string">"province_name"</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">	<span class="string">"city_name"</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">	<span class="string">"district_name"</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">	<span class="string">"carrier_name"</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> <span class="string">"idx_iprange_cn"</span> <span class="keyword">ON</span> <span class="string">"public"</span>.<span class="string">"ip_service_cn"</span> (start_ip,end_ip);</span><br></pre></td></tr></table></figure>

<h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><blockquote>
<p>因为涉及到的数据量有近五百万条IP地址段，所以需要考虑插入的效率问题。于是结合了两个方案：</p>
</blockquote>
<ul>
<li>开Go程同时往中英文IP表单中插数据</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> NewInsert(p, <span class="string">"en"</span>, &amp;wg)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> NewInsert(p, <span class="string">"cn"</span>, &amp;wg)</span><br><span class="line">wg.Wait()</span><br><span class="line">Db.Close()</span><br></pre></td></tr></table></figure>

<ul>
<li>结合sql语句，1000条数据提交一次。（见上文PG插入多个数据的语句格式）</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInsert</span><span class="params">(p *GeoModel, tableName <span class="keyword">string</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> data, sql, sqlHead, sqlData, oneData <span class="keyword">string</span></span><br><span class="line">	sqlHead = <span class="string">"INSERT INTO public.ip_service_%s ( start_ip , end_ip , country_name , province_name , city_name , district_name , carrier_name)"</span></span><br><span class="line">	sqlData = <span class="string">"(%v,%v,'%v','%v','%v','%v','%v')"</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tableName == <span class="string">"en"</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> k, vousmevoyez := <span class="keyword">range</span> p.enGeos &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> vousmevoyez.StartIP != <span class="number">0</span> &amp;&amp; vousmevoyez.EndIP != <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">				oneData = fmt.Sprintf(sqlData, v.StartIP, v.EndIP, v.CountryName, v.ProvinceName, v.CityName, v.DistrictName, v.CarrierName)</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> k%<span class="number">1000</span> != <span class="number">0</span> &amp;&amp; k &lt; <span class="built_in">len</span>(p.cnGeos) &#123;</span><br><span class="line">					data += oneData</span><br><span class="line">					data += <span class="string">","</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					data += oneData</span><br><span class="line">					sql = sqlHead + <span class="string">" VALUES "</span> + data</span><br><span class="line">					fmt.Println(tableName + <span class="string">"***********:**********"</span> + strconv.Itoa(k))</span><br><span class="line">					_, err := Db.Exec(sql)</span><br><span class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">						fmt.Println(sql, err)</span><br><span class="line">						TableHandler(<span class="number">0</span>)</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> k%<span class="number">1000</span> == <span class="number">0</span> &#123;</span><br><span class="line">				data = <span class="string">""</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//···略</span></span><br><span class="line">  &#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其间碰到的一个坑：在英文IP地理信息中，名称中有的时候有单引号如<code>Yi&#39;an City</code>这个时候放在sql语句中就会报错，这个时候，如果想要在数据库中正确插入单引号，就要把一个单引号变成两个。所以，增加了一个排查单引号的功能，例子如下：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(tokens) &gt;= <span class="number">3</span> &#123;</span><br><span class="line">		geo.CountryName = tokens[<span class="number">2</span>]</span><br><span class="line">		<span class="keyword">if</span> strings.Contains(geo.CountryName, <span class="string">"'"</span>) &#123;</span><br><span class="line">			geo.CountryName = strings.Replace(geo.CountryName, <span class="string">"'"</span>, <span class="string">"''"</span>, <span class="number">-1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部代码修改"><a href="#内部代码修改" class="headerlink" title="内部代码修改"></a>内部代码修改</h3><p>后续只需要将源代码中关于geoModel的结构体做一次重新的适配，搜索的入口做一个重定向就行了，这里不做赘述。</p>
<h2 id="如何支持IPV6"><a href="#如何支持IPV6" class="headerlink" title="如何支持IPV6"></a>如何支持IPV6</h2><p>由于Leader说了，I18N的重构暂时不需要管IPV6的模块，所以就不动，并且，现阶段只需要做出一个能用的IPV6地址查询即可，于是，我首先要下载数据源，然后做地理查询前，同样要先将数据源转移到PG，然后再以类似的逻辑做地理查询，问题的难点在于，数据如何处理，和如何转移数据，以及数据库如何设计等等。</p>
<h3 id="地理数据集的处理"><a href="#地理数据集的处理" class="headerlink" title="地理数据集的处理"></a>地理数据集的处理</h3><p>IPV6地理信息数据集的<a href="https://www.cnblogs.com/kjcy8/p/5787723.html" target="_blank" rel="noopener">特性</a><br><a href=""></a></p>
]]></content>
      <tags>
        <tag>Projects</tag>
      </tags>
  </entry>
  <entry>
    <title>Koala结构的入门</title>
    <url>/2018/12/11/Koala/</url>
    <content><![CDATA[<h1 id="koala框架的使用"><a href="#koala框架的使用" class="headerlink" title="koala框架的使用"></a>koala框架的使用</h1><h2 id="编写IDL"><a href="#编写IDL" class="headerlink" title="编写IDL"></a>编写IDL</h2><p>在业务项目目录下创建helloworld目录，进入该目录，然后创建编辑hello.thrift，该文件用来生成基本框架。输入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Result &#123;      &#x2F;&#x2F;定义了一个Result结构体，为接口返回的结构体数据</span><br><span class="line">    1: string response,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service HelloService &#123;    &#x2F;&#x2F;定义了一个服务，只有一个接口↓</span><br><span class="line">    Result HelloWorld(1:string name);  &#x2F;&#x2F;HelloWorld,该接口接收一个string参数，返回一个Result结构体，见上。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成框架代码"><a href="#生成框架代码" class="headerlink" title="生成框架代码"></a>生成框架代码</h2><p>键入如下命令生成框架代码，请下载最新版本的<a href="http://micode.be.xiaomi.com/soa/soa_tools" target="_blank" rel="noopener">thrift工具</a></p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;path&#x2F;to&#x2F;soa_tools&#x2F;thrift --gen go --packagePath micode.be.xiaomi.com&#x2F;systech&#x2F;helloworld hello.thrift</span><br></pre></td></tr></table></figure>

<h2 id="编译执行"><a href="#编译执行" class="headerlink" title="编译执行"></a>编译执行</h2><p>执行 ./build.sh 进行编译，编译成功后，生成的程序在bin目录下。</p>
<h2 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h2><p>启动自动构建程序(auto_build.sh)，自动构建程序会实时检测项目目录下源码的是否变更，如果有变更将自动进行编译、重启程序。</p>
<h2 id="了解框架代码结构"><a href="#了解框架代码结构" class="headerlink" title="了解框架代码结构"></a>了解框架代码结构</h2><p>生成的框架代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── auto_build.sh                           &#x2F;&#x2F;自动构建脚本</span><br><span class="line">├── bin</span><br><span class="line">│   └── HelloService</span><br><span class="line">├── build.sh                                &#x2F;&#x2F;编译脚本</span><br><span class="line">├── config</span><br><span class="line">│   ├── scm_config.ini                      </span><br><span class="line">│   ├── scm_config.ini.online.env           &#x2F;&#x2F;线上配置</span><br><span class="line">│   └── scm_config.ini.test.env             &#x2F;&#x2F;测试环境配置</span><br><span class="line">├── hello.thrift                            &#x2F;&#x2F;接口描述文件</span><br><span class="line">├── package.sh                              &#x2F;&#x2F;编译打包脚本，使用请参考：http:&#x2F;&#x2F;mis.n.mi.com&#x2F;koala&#x2F;publish&#x2F;package.html</span><br><span class="line">├── README</span><br><span class="line">├── run                                     &#x2F;&#x2F;启动脚本</span><br><span class="line">├── run.sh                                  &#x2F;&#x2F;带supervise的启动脚本</span><br><span class="line">├── framework                               &#x2F;&#x2F;框架基础代码（无需更改）</span><br><span class="line">│   └── app</span><br><span class="line">│       ├── app.go</span><br><span class="line">│       ├── config.go</span><br><span class="line">│       ├── generate.go</span><br><span class="line">│       ├── global.go</span><br><span class="line">│       ├── initDb.go</span><br><span class="line">│       ├── initRabbitmq.go</span><br><span class="line">│       ├── initRedis.go</span><br><span class="line">│       ├── initRedisMock.go</span><br><span class="line">│       ├── initSqlMock.go</span><br><span class="line">│       ├── manager.go</span><br><span class="line">│       ├── plugin.go</span><br><span class="line">│       ├── register.go</span><br><span class="line">│       ├── rpc.go</span><br><span class="line">│       └── user_config.go</span><br><span class="line">├── hello                                   &#x2F;&#x2F;网络相关基础代码，无需更改</span><br><span class="line">│   ├── constants.go</span><br><span class="line">│   ├── helloservice.go</span><br><span class="line">│   ├── helloservice_host_wrapper.go</span><br><span class="line">│   ├── hello_service-remote</span><br><span class="line">│   │   └── hello_service-remote.go</span><br><span class="line">│   ├── helloservice_wrapper.go</span><br><span class="line">│   └── ttypes.go</span><br><span class="line">├── main</span><br><span class="line">│   ├── HelloService.go</span><br><span class="line">│   ├── HelloWorld_handler.go               &#x2F;&#x2F;HelloWorld的入口文件，需要业务实现</span><br><span class="line">│   ├── hook.go                             &#x2F;&#x2F;框架各个阶段的回调接口，可以实现自定义功能</span><br><span class="line">│   └── main.go</span><br><span class="line">└── model                                   &#x2F;&#x2F;业务model层</span><br><span class="line">└── supervise</span><br><span class="line">    └── supervise</span><br><span class="line">└── glide.yaml                              &#x2F;&#x2F; 依赖说明文件</span><br><span class="line">└── glide.lock                              &#x2F;&#x2F; 依赖版本锁文件</span><br></pre></td></tr></table></figure>
<p>对于 thrift IDL 中定义的每一个接口，会在 main 目录单独一个代码文件，并在接口名后面加上_handler后缀。 例如，对于 hello.thrift 定义的 HelloWorld 接口，生成的实现文件为 main/HelloWorld_handler.go。</p>
<h2 id="实现HelloWorld接口"><a href="#实现HelloWorld接口" class="headerlink" title="实现HelloWorld接口"></a>实现HelloWorld接口</h2><p>打开 main/HelloWorld_handler.go文件，框架生成的源代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"micode.be.xiaomi.com/systech/helloworld/hello"</span></span><br><span class="line">    <span class="string">"micode.be.xiaomi.com/systech/soa/context"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//ctx 用来记录请求在框架运行中当中的上下文，比如traceid以及appid等公共信息</span></span><br><span class="line"><span class="comment">//name 也就是我们IDL中定义的参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloServiceHandler)</span> <span class="title">HelloWorld</span><span class="params">(ctx *context.XContext, name <span class="keyword">string</span>)</span> <span class="params">(r *hello.Result_, errRet error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口返回一个hello.Result结构，以及若有错误产生，返回一个errRet。<br>我们记得，hello.Result_结构体的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Result_ <span class="keyword">struct</span> &#123;</span><br><span class="line">    Response <span class="keyword">string</span> <span class="string">`thrift:"response,1" json:"response"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当处理正常时，返回一个Response字符串。因此，我们的HelloWorld接口非常简单，实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"micode.be.xiaomi.com/systech/helloworld/hello"</span></span><br><span class="line">    <span class="string">"micode.be.xiaomi.com/systech/soa/context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloServiceHandler)</span> <span class="title">HelloWorld</span><span class="params">(context *context.XContext, name <span class="keyword">string</span>)</span> <span class="params">(r *hello.Result_, err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    r = &amp;hello.Result_&#123;&#125;</span><br><span class="line">    r.Response = fmt.Sprintf(<span class="string">"hello world,%s"</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="配置组名和服务名"><a href="#配置组名和服务名" class="headerlink" title="配置组名和服务名"></a>配置组名和服务名</h2><p>启动服务之前必须先在config/scm_config.ini中配置组名和服务名。<br>打开config/scm_config.ini，在group和service两个字段，填入相应的信息。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;基础配置</span><br><span class="line">[xbase]</span><br><span class="line">config_type&#x3D;local #local or etcd</span><br><span class="line">config_addr&#x3D;http:&#x2F;&#x2F;etcd.test.mi.com #配置中心地址</span><br><span class="line">;项目所在的小组名,一定要配置，不配置将会panic，详情请参见mis.n.mi.com</span><br><span class="line">group&#x3D;systech</span><br><span class="line">;项目的服务名，一定要配置，不配置将会panic，详情请参见mis.n.mi.com </span><br><span class="line">service&#x3D;hello</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>(注)服务名：服务开发完了之后，通过SOA平台进行注册，注册服务的时候会分配一个唯一的服务名。</p>
<h2 id="启动服务HelloService"><a href="#启动服务HelloService" class="headerlink" title="启动服务HelloService"></a>启动服务HelloService</h2><p>使用如下命令进行启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;HelloService</span><br></pre></td></tr></table></figure>

<h1 id="调用和测试"><a href="#调用和测试" class="headerlink" title="调用和测试"></a>调用和测试</h1><h2 id="生成SDK"><a href="#生成SDK" class="headerlink" title="生成SDK"></a>生成SDK</h2><p>通过以下命令，生成Golang的SDK：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;path&#x2F;to&#x2F;soa_tools&#x2F;thrift --gen go --packagePath micode.be.xiaomi.com&#x2F;your&#x2F;project .&#x2F;hello.thrift</span><br></pre></td></tr></table></figure>
<p>生成的SDK在当前目录sdk/v3/目录下。</p>
<p><strong>如果基于 koala v3 开发的项目需要生成 sdk 给 koala v1 或 v2 的项目使用，请使用命令：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;path&#x2F;to&#x2F;soa_tools&#x2F;thrift --gen go --v1 .&#x2F;hello.thrift</span><br><span class="line">&#x2F;path&#x2F;to&#x2F;soa_tools&#x2F;thrift --gen go --v2 .&#x2F;hello.thrift</span><br></pre></td></tr></table></figure>
<p><strong>生成的 SDK 在 sdk/v1/ sdk/v2 目录下。</strong></p>
<h2 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h2><p>golang版rpc包括两种调用方式：</p>
<h3 id="通过IP调用"><a href="#通过IP调用" class="headerlink" title="通过IP调用"></a>通过IP调用</h3><p>一般在开发过程，为了简化调用流程，我们可以直接指定后端服务ip和port进行调用。 在项目目录下(位置任意，只要import了…/helloworld/sdk/v3/hello包即可)新建main.go文件，编辑以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"micode.be.xiaomi.com/systech/helloworld/sdk/v3/hello"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	client:=hello.NewHelloServiceClientHostWrapper(<span class="string">"127.0.0.1"</span>,<span class="number">12508</span>,<span class="string">"xxx"</span>)</span><br><span class="line">	fmt.Println(client.HelloWorld(<span class="string">"xiaoming"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们代码依赖koala基础库，为了简化编译步骤，我们采用脚本进行编译运行，在当前目录下 打开run.sh，输入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">curdir&#x3D;&#96;pwd&#96;</span><br><span class="line">glide init &amp;&amp; glide up</span><br><span class="line">go run $curdir&#x2F;main.go</span><br></pre></td></tr></table></figure>
<p>运行run.sh，即可看到程序运行结果。</p>
<h3 id="通过服务名调用"><a href="#通过服务名调用" class="headerlink" title="通过服务名调用"></a>通过服务名调用</h3><p>在测试或线上环境中，我们需要在SOA平台上进行订阅xm_ip_service，然后通过服务名进行调用。 调用代码如下，保存为main.go：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"micode.be.xiaomi.com/your/project/sdk/v3/ip"</span></span><br><span class="line">    <span class="string">"micode.be.xiaomi.com/systech/soa/xrpc"</span></span><br><span class="line">    <span class="string">"micode.be.xiaomi.com/systech/soa/thrift"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化rpc组件,必须要到平台上订阅xm_ip_service服务</span></span><br><span class="line">    <span class="comment">//在本例中，xm_ip_service_client已经订阅了xm_ip_service服务，所以能够调用成功</span></span><br><span class="line">    <span class="comment">//参数1：group 订阅者所在的组名</span></span><br><span class="line">    <span class="comment">//参数2：service 订阅者所在的服务名（项目名）</span></span><br><span class="line">    <span class="comment">//参数3：etcd_host etcd地址，</span></span><br><span class="line">             <span class="number">1.</span> 测试环境为http:<span class="comment">//etcd.test.mi.com </span></span><br><span class="line">             <span class="number">1.</span> 线上环境为http:<span class="comment">//soa01.etcd.b2c.srv:4001</span></span><br><span class="line">    _, err := xrpc.NewXRpcDefault(<span class="string">"misite"</span>, <span class="string">"xm_ip_service_client"</span>, <span class="string">"http://etcd.test.mi.com"</span>)</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">nil</span>) &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数1：serviceName 调用方的服务名</span></span><br><span class="line">    <span class="comment">//参数2：logid 用来标识一次请求，一般从上游获取，没有可以自己随机生成</span></span><br><span class="line">    <span class="comment">//参数3：rpcId 填0即可</span></span><br><span class="line">    context := thrift.NewXContext(<span class="string">"xm_ip_service_client"</span>, <span class="number">1000</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 参数1：serviceName 服务提供方的服务名</span></span><br><span class="line">    <span class="comment">//2. 参数2：ctx 调用上下文</span></span><br><span class="line">    client := ip.NewIPServiceClientWrapper2(<span class="string">"xm_ip_service"</span>, context)</span><br><span class="line"></span><br><span class="line">    ipList := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">    ipList = <span class="built_in">append</span>(ipList, <span class="string">"100.200.39.4"</span>)</span><br><span class="line">    fmt.Println(client.QueryGeoInfoByIP(ipList))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行测试程序"><a href="#运行测试程序" class="headerlink" title="运行测试程序"></a>运行测试程序</h2><p>正常情况下，将会返回类似如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Result_(&#123;Response:hello world,liuxing1&#125;) &lt;nil&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Projects</tag>
        <tag>koala</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基本规范</title>
    <url>/2018/12/11/MySQL%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="一、基础规范"><a href="#一、基础规范" class="headerlink" title="一、基础规范"></a>一、基础规范</h1><ol>
<li><strong>使用 INNODB 存储引擎</strong></li>
<li><strong>表字符集使用 UTF8,如遇到EMOJ等表情符号的存储需求，可申请使用UTF8MB4字符集</strong></li>
<li><strong>所有表都需要添加注释</strong></li>
<li>单表数据量建字符类型居多的表建议控制在3000W以内，整型居多的表建议控制在5000W以内</li>
<li><strong>不在数据库中存储图⽚、文件等大数据</strong></li>
<li>禁止在线上做数据库压力测试</li>
<li>禁⽌从测试、开发环境直连数据库</li>
</ol>
<h1 id="二、命名规范"><a href="#二、命名规范" class="headerlink" title="二、命名规范"></a>二、命名规范</h1><ol>
<li><strong>库名表名字段名必须有固定的命名长度，12个字符以内</strong></li>
<li>库名、表名、字段名禁⽌止使⽤用MySQL保留字,比如订单表不要直接叫做order</li>
<li><strong>临时库、表名必须以tmp为前缀，并以⽇日期为后缀</strong></li>
<li><strong>备份库、表必须以bak为前缀，并以日期为后缀</strong></li>
</ol>
<a id="more"></a>

<h1 id="三、库、表、字段开发设计规范"><a href="#三、库、表、字段开发设计规范" class="headerlink" title="三、库、表、字段开发设计规范"></a>三、库、表、字段开发设计规范</h1><ol>
<li><strong>建表默认5字段，主键、创建时间、修改时间。id、create_time、update_time</strong></li>
<li>禁⽌使用分区表</li>
<li>拆分大字段和访问频率低的字段，分离冷热数据</li>
<li><strong>按日期时间分表需符合例如table_201401、table_20140422格式</strong></li>
<li>采用合适的分库分表策略</li>
<li><strong>用 DECIMAL 代替 FLOAT 和 DOUBLE 存储精确浮点数</strong></li>
<li>越简单越好：将字符转化为数字、使用 TINYINT 来代替 ENUM 类型</li>
<li>若使用ENUM类型，不允许修改默认值，只允许顺序添加</li>
<li><strong>所有字段均定义为 NOT NULL</strong></li>
<li><strong>INT类型固定占用 4 字节存储</strong></li>
<li><strong>使用 timestamp 存储时间</strong></li>
<li><strong>使用 VARBINARY 存储大小写敏感的变长字符串</strong></li>
<li><strong>禁止在数据库中存储明文密码，把密码加密后存储</strong></li>
<li>用好数值类型字段</li>
<li><strong>存储ip最好用 int 存储而非 char(15)</strong></li>
<li><strong>避免使用 NULL 字段</strong>， NULL 字段很难查询优化，NULL字段的索引需要额外空间，NULL字段的复合索引无效</li>
<li><strong>少用 text/blob ， varchar 的性能会比 text 高很多，实在避免不了blob，请拆表</strong></li>
<li><strong>数据库中不允许存储大文件，或者照片，可以将大对象放到磁盘上，数据库中存储它的路径</strong></li>
</ol>
<h1 id="四、索引规范"><a href="#四、索引规范" class="headerlink" title="四、索引规范"></a>四、索引规范</h1><p>1、索引的数量要控制：</p>
<ul>
<li><strong>单张表中索引数量不超过5个</strong></li>
<li>单个索引中的字段数不超过5个</li>
<li>对字符串使⽤用前缀索引，前缀索引长度不超过8个字符</li>
<li>建议优先考虑前缀索引，必要时可添加伪列并建立索引</li>
</ul>
<p>2、<strong>主键准则</strong></p>
<ul>
<li><strong>表必须有主键</strong></li>
<li><strong>不使用更新频繁的列作为主键</strong></li>
<li><strong>尽量不选择字符串列作为主键</strong></li>
<li>不使用 UUID MD5 HASH 这些作为主键(数值太离散了)</li>
<li><strong>默认使⽤非空的唯一键作为主键</strong></li>
<li><strong>建议选择自增或发号器</strong></li>
</ul>
<p>3、<strong>重要的SQL必须被索引</strong></p>
<ul>
<li>比如：UPDATE 、 DELETE 语句的 WHERE 条件列,ORDER BY 、 GROUPBY 、 DISTINCT 的字段</li>
</ul>
<p>4、多表JOIN的字段注意以下</p>
<ul>
<li>区分度最大的字段放在前面</li>
<li>核⼼SQL优先考虑覆盖索引</li>
<li>避免冗余和重复索引</li>
<li>索引要综合评估数据密度和分布以及考虑查询和更新比例</li>
</ul>
<p>5、<strong>索引禁忌</strong></p>
<ul>
<li><strong>不在低基数列上建立索引，例如“性别”</strong></li>
<li><strong>不在索引列进行数学运算和函数运算</strong></li>
</ul>
<p>6、<strong>尽量不使用外键</strong></p>
<ul>
<li>外键用来保护参照完整性，可在业务端实现</li>
<li>对父表和子表的操作会相互影响，降低可用性</li>
</ul>
<p>7、索引命名：</p>
<ul>
<li><strong>非唯一索引必须以idx字段1字段2命名，唯一所以必须以 uniq 字段 1 字段 2 命名，索引名称必须全部小写</strong></li>
</ul>
<p>8、<strong>新建的唯一索引必须不能和主键重复</strong></p>
<p>9、<strong>索引字段的默认值不能为 NULL ，要改为其他的 default 或者空。 NULL 非常影响索引的查询效率</strong></p>
<p>10、反复查看与表相关的SQL</p>
<ul>
<li>符合最左前缀的特点建立索引。多条字段重复的语句，要修改语句条件字段的顺序，为其建立一条联合索引，减少索引数量</li>
</ul>
<p>11、<strong>能使用唯一索引就要使用唯一索引，提高查询效率</strong></p>
<p>12、研发要经常使用 explain ，如果发现索引选择性差，必须让他们学会使用hint</p>
<p>13、合理创建联合索引，(a，b，c) 相当于 (a) 、(a，b) 、(a，b，c)</p>
<p>14、不对过长的VARCHAR字段建立索引。建议优先考虑添加CRC32或MD5伪列，并对伪列建立索引，减少索引长度，提高效率。</p>
<h1 id="五、SQL规范"><a href="#五、SQL规范" class="headerlink" title="五、SQL规范"></a>五、SQL规范</h1><ol>
<li>使用prepared statement，可以提升性能并避免SQL注入。</li>
<li>减少与数据库交互次数，尽量采用批量提交SQL语句（INSERT INTO table （column1、column2、column3） VALUES(),(),()），不宜过多看字符个数500-1000即可。</li>
<li>SQL语句尽可能简单，大的SQL想办法拆成小的SQL语句(充分利用QUERYCACHE和充分利用多核CPU)</li>
<li>事务要简单，整个事务的时间长度不要太长</li>
<li>避免使用触发器、函数、存储过程</li>
<li>降低业务耦合度，为sacle out 、 sharding 留有余地</li>
<li><strong>避免在数据库中进⾏数学运算(MySQL不擅长数学运算和逻辑判断)</strong></li>
<li><strong>不要用 SELECT * ，查询哪几个字段就SELECT这几个字段</strong></li>
<li><strong>SQL中使用到OR的改写为用IN()(OR的效率没有IN的效率高)</strong></li>
<li>用in代替or,里面数字的个数建议控制在 1000 以内</li>
<li><strong>LIMIT分页注意效率。</strong></li>
<li><strong>使用 UNION ALL 替代 UNION</strong></li>
<li>避免使用大表的 JOIN</li>
<li><strong>使用 GROUP BY 分组、自动排序</strong></li>
<li><strong>对数据的更新要打散后批量更新，不要一次更新太多数据</strong></li>
<li><strong>减少与数据库的交互次数</strong></li>
<li>注意使用性能分析工具</li>
<li>SQL explain / showprofile / mySQLsla，尽量避免extra列出现：Using File Sort、Using Temporary。</li>
<li><strong>SQL语句要求所有研发，SQL关键字全部是大写，每个词只允许有一个空格</strong></li>
<li><strong>SQL语句不可以出现隐式转换，比如 SELECT id FROM TABLE WHERE id=’1’</strong></li>
<li>IN条件里面的数据数量要少，我记得应该是500个以内，要学会使用EXIST代替IN，EXIST在一些场景查询会比IN快</li>
<li><strong>能不用 NOT IN 就不用 NOTIN ，坑太多了。。会把空和NULL给查出来</strong></li>
<li><strong>在SQL语句中，禁止使用前缀是%的LIKE</strong></li>
<li><strong>不使用负向查询，如 NOT IN / LIKE</strong></li>
<li><strong>关于分页查询：程序里建议合理使用分页来提高效率LIMIT，OFFSET较大要配合子查询使用</strong></li>
<li><strong>禁止在数据库中跑大查询</strong></li>
<li>使⽤预编译语句，只传参数，比传递SQL语句更高效；一次解析，多次使用；降低SQL注入概率</li>
<li><strong>禁止使 ORDER BY RAND()</strong></li>
<li>禁⽌单条SQL语句同时更新多个表</li>
<li><strong>禁止使用%前导查询，例如：like “%abc”，无法利用到索引。</strong></li>
<li><strong>禁止使用负向查询，例如 not in、!=、not like、&lt;&gt;。</strong></li>
</ol>
<h1 id="六、常见类型建议"><a href="#六、常见类型建议" class="headerlink" title="六、常见类型建议"></a>六、常见类型建议</h1><ul>
<li><strong>小米帐号(user_id/mi_id):bigint</strong></li>
<li><strong>订单号(order_id):bigint</strong></li>
<li><strong>钱相关(price/money):bigint(看需求按分或者厘做单位)</strong></li>
<li>sku()</li>
<li>商品id</li>
<li>货品id</li>
<li><strong>微信open_id</strong></li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 教程</title>
    <url>/2018/12/11/Redis%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Redis-教程"><a href="#Redis-教程" class="headerlink" title="Redis 教程"></a><a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">Redis 教程</a></h1><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy2x4m6m1mj30ki0d8di9.jpg" alt=""></p>
<p>Redis是一个字典结构的存储服务器，而实际上一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。这与我们熟知的在一个关系数据库实例中可以创建多个数据库类似，所以可以将其中的每个字典都理解成一个独立的数据库。</p>
<a id="more"></a>

<h1 id="Redis的安装和启动"><a href="#Redis的安装和启动" class="headerlink" title="Redis的安装和启动"></a>Redis的安装和启动</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew install redis</span><br></pre></td></tr></table></figure>
<p>启动redis服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew services start redis</span><br></pre></td></tr></table></figure>
<p>启动redis客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ redis-cli</span><br></pre></td></tr></table></figure>
<p>如果出现中文乱码，则要在 redis-cli 后面加上 –raw</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ redis-cli &#x2F;--raw</span><br></pre></td></tr></table></figure>
<p>远程服务上执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ redis-cli -h host -p port -a password</span><br></pre></td></tr></table></figure>
<p>检查连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PING&#x2F;&#x2F;PONG显示连接成功</span><br></pre></td></tr></table></figure>
<h1 id="Redis-常用命令"><a href="#Redis-常用命令" class="headerlink" title="Redis  常用命令"></a>Redis  常用命令</h1><h2 id="Redis-数据操作命令"><a href="#Redis-数据操作命令" class="headerlink" title="Redis 数据操作命令"></a>Redis 数据操作命令</h2><p>Redis 数据操作命令的基本语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; COMMAND KEY_NAME</span><br></pre></td></tr></table></figure>
<p><a href="http://www.runoob.com/redis/redis-keys.html" target="_blank" rel="noopener">Redis 键(key)</a><br><a href="http://www.runoob.com/redis/redis-strings.html" target="_blank" rel="noopener">Redis 字符串(String)</a><br><a href="http://www.runoob.com/redis/redis-hashes.html" target="_blank" rel="noopener">Redis 哈希(Hash)</a><br><a href="http://www.runoob.com/redis/redis-lists.html" target="_blank" rel="noopener">Redis 列表(List)</a><br><a href="http://www.runoob.com/redis/redis-sets.html" target="_blank" rel="noopener">Redis 集合(Set)</a><br><a href="http://www.runoob.com/redis/redis-sorted-sets.html" target="_blank" rel="noopener">Redis 有序集合(sorted set)</a><br><a href="http://www.runoob.com/redis/redis-hyperloglog.html" target="_blank" rel="noopener">Redis HyperLogLog</a></p>
<h2 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。<br>Redis 客户端可以订阅任意数量的频道。<br><a href="http://www.runoob.com/redis/redis-pub-sub.html" target="_blank" rel="noopener">Redis 发布订阅</a><br>实例<br>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;redisChat&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure>
<p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Redis is a great caching technique&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Learn redis by runoob.com&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"># 订阅者的客户端会显示如下消息</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;redisChat&quot;</span><br><span class="line">3) &quot;Redis is a great caching technique&quot;</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;redisChat&quot;</span><br><span class="line">3) &quot;Learn redis by runoob.com&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。<br>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。一个事务从开始到执行会经历以下三个阶段：</li>
</ul>
<ol>
<li>开始事务。</li>
<li>命令入队。</li>
<li>执行事务。</li>
</ol>
<hr>
<p>实例<br>以下是一个事务的例子， 它先以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <strong>EXEC</strong> 命令触发事务， 一并执行事务中的所有命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET book-name &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; GET book-name</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SADD tag &quot;C++&quot; &quot;Programming&quot; &quot;Mastering Series&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS tag</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">3) (integer) 3</span><br><span class="line">4) 1) &quot;Mastering Series&quot;</span><br><span class="line">   2) &quot;C++&quot;</span><br><span class="line">   3) &quot;Programming&quot;</span><br></pre></td></tr></table></figure>

<p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。<br>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p>
<blockquote>
<p>这是官网上的说明 From redis docs on transactions:  </p>
<p>It’s important to note that even when a command fails, all the other commands in the queue are processed – Redis will not stop the processing of commands.  </p>
</blockquote>
<p>实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:7000&gt; multi</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7000&gt; set a aaa</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7000&gt; set b bbb</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7000&gt; set c ccc</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7000&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br></pre></td></tr></table></figure>

<p>如果在 set b bbb 处失败，set a 已成功不会回滚，set c 还会继续执行。</p>
<hr>
<p>Redis 事务命令<br>下表列出了 redis 事务的相关命令：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fy2x4mq7ycj30n509zq3s.jpg" alt=""></p>
<h2 id="Redis-脚本"><a href="#Redis-脚本" class="headerlink" title="Redis 脚本"></a>Redis 脚本</h2><p>Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 <strong>EVAL</strong><br><a href="http://www.runoob.com/redis/redis-scripting.html" target="_blank" rel="noopener">Redis 脚本</a></p>
<h2 id="Redis-连接"><a href="#Redis-连接" class="headerlink" title="Redis 连接"></a>Redis 连接</h2><p>Redis 连接命令主要是用于连接 redis 服务。<br>实例<br>以下实例演示了客户端如何通过密码验证连接到 redis 服务，并检测服务是否在运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; AUTH &quot;password&quot; &#x2F;&#x2F;验证密码是否正确</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; PING            &#x2F;&#x2F;查看服务是否运行</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>
<ul>
<li>ECHO message   :  打印字符串</li>
<li>QUIT  : 关闭当前连接</li>
<li>SELECT index  : 切换到指定的数据库</li>
</ul>
<h2 id="Redis-服务器"><a href="#Redis-服务器" class="headerlink" title="Redis 服务器"></a>Redis 服务器</h2><p>Redis 服务器命令主要是用于管理 redis 服务。<br><a href="http://www.runoob.com/redis/redis-server.html" target="_blank" rel="noopener">Redis 服务器</a></p>
<h1 id="Redis-高级使用教程"><a href="#Redis-高级使用教程" class="headerlink" title="Redis 高级使用教程"></a>Redis 高级使用教程</h1><h2 id="Redis数据备份与恢复"><a href="#Redis数据备份与恢复" class="headerlink" title="Redis数据备份与恢复"></a>Redis数据备份与恢复</h2><h3 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h3><p>Redis <strong>SAVE</strong> 命令用于创建当前数据库的备份。<br>语法<br>redis <strong>Save</strong> 命令基本语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SAVE</span><br></pre></td></tr></table></figure>
<p>实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SAVE </span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>该命令将在 redis 安装目录中创建dump.rdb文件。</p>
<h3 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h3><p>如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 <strong>CONFIG</strong> 命令，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET dir</span><br><span class="line">1) &quot;dir&quot;</span><br><span class="line">2) &quot;&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&quot;</span><br></pre></td></tr></table></figure>
<p>以上命令 <strong>CONFIG GET dir</strong> 输出的 redis 安装目录为 _usr_local_redis_bin。</p>
<h3 id="BGSAVE"><a href="#BGSAVE" class="headerlink" title="BGSAVE"></a><strong>BGSAVE</strong></h3><p>创建 redis 备份文件也可以使用命令 <strong>BGSAVE</strong>，该命令在后台执行。<br>实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BGSAVE</span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure>
<h2 id="Redis-安全"><a href="#Redis-安全" class="headerlink" title="Redis 安全"></a>Redis 安全</h2><p>我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。<br>实例<br>我们可以通过以下命令查看是否设置了密码验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。<br>你可以通过以下命令来修改该参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG set requirepass &quot;runoob&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; CONFIG get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;runoob&quot;</span><br></pre></td></tr></table></figure>
<p>设置密码后，客户端连接 redis 服务就需要密码验证，否则无法执行命令。<br>语法<br>AUTH 命令基本语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; AUTH password</span><br></pre></td></tr></table></figure>
<p>实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; AUTH &quot;runoob&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SET mykey &quot;Test value&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GET mykey</span><br><span class="line">&quot;Test value&quot;</span><br></pre></td></tr></table></figure>
<h2 id="Redis-性能测试"><a href="#Redis-性能测试" class="headerlink" title="Redis 性能测试"></a>Redis 性能测试</h2><p>Redis 性能测试是通过同时执行多个命令实现的。<br>语法<br>redis 性能测试的基本命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-benchmark [option] [option value]</span><br></pre></td></tr></table></figure>
<p>实例<br>以下实例同时执行 10000 个请求来检测性能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ redis-benchmark -n 10000  -q</span><br><span class="line">PING_INLINE: 141043.72 requests per second</span><br><span class="line">PING_BULK: 142857.14 requests per second</span><br><span class="line">SET: 141442.72 requests per second</span><br><span class="line">GET: 145348.83 requests per second</span><br><span class="line">INCR: 137362.64 requests per second</span><br><span class="line">LPUSH: 145348.83 requests per second</span><br><span class="line">LPOP: 146198.83 requests per second</span><br><span class="line">SADD: 146198.83 requests per second</span><br><span class="line">SPOP: 149253.73 requests per second</span><br><span class="line">LPUSH (needed to benchmark LRANGE): 148588.42 requests per second</span><br><span class="line">LRANGE_100 (first 100 elements): 58411.21 requests per second</span><br><span class="line">LRANGE_300 (first 300 elements): 21195.42 requests per second</span><br><span class="line">LRANGE_500 (first 450 elements): 14539.11 requests per second</span><br><span class="line">LRANGE_600 (first 600 elements): 10504.20 requests per second</span><br><span class="line">MSET (10 keys): 93283.58 requests per second</span><br></pre></td></tr></table></figure>
<p>redis 性能测试工具可选参数如下所示：<br>序号  选项  描述  默认值<br>1   -h  指定服务器主机名    127.0.0.1<br>2   -p  指定服务器端口   6379<br>3   -s  指定服务器 socket<br>4   -c  指定并发连接数   50<br>5   -n  指定请求数 10000<br>6   -d  以字节的形式指定 SET/GET 值的数据大小 2<br>7   -k  1=keep alive 0=reconnect    1<br>8   -r  SET_GET_INCR 使用随机 key, SADD 使用随机值<br>9   -P  通过管道传输 <numreq> 请求  1<br>10  -q  强制退出 redis。仅显示 query/sec 值<br>11  –csv   以 CSV 格式输出<br>12  -l  生成循环，永久执行测试<br>13  -t  仅运行以逗号分隔的测试命令列表。<br>14  -I  Idle 模式。仅打开 N 个 idle 连接并等待。<br>实例<br>以下实例我们使用了多个参数来测试 redis 性能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 10000 -q</span><br><span class="line">SET: 146198.83 requests per second</span><br><span class="line">LPUSH: 145560.41 requests per second</span><br></pre></td></tr></table></figure>
<p>以上实例中主机为 127.0.0.1，端口号为 6379，执行的命令为 <strong>SET,LPUSH</strong>，请求数为 10000，通过 -q 参数让结果只显示每秒执行的请求数。</p>
<h2 id="Redis-客户端连接"><a href="#Redis-客户端连接" class="headerlink" title="Redis 客户端连接"></a>Redis 客户端连接</h2><p>Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作：</p>
<ul>
<li>首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。</li>
<li>然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法</li>
<li>然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送</li>
</ul>
<hr>
<h3 id="最大连接数"><a href="#最大连接数" class="headerlink" title="最大连接数"></a>最大连接数</h3><p>在 Redis2.4 中，最大连接数是被直接硬编码在代码里面的，而在2.6版本中这个值变成可配置的。<br>maxclients 的默认值是 10000，你也可以在 redis.conf 中对这个值进行修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config get maxclients</span><br><span class="line">1) &quot;maxclients&quot;</span><br><span class="line">2) &quot;10000&quot;</span><br></pre></td></tr></table></figure>
<p>实例<br>以下实例我们在服务启动时设置最大连接数为 100000：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server --maxclients 100000</span><br></pre></td></tr></table></figure>

<h3 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h3><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy2x4mgzc9j30n40a7aat.jpg" alt=""></p>
<h2 id="Redis-管道技术"><a href="#Redis-管道技术" class="headerlink" title="Redis 管道技术"></a>Redis 管道技术</h2><p>Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：</p>
<ul>
<li>客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。</li>
<li>服务端处理命令，并将结果返回给客户端。</li>
</ul>
<hr>
<p>Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。<br>实例<br>查看 redis 管道，只需要启动 redis 实例并输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(echo -en &quot;PING\r\n SET runoobkey redis\r\nGET runoobkey\r\nINCR visitor\r\nINCR visitor\r\nINCR visitor\r\n&quot;; sleep 10) | nc localhost 6379</span><br><span class="line">+PONG</span><br><span class="line">+OK</span><br><span class="line">redis</span><br><span class="line">:1</span><br><span class="line">:2</span><br><span class="line">:3</span><br></pre></td></tr></table></figure>
<p>以上实例中我们通过使用 PING 命令查看redis服务是否可用， 之后我们设置了 runoobkey 的值为 redis，然后我们获取 runoobkey 的值并使得 visitor 自增 3 次。在返回的结果中我们可以看到这些命令一次性向 redis 服务提交，并最终一次性读取所有服务端的响应</p>
<hr>
<blockquote>
<p>管道技术的优势:<br>管道技术最显著的优势是提高了 <strong>redis</strong> 服务的性能。</p>
</blockquote>
<hr>
<p><strong>一些测试数据</strong><br>在下面的测试中，我们将使用Redis的Ruby客户端，支持管道技术特性，测试管道技术对速度的提升效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require &#39;rubygems&#39; </span><br><span class="line">require &#39;redis&#39;</span><br><span class="line">def bench(descr) </span><br><span class="line">start &#x3D; Time.now </span><br><span class="line">yield </span><br><span class="line">puts &quot;#&#123;descr&#125; #&#123;Time.now-start&#125; seconds&quot; </span><br><span class="line">end</span><br><span class="line">def without_pipelining </span><br><span class="line">r &#x3D; Redis.new </span><br><span class="line">10000.times &#123; </span><br><span class="line">    r.ping </span><br><span class="line">&#125; </span><br><span class="line">end</span><br><span class="line">def with_pipelining </span><br><span class="line">r &#x3D; Redis.new </span><br><span class="line">r.pipelined &#123; </span><br><span class="line">    10000.times &#123; </span><br><span class="line">        r.ping </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">end</span><br><span class="line">bench(&quot;without pipelining&quot;) &#123; </span><br><span class="line">    without_pipelining </span><br><span class="line">&#125; </span><br><span class="line">bench(&quot;with pipelining&quot;) &#123; </span><br><span class="line">    with_pipelining </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从处于局域网中的Mac OS X系统上执行上面这个简单脚本的数据表明，开启了管道操作后，往返延时已经被改善得相当低了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">without pipelining 1.185238 seconds </span><br><span class="line">with pipelining 0.250783 seconds</span><br></pre></td></tr></table></figure>
<p>如你所见，开启管道后，我们的速度效率提升了5倍。</p>
<h2 id="Redis-分区"><a href="#Redis-分区" class="headerlink" title="Redis 分区"></a>Redis 分区</h2><p>分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。</p>
<h3 id="分区的优势"><a href="#分区的优势" class="headerlink" title="分区的优势"></a>分区的优势</h3><ul>
<li>通过利用多台计算机内存的和值，允许我们构造更大的数据库。</li>
<li>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。</li>
</ul>
<h3 id="分区的不足"><a href="#分区的不足" class="headerlink" title="分区的不足"></a>分区的不足</h3><p>redis的一些特性在分区方面表现的不是很好：</p>
<ul>
<li>涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。</li>
<li>涉及多个key的redis事务不能使用。</li>
<li>当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。</li>
<li>增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。</li>
</ul>
<hr>
<h3 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h3><p>Redis 有两种类型分区。 假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个Redis服务。</p>
<h4 id="范围分区"><a href="#范围分区" class="headerlink" title="范围分区"></a>范围分区</h4><p>最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。<br>比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。<br>这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各 种对象的映射表，通常对Redis来说并非是好的方法。</p>
<h4 id="哈希分区"><a href="#哈希分区" class="headerlink" title="哈希分区"></a>哈希分区</h4><p>另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单：</p>
<ul>
<li>用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。</li>
<li>对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 = 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。</li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Moments Project 朋友圈设计</title>
    <url>/2018/12/11/moment/</url>
    <content><![CDATA[<h1 id="需求↓"><a href="#需求↓" class="headerlink" title="需求↓"></a>需求↓</h1><p>做一个看板任务(照着微信朋友圈来,不过所有用户全部看成朋友即可)</p>
<ol>
<li>用户可以登录,可以保持登录状态</li>
<li>用户可以发布一个想法,包含一段文字,0-4张图片(保存图片链接即可)</li>
<li>用户可以查看大家发布的说说,按时间顺序从新展示,需分页,一页20个</li>
<li>用户可以评论想法,也可以删除自己的评论</li>
<li>用户可以点赞/取消点赞想法</li>
<li>消息通知,点赞回复要通知所有和说说相关的人</li>
</ol>
<blockquote>
<p>不做界面,规划好接口,数据库,且完成即可<br>数据库尽可能满足 一对一  一对多  多对多 关系,不要求字段冗余<br>使用HTTP协议,框架自选(iris,beego等都行)<br>进度:</p>
</blockquote>
<ol>
<li>设计好数据库</li>
<li>规划好接口</li>
<li>做好登录认证</li>
<li>完成接口</li>
</ol>
<a id="more"></a>

<h1 id="数据库实现"><a href="#数据库实现" class="headerlink" title="数据库实现"></a>数据库实现</h1><p><a href="https://jingyan.baidu.com/article/624e745961c6a134e9ba5a40.html" target="_blank" rel="noopener">数据库E-R图怎么画？</a></p>
<blockquote>
<p>实体，属性，关系；实体就是一个个对象，比如猫；属性就是实体所有的某个属性，比如猫的性别；关系就是实体和实体之间或者实体内部之间的关系。<br>在ER图中，<strong>矩形代表实体，椭圆代表属性，菱形代表关系</strong>，各个形状之间用线段连接。  </p>
</blockquote>
<p>在本项目中，实体有</p>
<ol>
<li>内容发布者</li>
<li>朋友圈发布项</li>
<li>朋友圈的评论项</li>
</ol>
<p>内容发布者对应属性：</p>
<ul>
<li>用户ID（系统内部）（主键）</li>
<li>用户姓名（界面展示）</li>
<li>用户密码</li>
</ul>
<p>朋友圈标志属性：</p>
<ul>
<li>发布ID(每个发布者发布朋友圈时调用，自增1，本身具有时间顺序特性)（主键）</li>
<li>发布者用户ID（外键）</li>
<li>创建时间（显示在朋友圈下方）</li>
<li>照片列：照片url;照片url;照片url;照片url</li>
<li>配文字符串</li>
</ul>
<p>评论属性：（评论归属于单个用户，并且此用户为接收者，而不是发布者）</p>
<ul>
<li>用户ID（评论创建者，用来检索对应的用户名，以展示用户评论）（外键）</li>
<li>所属朋友圈，即发布ID（和用户ID组合作为主键）（外键）</li>
<li>评论创建时间（按时间顺序显示评论）</li>
<li>评论内容字符串</li>
<li>点赞与否</li>
</ul>
<h2 id="数据库设计思路"><a href="#数据库设计思路" class="headerlink" title="数据库设计思路"></a>数据库设计思路</h2><blockquote>
<p>做一个看板任务(照着微信朋友圈来,不过所有用户全部看成朋友即可)1. 用户可以登录,可以保持登录状态<br>2. 用户可以发布一个想法,包含一段文字,0-4张图片(保存图片链接即可)<br>3. 用户可以查看大家发布的说说,按时间顺序从新展示,需分页,一页20个<br>4. 用户可以评论想法,也可以删除自己的评论<br>5. 用户可以点赞/取消点赞想法<br>6. 消息通知,点赞回复要通知所有和说说相关的人<br>不做界面,规划好接口,数据库,且完成即可<br>数据库尽可能满足 一对一 一对多 多对多 关系,不要求字段冗余<br>使用HTTP协议,框架自选(iris,beego等都行)</p>
</blockquote>
<p><strong>微信朋友圈设计架构</strong></p>
<p>微信朋友圈的数据有四个核心的表：</p>
<ol>
<li>发布表，发布表记录了来自所有用户的所有<a href="http://www.woshipm.com/marketing/1023818.html" target="_blank" rel="noopener">Feed</a>，比如一个用户发布了几张图片，每张图片的URL，图片在<a href="https://www.cnblogs.com/tinywan/p/6067126.html" target="_blank" rel="noopener">CDN</a>里的URL，它有哪些元属性，谁可以看，谁不可以看等等。</li>
<li>相册，相册是每个用户独立的，记录了该用户所发布的所有内容，包括了与图片相关的文字，和无配图文字。</li>
<li>评论， 评论就是针对某个具体发布的朋友评论和点赞操作。</li>
<li>时间线，所谓“刷朋友圈”，就是刷时间线，就是一个用户所有的朋友的发布内容。</li>
</ol>
<p><strong>微信朋友圈的工作流程概述</strong></p>
<ol>
<li><p>比如有两个用户A和B， A和B各自都有各自的相册（可以理解为A和B各自的朋友圈内容），可能在同一台服务器上，也可能在不同服务器上。现在A上传了一张图片到自己的朋友圈。上传图片不经过微信服务器，而是直接上传到最近的CDN节点去，所以非常快。图片上传到CDN后，小王的微信客户端会通知，这里有一个新的发布（比如叫K2），这个发布的图片CDN URL是什么，谁能看这张图片等等此类的元数据。来把这些数据写入发布表中。</p>
</li>
<li><p>在发布表写完之后，会把K2的发布索引到A的相册表中，所以相册表记录得就是每个内容索引指针，相册表写好后会触发一个批处理动作，这个动作就是去跟A的每个好友说，A有一个新的发布，请把这个发布插入到每个好友的时间线里去。</p>
</li>
<li><p>现在B上朋友圈了，而B是A的一个好友，B拉自己的时间线的时候，时间线会获得K2的新发布通知，然后B的微信客户端就会取根据K2的元数据去获取发布表中的一些信息比如：CDN URL，把图片拉到本地。</p>
</li>
</ol>
<blockquote>
<p>在这个过程中，发布是很重要的，因为一方面要写一个自己的数据副本，并写入自己的时间线，还要把这个副本的指针插到所有好友的时间线里面去，如果一个用户有几百个好友的话，这个过程会比较慢一些。这是一个单数据副本写扩散的过程。但是相对应的，读取就很简单。每个用户只需要读取自己的时间线这一个动作就行，不需要去遍历所有的好友相册表。这个是否有一定得数据冗余？？</p>
</blockquote>
<p>参考文献：</p>
<ol>
<li><a href="https://blog.csdn.net/u011035407/article/details/78592787" target="_blank" rel="noopener">朋友圈的设计及实现</a></li>
<li><a href="https://blog.csdn.net/u012244016/article/details/70664959" target="_blank" rel="noopener">微信与朋友圈后台架构</a></li>
<li><a href="https://www.zhihu.com/question/21909660" target="_blank" rel="noopener">微信朋友圈数据库模式如何设计的？</a></li>
<li><a href="https://www.2cto.com/kf/201603/496529.html" target="_blank" rel="noopener">微信与朋友圈后台架构的讲解</a></li>
<li><a href="https://blog.csdn.net/sinat_27564919/article/details/70946319" target="_blank" rel="noopener">控制朋友圈好友状态可见性的数据表设计</a></li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy2x4kvuemj30m108ydhk.jpg" alt="idea"></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy2x4lt2r6j30m70jjwjr.jpg" alt="er"></p>
<h2 id="数据交互逻辑"><a href="#数据交互逻辑" class="headerlink" title="数据交互逻辑"></a>数据交互逻辑</h2><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><blockquote>
<p>匹配password字段—&gt;若成功，登录操作（http协议）进入看板界面，推送Feed流信息，若失败，拒绝访问，“密码错误，请重新输入密码”，超时锁定。  </p>
</blockquote>
<h3 id="刷朋友圈"><a href="#刷朋友圈" class="headerlink" title="刷朋友圈"></a>刷朋友圈</h3><blockquote>
<p>登录成功—&gt;推送publish，按publish_id从大到小排列，展示publish_id最大的20个publish。<br>刷朋友圈的行为即为刷取多个朋友圈信息（publish）对于单个publish:* 获取创建时间—&gt;拉取create_time在左下方显示；<br>* 获取照片—&gt;拉取picture表中，publish_id对应的pic_url；</p>
</blockquote>
<ul>
<li>获取朋友圈文字—&gt;拉取caption；</li>
<li>获取评论—&gt;拉取comment表中，publish_id对应的comment，根据comment_id进行从大到小排序，根据usr_id，检索出usr_name(即评论人)，拉取comments,和comment create_time（整体显示情况即为：评论人，评论，评论创建的时间)；</li>
<li>获取点赞信息—&gt;拉取like表中，publish_id对应的like项，并根据like_id,从大到小排序（整体显示情况即为：点赞人A，点赞人B，点赞人C…）</li>
</ul>
<h3 id="发布朋友圈"><a href="#发布朋友圈" class="headerlink" title="发布朋友圈"></a>发布朋友圈</h3><blockquote>
<p>创建一个新的publish表项，publish_id自增1，根据当前用户，填入当前usr_id,录入当前时间到create_time，将朋友圈文字信息，录入到caption字段中；<br>若有照片，每个照片创建一个picture表项，录入pic_url和当前publish_id，pic_id自增1  </p>
</blockquote>
<h3 id="评论朋友圈"><a href="#评论朋友圈" class="headerlink" title="评论朋友圈"></a>评论朋友圈</h3><blockquote>
<p>创建一个新的comment表项，comment_id自增1，根据当前用户，填入当前usr_id,录入当前时间到create_time，将评论文字信息，录入到comments字段中，并录入当前评论的publish_id；<br>创建Notice，根据当前评论的publish_id，检索，当前Notice表中，具有同样publish_id的Notice，查看其中的from_id和to_id，即为所有相关的用户，创建对应的Notice，notice_id自增1，publish_id即为当前评论的publish_id，type为0（0为评论，1为点赞），from_id为当前评论的用户，to_id依次为检索到的所有用户ID，status为0（0未读，1已读）；  </p>
</blockquote>
<h3 id="点赞朋友圈"><a href="#点赞朋友圈" class="headerlink" title="点赞朋友圈"></a>点赞朋友圈</h3><blockquote>
<p>创建一个新的like表项，like_id自增1，根据当前用户，填入当前usr_id，填入当前点赞的publish_id；<br>创建Notice，根据当前评论的publish_id，检索，当前Notice表中，具有同样publish_id的Notice，查看其中的from_id和to_id，即为所有相关的用户，创建对应的Notice，notice_id自增1，publish_id即为当前评论的publish_id，type为1（0为评论，1为点赞），from_id为当前评论的用户，to_id依次为检索到的所有用户ID，status为0（0未读，1已读）；  </p>
</blockquote>
<h3 id="推送评论通知基本逻辑"><a href="#推送评论通知基本逻辑" class="headerlink" title="推送评论通知基本逻辑"></a>推送评论通知基本逻辑</h3><blockquote>
<ul>
<li><em>接收通知的用户，通知详情需要主动获取</em></li>
<li><em>通知的主动推送，本质为当前用户定时，每秒查看，有多少条未读通知</em> (*)</li>
</ul>
</blockquote>
<ul>
<li>根据Notice表，主动获取通知，定时获取to_id与当前用户usr_id相符，且status字段为0（未读）的Notice。通知格式为“您有N条消息未读”。并同时存储这些Notice的notice_id</li>
<li>当用户点击通知，读取通知时，检索存储的notice_id，将这些Notice的status字段置为1，并根据type获知通知类型，若type=0为评论，则查找comment表项，查找对应publish_id中<code>usr_id=from_id</code>的comments字段，获取评论详情(from_id+comments)，上方要同时拉取对应publish_id的朋友圈详情(usr_id+pic+caption+create_time)；若type=1为点赞，则拉取对应publish_id的朋友圈详情，并显示，”(from_id) like this”，上方要同时拉取对应publish_id的朋友圈详情(usr_id+pic+caption+create_time)</li>
</ul>
<h3 id="通知的几种特殊情况的考虑"><a href="#通知的几种特殊情况的考虑" class="headerlink" title="通知的几种特殊情况的考虑"></a>通知的几种特殊情况的考虑</h3><blockquote>
<ul>
<li>(未评论用户)取消点赞后，需要去掉该用户的Notice</li>
<li>(未点赞用户)删除评论后，需要去掉该用户的Notice</li>
</ul>
</blockquote>
<ul>
<li>阅读过通知后，通知需要保留，将状态置为已读，当后续还有人评论时，可以根据Notice表自动维护之后的通知。</li>
<li>每一次的通知都可以直接通过上一次通知进行维护更新。第一步，找到对应的publish_id中notice_id的最大的一项，找出对应的from_id，即找出了，本朋友圈上一次的通知，是从from_id，通知到了此用户的所有to_id。即所有最新的相关用户群，则更新的Notice为，from_id=当前usr_id，to_id=上一次的from_id+上一次的所有的to_id。</li>
<li><em>初次生成的通知会被立刻调用，所以也可以直接在生成的时候，直接推送。</em> （*）</li>
</ul>
<h2 id="MySQL设计规范"><a href="#MySQL设计规范" class="headerlink" title="MySQL设计规范"></a><a href="/2018/12/11/MySQL基本规范/">MySQL设计规范</a></h2><blockquote>
<p>详情，点击标题跳转页面↑</p>
</blockquote>
<hr>
<h1 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h1><h2 id="接口基础函数"><a href="#接口基础函数" class="headerlink" title="接口基础函数"></a>接口基础函数</h2><h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><blockquote>
<p>Beego框架中，Controller的Prepare函数都会自动在调用其之前先被调用。<br>所以Prepare函数，被我用来写验证相关的代码。</p>
</blockquote>
<p>①假如当前是在进行非登录操作，则需要验证，session_id，若为空，则未登录，跳转到登录操作页面<br>②若不为空，则在redis中进行比对，看是否存在当前用户的session_id，K-VOUSMEVOYEZ结构为“K:session_id,VOUSMEVOYEZ:usr_name”，若查找当前session_id，得到的用户为空，则未登录，跳转到登录操作页面；得到的用户名非空，还需要验证一下用户表中是否存在该用户，不存在则显示为仿冒用户<br>③若不存在session_id的问题，执行完Prepare函数仍未被跳转到登录页面，则继续执行Controller</p>
<h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><p>一个跳转函数，用来控制，当出现错误或者验证安全的问题时，及时做出反馈，当出现系统性错误时，停止系统的运行，当出现验证问题时，及时跳转到所需页面，如登录页面等。<br><strong>msg</strong>：用来描述当前问题，并写入到跳转页面<br><strong>url</strong>：用来描述跳转链接，当为空时，停止运行当前controller</p>
<h3 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h3><blockquote>
<p>Beego框架中，任何Controller的Finish函数都会自动在调用后，最后时刻被调用，所以Finish函数，被我用来写Session的控制。</p>
</blockquote>
<p>①假如当前是在进行非登录登出操作，需要验证后，为当前Session_id，续期30分钟<br>②假如是登录操作，需要为当前用户创建一个session_id,存到redis中，并发送给客户端</p>
<hr>
<h2 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h2><h3 id="Login"><a href="#Login" class="headerlink" title="Login"></a>Login</h3><p><strong>路由</strong>：”/admin/login”<br>用户登录输入用户名密码，以Json格式发送至客户端，若存在Session，且和服务器内Session_id相符，则直接验证通过</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UsrInfo 用户评价时提交的表单</span></span><br><span class="line"><span class="keyword">type</span> UsrInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	UsrName  <span class="keyword">string</span> <span class="string">`form:"usr_name"`</span></span><br><span class="line">	Password <span class="keyword">string</span> <span class="string">`form:"password"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输入</strong>：Body包含用户名密码的Json格式文档，或其他包含Session_id的Json格式文档<br>通过解析Json，解析出用户名，密码，和Session_id：<br>①假如Session_id非空，且在Redis中存在，则更新Redis，直接进入下一步；<br>②假如Session_id非空，但在Redis中不存在，则登录超时，要求重新登录，进入登录界面<br>③假如Session_id为空，则进入登录界面，解析客户端发送过来的用户名密码，若用户名密码匹配，则登录成功，并生成一个Session记录，保存在Redis，同时将Session_id作为输出发送给客户端。否则直接返回“用户名或密码错误”，要求重新登录</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LoginResult 传递登录结果</span></span><br><span class="line"><span class="keyword">type</span> LoginResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	Result    <span class="keyword">bool</span>   <span class="string">`json:"result"`</span></span><br><span class="line">	UsrID     <span class="keyword">int</span>    <span class="string">`json:"usr_id"`</span></span><br><span class="line">	SessionID <span class="keyword">string</span> <span class="string">`json:"session_id"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：验证结果（true/false）+ session_id + usr_id(给客户端保存)</p>
<h3 id="Logout"><a href="#Logout" class="headerlink" title="Logout"></a>Logout</h3><p><strong>路由</strong>：”/admin/login”<br>用户退出登录的时候，需要清除掉当前用户的Session_id。然后跳转到登录页面。</p>
<p><strong>输入</strong>：session_id</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LogoutFeedback 退出登录反馈信息</span></span><br><span class="line"><span class="keyword">type</span> LogoutFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	Result <span class="keyword">bool</span>   <span class="string">`json:"result"`</span></span><br><span class="line">	Info   <span class="keyword">string</span> <span class="string">`json:"info"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：返回到登录界面</p>
<hr>
<h2 id="朋友圈接口"><a href="#朋友圈接口" class="headerlink" title="朋友圈接口"></a>朋友圈接口</h2><h3 id="PostMoment-发布朋友圈"><a href="#PostMoment-发布朋友圈" class="headerlink" title="PostMoment(发布朋友圈)"></a>PostMoment(发布朋友圈)</h3><blockquote>
<p>分析：客户端发布朋友圈，通过表单发送给后台，返回一个publish_id,和发布结果；发布朋友圈时，所需要的信息是，用户名，文字信息，和图片，由此构建表单结构体</p>
</blockquote>
<p><strong>路由</strong>：”/feed/post”</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PushMoment is 发送朋友圈时提交的表单</span></span><br><span class="line"><span class="keyword">type</span> PushMoment <span class="keyword">struct</span> &#123;</span><br><span class="line">	UserName <span class="keyword">string</span>   <span class="string">`form:"usr_name"`</span></span><br><span class="line">	Caption  <span class="keyword">string</span>   <span class="string">`form:"caption"`</span></span><br><span class="line">	PicList  []<span class="keyword">string</span> <span class="string">`form:"pic_list"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输入</strong>：朋友圈所需信息的表单。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PostResult 发布朋友圈后的反馈结果</span></span><br><span class="line"><span class="keyword">type</span> PostResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	Result    <span class="keyword">bool</span>  <span class="string">`json:"result"`</span></span><br><span class="line">	PublishID <span class="keyword">int64</span> <span class="string">`json:"publish_id"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：true or false 若为true 还需要返回一个当前创建成功后，数据库中publish表的publish_id,方便后期加评价和删除朋友圈。</p>
<h3 id="ReadMoment-刷朋友圈"><a href="#ReadMoment-刷朋友圈" class="headerlink" title="ReadMoment(刷朋友圈)"></a>ReadMoment(刷朋友圈)</h3><blockquote>
<p>分析：由于本需求中，所有人都为朋友，所以所有人的展示结果只跟发送展示请求的时间有关（当做一个锚点），读取朋友圈时，不要读取最新的朋友圈信息，即只刷取，锚点以前，请求时的当前数据库数据。如若不然，会导致分页重复，刷新朋友圈为动态操作（和刷朋友圈区分开，刷朋友圈是静态操作）。最新的朋友圈和评论产生时，只轮询读取到通知，而不拉取最新的朋友圈信息。当用户主动刷新的时候，再读取最新的信息。</p>
</blockquote>
<p><strong>路由</strong>：”/feed/circle”<br>用户登录成功跳转至朋友圈界面，查询当前publish列表，记录此时最新的publish（即为Publish_id最大值），记录为publishAnchor，通过锚点进行分页展示。<br>通过publish_id排列，查找20个最新的朋友圈，将所有的数据打包发送出去。</p>
<p><strong>输入</strong>：publish_index（数据类型int，读取朋友圈信息时publish_id的开始处）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MomentFeed 朋友圈数据流</span></span><br><span class="line"><span class="keyword">type</span> MomentFeed <span class="keyword">struct</span> &#123;</span><br><span class="line">	Moments   []models.OneMoment <span class="string">`json:"Moments"`</span></span><br><span class="line">	PublishID <span class="keyword">int</span>                <span class="string">`json:"publish_id"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OneMoment is 单个朋友圈的Json格式</span></span><br><span class="line"><span class="keyword">type</span> OneMoment <span class="keyword">struct</span> &#123;</span><br><span class="line">	PublishID  <span class="keyword">int</span>         <span class="string">`json:"publish_id"`</span></span><br><span class="line">	UserName   <span class="keyword">string</span>      <span class="string">`json:"usr_name"`</span></span><br><span class="line">	Caption    <span class="keyword">string</span>      <span class="string">`json:"caption"`</span></span><br><span class="line">	PicList    []<span class="keyword">string</span>    <span class="string">`json:"pic_list"`</span></span><br><span class="line">	CreateTime <span class="keyword">string</span>      <span class="string">`json:"create_time"`</span></span><br><span class="line">	LikeList   []<span class="keyword">string</span>    <span class="string">`json:"like_list"`</span></span><br><span class="line">	Comments   CommentList <span class="string">`json:"comments"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OneComment is 单个评论传输时的Json格式</span></span><br><span class="line"><span class="keyword">type</span> OneComment <span class="keyword">struct</span> &#123;</span><br><span class="line">	CommentID      <span class="keyword">int</span>    <span class="string">`json:"comment_id"`</span></span><br><span class="line">	UsrName        <span class="keyword">string</span> <span class="string">`json:"usr_name"`</span></span><br><span class="line">	CommentCaption <span class="keyword">string</span> <span class="string">`json:"comment_caption"`</span></span><br><span class="line">	CreateTime     <span class="keyword">string</span> <span class="string">`json:"create_time"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CommentList is 评论列表，Json格式</span></span><br><span class="line"><span class="keyword">type</span> CommentList []OneComment</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：锚点后的20条朋友圈信息（JSON）。创建一个朋友圈整体信息的结构体。</p>
<p><strong>结构体整体要满足</strong>：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fy6f2yb0clj30s90w2dgr.jpg" alt=""></p>
<h3 id="DelMoment-删除朋友圈"><a href="#DelMoment-删除朋友圈" class="headerlink" title="DelMoment(删除朋友圈)"></a>DelMoment(删除朋友圈)</h3><p>根据前端发送来的pubish_id，进行对当前朋友圈的一系列删除，包括，相册表，评论表，点赞表和通知表。<br><strong>路由</strong>：”/feed/del”</p>
<p><strong>输入</strong>：publish_id</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DelFeedInfo 删除朋友圈后的反馈信息</span></span><br><span class="line"><span class="keyword">type</span> DelFeedInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	Result <span class="keyword">bool</span>   <span class="string">`json:"result"`</span></span><br><span class="line">	Info   <span class="keyword">string</span> <span class="string">`json:"info"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：反馈信息，true or false</p>
<hr>
<h2 id="评论接口"><a href="#评论接口" class="headerlink" title="评论接口"></a>评论接口</h2><h3 id="CreateComment-发布评论接口"><a href="#CreateComment-发布评论接口" class="headerlink" title="CreateComment(发布评论接口)"></a>CreateComment(发布评论接口)</h3><p>根据前端发送来的评论信息，建立数据库信息，因为前段发来的评论信息，要有，评论相关文字，评论所属对象，和评论所属朋友圈，故建立表单信息进行接收。</p>
<p><strong>路由</strong>：”/feed/comment/create”</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OneComment 用户评价时提交的表单</span></span><br><span class="line"><span class="keyword">type</span> OneComment <span class="keyword">struct</span> &#123;</span><br><span class="line">	UsrID          <span class="keyword">int</span>    <span class="string">`form:"usr_id"`</span></span><br><span class="line">	UsrName        <span class="keyword">string</span> <span class="string">`form:"usr_name"`</span></span><br><span class="line">	CommentCaption <span class="keyword">string</span> <span class="string">`form:"comment_caption"`</span></span><br><span class="line">	PublishID      <span class="keyword">int</span>    <span class="string">`form:"publish_id"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输入</strong>：form</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CreateCommentFeedback 评论创建反馈</span></span><br><span class="line"><span class="keyword">type</span> CreateCommentFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	CommentID    <span class="keyword">int64</span> <span class="string">`json:"comment_id"`</span></span><br><span class="line">	CreateResult <span class="keyword">bool</span>  <span class="string">`json:"create_result"`</span></span><br><span class="line">	NoticeStatus <span class="keyword">bool</span>  <span class="string">`json:"notice_status"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：反馈信息，返回告诉客户端，该评论的comment_id，以及评论成功与否，通知是否已经建立等确认信息。</p>
<h3 id="DelComment-删除评论接口"><a href="#DelComment-删除评论接口" class="headerlink" title="DelComment(删除评论接口)"></a>DelComment(删除评论接口)</h3><p>给出对应的comment_id，删除所有的相关信息。改动涉及：comment表和notice表</p>
<p><strong>路由</strong>：”/feed/comment/del”</p>
<p><strong>输入</strong>：comment_id</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DelCommentFeedback 评论创建反馈</span></span><br><span class="line"><span class="keyword">type</span> DelCommentFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	DelResult       <span class="keyword">bool</span>   <span class="string">`json:"del_result"`</span></span><br><span class="line">	DelNoticeResult <span class="keyword">bool</span>   <span class="string">`json:"del_notice_status"`</span></span><br><span class="line">	Info            <span class="keyword">string</span> <span class="string">`json:"info"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：反馈信息，返回告诉客户端，评论删除与否，评论涉及的通知信息删除与否。</p>
<hr>
<h2 id="点赞接口"><a href="#点赞接口" class="headerlink" title="点赞接口"></a>点赞接口</h2><h3 id="LIke（点赞）"><a href="#LIke（点赞）" class="headerlink" title="LIke（点赞）"></a>LIke（点赞）</h3><p>点赞过程中，需要在点赞表中建立一条新信息，相应的，点赞通知的建立，需要通过CreateNotice遍历的在Notice表中建立多条信息。所以需要usr_id ,usr_name ，publish_id 三个信息，以上信息以表单形式传递。</p>
<p><strong>路由</strong>：”/feed/like/create</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Like is 前端大赞操作发送来的表单</span></span><br><span class="line"><span class="keyword">type</span> Like <span class="keyword">struct</span> &#123;</span><br><span class="line">	UsrID     <span class="keyword">int</span>    <span class="string">`form:"usr_id"`</span></span><br><span class="line">	UsrName   <span class="keyword">string</span> <span class="string">`form:"usr_name"`</span></span><br><span class="line">	PublishID <span class="keyword">int</span>    <span class="string">`form:"publish_id"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输入</strong>：点赞表单：Like结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CreateLikeFeedback 创建点赞后给出的反馈信息</span></span><br><span class="line"><span class="keyword">type</span> CreateLikeFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	LikeID       <span class="keyword">int</span>  <span class="string">`json:"like_id"`</span></span><br><span class="line">	CreateResult <span class="keyword">bool</span> <span class="string">`json:"create_result"`</span></span><br><span class="line">	NoticeStatus <span class="keyword">bool</span> <span class="string">`json:"notice_status"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：反馈信息，返回告诉客户端，创建的点赞的ID是多少，创建结果如何，通知是否创建成果的信息。</p>
<h3 id="CancelLike-取消点赞"><a href="#CancelLike-取消点赞" class="headerlink" title="CancelLike(取消点赞)"></a>CancelLike(取消点赞)</h3><p>取消点赞，得到取消点赞的对应like_id即可，删除like表中对应的信息，并同时删除对应的通知信息。</p>
<p><strong>路由</strong>：”/feed/like/cancel</p>
<p><strong>输入</strong>：like_id</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CancelLikeFeedback 取消点赞反馈</span></span><br><span class="line"><span class="keyword">type</span> CancelLikeFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	CancelResult    <span class="keyword">bool</span>   <span class="string">`json:"cancel_result"`</span></span><br><span class="line">	DelNoticeResult <span class="keyword">bool</span>   <span class="string">`json:"del_notice_result"`</span></span><br><span class="line">	Info            <span class="keyword">string</span> <span class="string">`json:"info"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：取消的结果，删除通知的结果，以及相关的反馈信息。以便后期对应做出维护。</p>
<hr>
<h2 id="通知接口"><a href="#通知接口" class="headerlink" title="通知接口"></a>通知接口</h2><blockquote>
<p>通知被设计成，创建通知，删除通知为基本函数，穿插在点赞和评论的基本操作当中，并非一个单独的接口，而获取通知被设计成一个接口，目的就是能够随时获得最新的通知，能随时调用这个接口，读取操作可以作为常用接口，而增删通知则不开放为一个接口来调用。</p>
</blockquote>
<h3 id="GetNotice（获得通知）"><a href="#GetNotice（获得通知）" class="headerlink" title="GetNotice（获得通知）"></a>GetNotice（获得通知）</h3><p>获得通知时无需发送多余的信息，直接通过Session即可<br><strong>路由</strong>：feed/notice<br><strong>输入</strong>：session_id （从redis中获得usr_name）<br><strong>输出</strong>：通知信息。通知信息所需要的基本信息可以分析，通知信息的前端展示：<br>①朋友圈有更新的通知：如果有新的朋友圈，一个红点，如果没有，则没有红点；<br>②自己的朋友圈被评论的通知：XX(usr_name)评价了您的“XXX”(某条朋友圈的部分文字信息)；<br>③自己参与的别人的朋友圈被其他人评论的通知：XX(usr_name)评价了“XXX”(某条朋友圈的部分文字信息)；<br>④自己的朋友圈被点赞的通知：XX(usr_name)点赞了您的“XXX”(某条朋友圈的部分文字信息)；<br>⑤自己参与的别人的朋友圈被其他人点赞的通知：XX(usr_name)点赞了“XXX”(某条朋友圈的部分文字信息)；<br>前端展示如上五种通知，则需要知道的信息有：</p>
<ol>
<li>该条通知，是通知有新的朋友圈还是新的评论还是有新的点赞？</li>
<li>publish表单是否有新的内容</li>
<li>评论时，是谁评论了哪条朋友圈</li>
<li>点赞时，是谁点赞了哪条朋友圈</li>
</ol>
<p>即为，publish_id,from_id,notice_type至于这条朋友圈的所属者是不是通知对象本身，可以由客户端自行判断。<br>因为通知的结构体如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OneNotice 单个通知信息</span></span><br><span class="line"><span class="keyword">type</span> OneNotice <span class="keyword">struct</span> &#123;</span><br><span class="line">	NoticeID     <span class="keyword">int</span>    <span class="string">`json:"notice_id"`</span></span><br><span class="line">	PublishID    <span class="keyword">int</span>    <span class="string">`json:"publish_id"`</span><span class="comment">//指向对应的朋友圈</span></span><br><span class="line">	NoticeType   <span class="keyword">int</span>    <span class="string">`json:"notice_type"`</span><span class="comment">//0为评论，1为点赞</span></span><br><span class="line">	CommentID    <span class="keyword">int</span>    <span class="string">`json:"comment_id"`</span></span><br><span class="line">	LikeID       <span class="keyword">int</span>    <span class="string">`json:"like_id"`</span></span><br><span class="line">	FromUserName <span class="keyword">string</span> <span class="string">`json:"from_user_name"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当客户端接收到的publish_id为0时，该条Notice意思是：有新的朋友圈信息。<br>当客户端接收到的publish_id不为0时，(如23)，from_user_name:liuxing1，notice_type:1，该条信息的意思是：23号朋友圈有来自liuxing1的点赞<br>当客户端接收到的publish_id不为0时，(如23)，from_user_name:liuxing1，notice_type:0，该条信息的意思是：23号朋友圈有来自liuxing1的评论</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NoticeList 发送给用户的通知信息</span></span><br><span class="line"><span class="keyword">type</span> NoticeList <span class="keyword">struct</span> &#123;</span><br><span class="line">	Notices []OneNotice <span class="string">`json:"notices"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>故，以上通知列，可以告知用户一切相关的通知信息，点击这些信息的时候，再调取具体的通知信息给用户呈现。</p>
<h3 id="GetInfo-根据通知，来获取相关信息的更新"><a href="#GetInfo-根据通知，来获取相关信息的更新" class="headerlink" title="GetInfo(根据通知，来获取相关信息的更新)"></a>GetInfo(根据通知，来获取相关信息的更新)</h3><p><strong>路由</strong>：feed/getinfo<br>以上五种通知，通知1不会单独呈现，只需要用小红点告知用户有最新动态，刷新朋友圈即可。通知2，3，4，5则会单独呈现，2，3点选的时候，会在上方展示相关朋友圈，下方会显示所有的点赞评论信息，即，将当前发生最新动态的朋友圈的最新状态整个从服务端拉取过来。点赞信息的更新类似。</p>
<p><strong>输入</strong>：通过“session_id”可以得知usr_id,usr_name。只需要publish_id即可进行信息的更新。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NewMoment 回传的最新单条朋友圈详情</span></span><br><span class="line"><span class="keyword">type</span> NewMoment OneMoment</span><br><span class="line"></span><br><span class="line"><span class="comment">//OneMoment is 单个朋友圈的Json格式</span></span><br><span class="line"><span class="keyword">type</span> OneMoment <span class="keyword">struct</span> &#123;</span><br><span class="line">	PublishID  <span class="keyword">int</span>         <span class="string">`json:"publish_id"`</span></span><br><span class="line">	UserName   <span class="keyword">string</span>      <span class="string">`json:"usr_name"`</span></span><br><span class="line">	Caption    <span class="keyword">string</span>      <span class="string">`json:"caption"`</span></span><br><span class="line">	PicList    []<span class="keyword">string</span>    <span class="string">`json:"pic_list"`</span></span><br><span class="line">	CreateTime <span class="keyword">string</span>      <span class="string">`json:"create_time"`</span></span><br><span class="line">	LikeList   []<span class="keyword">string</span>    <span class="string">`json:"like_list"`</span></span><br><span class="line">	Comments   CommentList <span class="string">`json:"comments"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CommentList is 评论列表，Json格式</span></span><br><span class="line"><span class="keyword">type</span> CommentList []OneComment</span><br><span class="line"></span><br><span class="line"><span class="comment">//OneComment 用户评价时提交的表单</span></span><br><span class="line"><span class="keyword">type</span> OneComment <span class="keyword">struct</span> &#123;</span><br><span class="line">	UsrName        <span class="keyword">string</span> <span class="string">`json:"usr_name"`</span></span><br><span class="line">	CommentCaption <span class="keyword">string</span> <span class="string">`form:"comment_caption" json:"comment_caption"`</span></span><br><span class="line">	PublishID      <span class="keyword">int</span>    <span class="string">`form:"publish_id" json:"-"`</span></span><br><span class="line">	CommentID      <span class="keyword">int</span>    <span class="string">`json:"comment_id"`</span></span><br><span class="line">	CreateTime     <span class="keyword">string</span> <span class="string">`json:"create_time"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：单条朋友圈的最新状态。</p>
<h1 id="实现所需知识树"><a href="#实现所需知识树" class="headerlink" title="实现所需知识树"></a>实现所需知识树</h1><h2 id="Beego框架的使用"><a href="#Beego框架的使用" class="headerlink" title="Beego框架的使用"></a><a href="https://beego.me/docs/quickstart/" target="_blank" rel="noopener">Beego框架的使用</a></h2><p><strong>实例</strong><br><a href="https://github.com/beego/samples/tree/master/WebIM" target="_blank" rel="noopener">samples/WebIM at master · beego/samples · GitHub</a></p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>由于需要保持登录状态，所以这里需要用到Session控制<br><a href="https://studygolang.com/articles/15822?fr=sidebar" target="_blank" rel="noopener">Go基础学习记录之如何在Golang中使用Session  - Go语言中文网 - Golang中文社区</a><br><a href="https://beego.me/docs/mvc/controller/session.md" target="_blank" rel="noopener">Session control - beego: simple &amp; powerful Go app framework</a></p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><a href="https://redis.io" target="_blank" rel="noopener">Redis</a></h2><p><a href="/2018/12/11/Redis教程/">Redis 教程</a></p>
<h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><p>Json解析首字母一定要大写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CreateCommentFeedback 评论创建反馈</span></span><br><span class="line"><span class="keyword">type</span> CreateCommentFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	CommentID    <span class="keyword">int64</span> <span class="string">`json:"comment_id"`</span></span><br><span class="line">	CreateResult <span class="keyword">bool</span>  <span class="string">`json:"create_result"`</span></span><br><span class="line">	NoticeStatus <span class="keyword">bool</span>  <span class="string">`json:"notice_status"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码JSON的时候，json:”-“可以让其不参与编码，不然还是会编码，不过不会更名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">PublishID      <span class="keyword">int</span>    <span class="string">`form:"publish_id" json:"-"`</span></span><br></pre></td></tr></table></figure>
<p>若为</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">PublishID      <span class="keyword">int</span>    <span class="string">`form:"publish_id"`</span></span><br></pre></td></tr></table></figure>
<p>编码的时候，还是会有这个字段，并且，显示的是，PublishID:XXX</p>
<p>redis的操作问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Cli.Set(<span class="string">"liuxing1"</span>, <span class="string">"aaaaa"</span>, <span class="number">30</span>*time.Minute)</span><br><span class="line">	a := Cli.Get(<span class="string">"liuxing1"</span>)</span><br><span class="line">	fmt.Println(a.Val())</span><br><span class="line">	fmt.Println(a.String())</span><br><span class="line">	b := Cli.Del(<span class="string">"liuxing"</span>)</span><br><span class="line">	fmt.Println(b.Val())</span><br><span class="line">	c := Cli.Get(<span class="string">"liuxing1"</span>)</span><br><span class="line">	fmt.Println(c.Val())</span><br><span class="line">	fmt.Println(c.Val()==<span class="string">""</span>)</span><br><span class="line">	fmt.Println(c.Err())</span><br><span class="line">	b = Cli.Del(<span class="string">"liuxing1"</span>)</span><br><span class="line">	fmt.Println(b.Val())</span><br><span class="line">	c = Cli.Get(<span class="string">"liuxing1"</span>)</span><br><span class="line">	fmt.Println(c.Val())</span><br><span class="line">	fmt.Println(c.Val()==<span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaaaa</span><br><span class="line">get liuxing1: aaaaa</span><br><span class="line">0</span><br><span class="line">aaaaa</span><br><span class="line">false</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<ul>
<li>「待补充」</li>
</ul>
]]></content>
      <tags>
        <tag>Projects</tag>
        <tag>MySQL</tag>
        <tag>Redis</tag>
        <tag>Beego</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Interview advice</title>
    <url>/2018/12/07/interview/</url>
    <content><![CDATA[<h1 id="如果你是一个Golang面试官，你会问哪些问题"><a href="#如果你是一个Golang面试官，你会问哪些问题" class="headerlink" title="如果你是一个Golang面试官，你会问哪些问题?"></a>如果你是一个Golang面试官，你会问哪些问题?</h1><ul>
<li>语言设计中空引用(null reference)的存在有什么问题？假设你想要将空引用的概念从你的首选语言中移除，可能导致什么结果？</li>
<li>为什么函数式编程重要？什么时候适用函数式语言？</li>
<li>设计(design)、架构(architecture)、功能(functionality)和美学(aesthetic)之间有什么区别？讨论一下。</li>
<li>微软、谷歌、欧朋(opera)和火狐这类公司是如何从他们的浏览器中获利的?</li>
<li>为什么打开TCP套接字有很大的开销？ 封装的重要性体现在哪儿？</li>
<li>什么是实时系统？它与普通系统有什么区别？ 实时语言(real-time language)和堆内存分配(heap memory allocation)之间的关系是什么？ 不变性(Immutability)是指?</li>
<li>(变量的)值只能在创建的时候被设置一次，之后就不能被改变。为什么不变性对写更加安全的代码有帮助？ </li>
<li>可变值(mutable values)和不可变值(immutable values)有哪些优缺点？ </li>
<li>什么是O/R阻抗失衡(Object-Relational impedence mismatch)？ </li>
<li>如果你需要使用缓存，你使用哪些原则来确定缓存的大小？ TCP和HTTP有什么区别？</li>
</ul>
<a id="more"></a>


<p>原文参考：<a href="https://www.jianshu.com/p/6bdb4d3b8eaf" target="_blank" rel="noopener">如果你是一个Golang面试官，你会问哪些问题?</a></p>
]]></content>
      <tags>
        <tag>tap</tag>
      </tags>
  </entry>
</search>
